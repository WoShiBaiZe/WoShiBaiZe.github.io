<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017-12-8.TCP协议]]></title>
    <url>%2F2019%2F12%2F06%2F2017-12-8-TCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP协议]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续化集成实战用户管理服务]]></title>
    <url>%2F2013%2F07%2F18%2FLinux%2FDay70%2C71%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%8C%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%2F101.GitLab%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%88%98%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[持续集成实战用户管理服务部署通用模块项目先将所有被依赖项目（通用模块项目）部署到 Nexus，为项目创建一个 deploy.bat 文件，示例代码如下： 123456789101112131415161718192021222324252627cd ..cd myshop-dependenciescall mvn deploycd ..cd myshop-commonscall mvn deploycd ..cd myshop-commons-domaincall mvn deploycd ..cd myshop-commons-mappercall mvn deploycd ..cd myshop-commons-dubbocall mvn deploycd ..cd myshop-static-backendcall mvn deploycd ..cd myshop-service-user-apicall mvn deploy 持续集成依赖管理项目由于我们所有项目的父工程都是依赖于 myshop-dependencies，所以我们持续集成的第一步是将该项目进行持续集成，在项目目录创建 .gitlab-ci.yml 文件，代码如下： 1234567stages: - deploydeploy: stage: deploy script: - /usr/local/maven/apache-maven-3.5.3/bin/mvn clean install 持续集成服务提供者gitlab-ci.yml12345678910111213141516171819202122232425262728293031# 定义阶段stages: - build - push - run - cleanbuild: stage: build script: - /usr/local/maven/apache-maven-3.5.3/bin/mvn clean package - cp target/myshop-service-user-provider-1.0.0-SNAPSHOT.jar docker - cd docker - docker build -t 192.168.10.133:5000/myshop-service-user-provider:v1.0.0 .push: stage: push script: - docker push 192.168.10.133:5000/myshop-service-user-provider:v1.0.0run: stage: run script: - cd docker - docker-compose down - docker-compose up -dclean: stage: clean script: - docker image prune -f Dockerfile123456789101112131415FROM openjdk:8-jreMAINTAINER Lusifer &lt;topsale@vip.qq.com&gt;ENV APP_VERSION 1.0.0-SNAPSHOTENV DOCKERIZE_VERSION v0.6.1RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \ &amp;&amp; tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \ &amp;&amp; rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gzRUN mkdir /appCOPY myshop-service-user-provider-$APP_VERSION.jar /app/app.jarENTRYPOINT [&quot;dockerize&quot;, &quot;-timeout&quot;, &quot;5m&quot;, &quot;-wait&quot;, &quot;tcp://192.168.10.131:3306&quot;, &quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;]EXPOSE 8501 22222 20881 docker-compose.yml1234567891011121314version: '3.1'services: myshop-service-user-provider: image: 192.168.10.133:5000/myshop-service-user-provider:v1.0.0 container_name: myshop-service-user-provider ports: - 8501:8501 - 22222:22222 - 20881:20881networks: default: external: name: dubbo 持续集成服务消费者gitlab-ci.yml123456789101112131415161718192021222324252627282930stages: - build - push - run - cleanbuild: stage: build script: - /usr/local/maven/apache-maven-3.5.3/bin/mvn clean package - cp target/myshop-service-user-consumer-1.0.0-SNAPSHOT.jar docker - cd docker - docker build -t 192.168.10.133:5000/myshop-service-user-consumer:v1.0.0 .push: stage: push script: - docker push 192.168.10.133:5000/myshop-service-user-consumer:v1.0.0run: stage: run script: - cd docker - docker-compose down - docker-compose up -dclean: stage: clean script: - docker image prune -f Dockerfile123456789101112131415FROM openjdk:8-jreMAINTAINER Lusifer &lt;topsale@vip.qq.com&gt;ENV APP_VERSION 1.0.0-SNAPSHOTENV DOCKERIZE_VERSION v0.6.1RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \ &amp;&amp; tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \ &amp;&amp; rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gzRUN mkdir /appCOPY myshop-service-user-consumer-$APP_VERSION.jar /app/app.jarENTRYPOINT [&quot;dockerize&quot;, &quot;-timeout&quot;, &quot;5m&quot;, &quot;-wait&quot;, &quot;tcp://192.168.10.131:20881&quot;, &quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;]EXPOSE 8601 8701 docker-compose.yml12345678910111213version: '3.1'services: myshop-service-user-consumer: image: 192.168.10.133:5000/myshop-service-user-consumer:v1.0.0 container_name: myshop-service-user-consumer ports: - 8601:8601 - 8701:8701networks: default: external: name: dubbo 注意： 因为 Docker 的沙箱机制，在不同 compose 中部署的项目会在不同的局域网中，为了解决这个问题，我们可以创建一个专门的外部网络，创建命令如下： 1docker network create &lt;网络名&gt;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab Runner 简介]]></title>
    <url>%2F2013%2F07%2F17%2FLinux%2FDay70%2C71%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%8C%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%2F100.GitLab%20%E5%9F%BA%E4%BA%8E%20Docker%20%E5%AE%89%E8%A3%85%20GitLab%20Runner%2F</url>
    <content type="text"><![CDATA[GitLab Runner 简介理解了上面的基本概念之后，有没有觉得少了些什么东西 —— 由谁来执行这些构建任务呢？ 答案就是 GitLab Runner 了！ 想问为什么不是 GitLab CI 来运行那些构建任务？ 一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。 GitLab CI 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 来做拉！ 因为 GitLab Runner 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 GitLab 的性能 基于 Docker 安装 GitLab Runner环境准备 创建工作目录 /usr/local/docker/runner 创建构建目录 /usr/local/docker/runner/environment 下载 jdk-8u221-linux-x64.tar.gz 并复制到 /usr/local/docker/runner/environment 下载 apache-maven-3.6.1-bin.tar.gz 并复制到 /usr/local/docker/runner/environment daemon.json在 /usr/local/docker/runner/environment 目录下创建 daemon.json，用于配置加速器和仓库地址 12345678&#123; "registry-mirrors": [ "https://registry.docker-cn.com" ], "insecure-registries": [ "192.168.10.133:5000" ]&#125; Dockerfile在 /usr/local/docker/runner/environment 目录下创建 Dockerfile 12345678910111213141516171819202122232425262728293031323334353637383940414243444546FROM gitlab/gitlab-runnerMAINTAINER Lusifer &lt;topsale@vip.qq.com&gt;# 修改软件源RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' &gt; /etc/apt/sources.list &amp;&amp; \ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' &gt;&gt; /etc/apt/sources.list &amp;&amp; \ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' &gt;&gt; /etc/apt/sources.list &amp;&amp; \ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' &gt;&gt; /etc/apt/sources.list &amp;&amp; \ apt-get update -y &amp;&amp; \ apt-get clean# 安装 DockerRUN apt-get -y install apt-transport-https ca-certificates curl software-properties-common &amp;&amp; \ curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - &amp;&amp; \ add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable" &amp;&amp; \ apt-get update -y &amp;&amp; \ apt-get install -y docker-ceCOPY daemon.json /etc/docker/daemon.json# 安装 Docker ComposeWORKDIR /usr/local/binRUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-composeRUN chmod +x docker-compose# 安装 JavaRUN mkdir -p /usr/local/javaWORKDIR /usr/local/javaCOPY jdk-8u221-linux-x64.tar.gz /usr/local/javaRUN tar -zxvf jdk-8u221-linux-x64.tar.gz &amp;&amp; \ rm -fr jdk-8u221-linux-x64.tar.gz# 安装 MavenRUN mkdir -p /usr/local/mavenWORKDIR /usr/local/maven# RUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.6.1-bin.tar.gzCOPY apache-maven-3.6.1-bin.tar.gz /usr/local/mavenRUN tar -zxvf apache-maven-3.6.1-bin.tar.gz &amp;&amp; \ rm -fr apache-maven-3.6.1-bin.tar.gz# COPY settings.xml /usr/local/maven/apache-maven-3.6.1/conf/settings.xml# 配置环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_221ENV MAVEN_HOME /usr/local/maven/apache-maven-3.6.1ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/binWORKDIR / docker-compose.yml在 /usr/local/docker/runner 目录下创建 docker-compose.yml 12345678910version: '3.1'services: gitlab-runner: build: environment restart: always container_name: gitlab-runner privileged: true volumes: - ./config:/etc/gitlab-runner - /var/run/docker.sock:/var/run/docker.sock 注册 Runner1234567891011121314151617181920212223242526272829docker exec -it gitlab-runner gitlab-runner register# 输入 GitLab 地址Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://192.168.10.132/# 输入 GitLab TokenPlease enter the gitlab-ci token for this runner:1Lxq_f1NRfCfeNbE5WRh# 输入 Runner 的说明Please enter the gitlab-ci description for this runner:可以为空# 设置 Tag，可以用于指定在构建规定的 tag 时触发 ciPlease enter the gitlab-ci tags for this runner (comma separated):deploy# 这里选择 true ，可以用于代码上传后直接执行Whether to run untagged builds [true/false]:true# 这里选择 false，可以直接回车，默认为 falseWhether to lock Runner to current project [true/false]:false# 选择 runner 执行器，这里我们选择的是 shellPlease enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:shell 使用 RunnerGitLab CI 地址与令牌参数1项目` –&gt; `设置` –&gt; `CI/CD` –&gt; `Runner 设置 .gitlab-ci.yml在项目工程下编写 .gitlab-ci.yml 配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758stages: - install_deps - test - build - deploy_test - deploy_productioncache: key: $&#123;CI_BUILD_REF_NAME&#125; paths: - node_modules/ - dist/# 安装依赖install_deps: stage: install_deps only: - develop - master script: - npm install# 运行测试用例test: stage: test only: - develop - master script: - npm run test# 编译build: stage: build only: - develop - master script: - npm run clean - npm run build:client - npm run build:server# 部署测试服务器deploy_test: stage: deploy_test only: - develop script: - pm2 delete app || true - pm2 start app.js --name app# 部署生产服务器deploy_production: stage: deploy_production only: - master script: - bash scripts/deploy/deploy.sh 上面的配置把一次 Pipeline 分成五个阶段： 安装依赖(install_deps 运行测试(test) 编译(build) 部署测试服务器(deploy_test) 部署生产服务器(deploy_production) 注意： 设置 Job.only 后，只有当 develop 分支和 master 分支有提交的时候才会触发相关的 Jobs。 节点说明： stages：定义构建阶段，这里只有一个阶段 deploy deploy：构建阶段 deploy 的详细配置也就是任务配置 script：需要执行的 shell 脚本 only：这里的 master 指在提交到 master 时执行 tags：与注册 runner 时的 tag 匹配 测试集成效果所有操作完成后 push 代码到服务器，查看是否成功： passed 表示执行成功 其它命令 删除注册信息 1gitlab-ci-multi-runner unregister --name "名称" 查看注册列表 1gitlab-ci-multi-runner list 附：项目配置 Dockerfile 案例12345678910111213141516FROM openjdk:8-jreMAINTAINER Lusifer &lt;topsale@vip.qq.com&gt;ENV APP_VERSION 1.0.0-SNAPSHOTENV DOCKERIZE_VERSION v0.6.1RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \ &amp;&amp; tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \ &amp;&amp; rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gzRUN mkdir /appCOPY myshop-service-user-provider-$APP_VERSION.jar /app/app.jarENTRYPOINT ["dockerize", "-timeout", "5m", "-wait", "tcp://192.168.10.131:3306", "java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "/app/app.jar"]EXPOSE 8501]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab持续化集成]]></title>
    <url>%2F2013%2F07%2F16%2FLinux%2FDay70%2C71%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%8C%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%2F099.GitLab%20%E4%BD%BF%E7%94%A8%20GitLab%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[简介从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只要在项目中添加一个 .gitlab-ci.yml 文件，然后添加一个 Runner，即可进行持续集成。 而且随着 GitLab 的升级，GitLab CI 变得越来越强大。 概念Pipeline一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。 任何提交或者 Merge Request 的合并都可以触发 Pipeline，如下图所示： 12345+------------------+ +----------------+| | trigger | || Commit / MR +----------&gt;+ Pipeline || | | |+------------------+ +----------------+ StagesStages 表示构建阶段，说白了就是上面提到的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点： 所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始 只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功 如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败 因此，Stages 和 Pipeline 的关系就是： 123456789+--------------------------------------------------------+| || Pipeline || || +-----------+ +------------+ +------------+ || | Stage 1 |----&gt;| Stage 2 |-----&gt;| Stage 3 | || +-----------+ +------------+ +------------+ || |+--------------------------------------------------------+ JobsJobs 表示构建工作，表示某个 Stage 里面执行的工作。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点： 相同 Stage 中的 Jobs 会并行执行 相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功 如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败 所以，Jobs 和 Stage 的关系图就是： 123456789+------------------------------------------+| || Stage 1 || || +---------+ +---------+ +---------+ || | Job 1 | | Job 2 | | Job 3 | || +---------+ +---------+ +---------+ || |+------------------------------------------+]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab持续化集成操作流程]]></title>
    <url>%2F2013%2F07%2F15%2FLinux%2FDay70%2C71%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%8C%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%2F098.GitLab%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述根据持续集成的设计，代码从提交到生产，整个过程有以下几步。 提交流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。 测试（第一轮）代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 测试的种类： 单元测试：针对函数或模块的测试 集成测试：针对整体产品的某个功能的测试，又称功能测试 端对端测试：从用户界面直达数据库的全链路测试 第一轮至少要跑单元测试。 构建通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 常用的构建工具如下： Jenkins Travis Codeship Strider Jenkins 和 Strider 是开源软件，Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。 测试（第二轮）构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。 第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。 需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。 部署通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有Ansible，Chef，Puppet等。 回滚一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续化集成(CI)]]></title>
    <url>%2F2013%2F07%2F14%2FLinux%2FDay70%2C71%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%8C%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%2F097.GitLab%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[概述互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）。 持续集成持续集成指的是，频繁地（一天多次）将代码集成到主干。它的好处主要有两个： 快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 Martin Fowler 说过，”持续集成并不能消除 Bug，而是让它们非常容易发现和改正。” 持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。 与持续集成相关的，还有两个概念，分别是持续交付和持续部署。 持续交付持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。 持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。 持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。 持续部署持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。 持续部署的前提是能自动化完成测试、构建、部署等步骤。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 模板文件]]></title>
    <url>%2F2013%2F07%2F13%2FLinux%2FDay59_DockerCompose%2F%E9%99%84%EF%BC%9ADocker%20Compose%20%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Docker Compose 模板文件模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。 123456789version: "3"services: webapp: image: examples/web ports: - "80:80" volumes: - "/data" 注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。 如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。 下面分别介绍各个指令的用法。 build指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 12345version: '3'services: webapp: build: ./dir 你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。使用 dockerfile 指令指定 Dockerfile 文件名。使用 arg 指令指定构建镜像时的变量。 123456789version: '3'services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 使用 cache_from 指定构建镜像的缓存 12345build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add, cap_drop指定容器的内核能力（capacity）分配。例如，让容器拥有所有能力可以指定为： 12cap_add: - ALL 去掉 NET_ADMIN 能力可以指定为： 12cap_drop: - NET_ADMIN command覆盖容器启动后默认执行的命令。 1command: echo "hello world" configs仅用于 Swarm mode cgroup_parent指定父 cgroup 组，意味着将继承该组的资源限制。例如，创建了一个 cgroup 组名称为 cgroups_1。 1cgroup_parent: cgroups_1 container_name指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。 1container_name: docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。 deploy仅用于 Swarm mode devices指定设备映射关系。 12devices: - "/dev/ttyUSB1:/dev/ttyUSB0" depends_on解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web 1234567891011121314version: '3'services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意： web 服务不会等待 redis db 「完全启动」之后才启动。 dns自定义 DNS 服务器。可以是一个值，也可以是一个列表。 12345dns: 8.8.8.8dns: - 8.8.8.8 - 114.114.114.114 dns_search配置 DNS 搜索域。可以是一个值，也可以是一个列表。 12345dns_search: example.comdns_search: - domain1.example.com - domain2.example.com tmpfs挂载一个 tmpfs 文件系统到容器。 1234tmpfs: /runtmpfs: - /run - /tmp env_file从文件中获取环境变量，可以为单独的文件路径或列表。如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。 123456env_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。 12# common.env: Set development environmentPROG_ENV=development environment设置环境变量。你可以使用数组或字典两种格式。 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。 1234567environment: RACK_ENV: development SESSION_SECRET:environment: - RACK_ENV=development - SESSION_SECRET 如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括 1y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF expose暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数 123expose: - "3000" - "8000" external_links 注意： 不建议使用该指令。 链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。 1234external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql extra_hosts类似 Docker 中的 --add-host 参数，指定额外的 host 名称映射信息。 123extra_hosts: - "googledns:8.8.8.8" - "dockerhub:52.1.157.61" 会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。 128.8.8.8 googledns52.1.157.61 dockerhub healthcheck通过命令检查容器是否健康运行。 12345healthcheck: test: ["CMD", "curl", "-f", "http://localhost"] interval: 1m30s timeout: 10s retries: 3 image指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 123image: ubuntuimage: orchardup/postgresqlimage: a4bc65fd labels为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。 1234labels: com.startupteam.description: "webapp for a startup team" com.startupteam.department: "devops department" com.startupteam.release: "rc3 for v1.0" links 注意：不推荐使用该指令。 logging配置日志选项。 1234logging: driver: syslog options: syslog-address: "tcp://192.168.0.42:123" 目前支持三种日志驱动类型。 123driver: "json-file"driver: "syslog"driver: "none" options 配置日志驱动的相关参数。 123options: max-size: "200k" max-file: "10" network_mode设置网络模式。使用和 docker run 的 --network 参数一样的值。 12345network_mode: "bridge"network_mode: "host"network_mode: "none"network_mode: "service:[service name]"network_mode: "container:[container name/id]" networks配置容器连接的网络。 1234567891011version: "3"services: some-service: networks: - some-network - other-networknetworks: some-network: other-network: pid跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。 1pid: "host" ports暴露端口信息。 使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。 12345ports: - "3000" - "8000:8000" - "49100:22" - "127.0.0.1:8001:8001" 注意： 当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。 secrets存储敏感数据，例如 mysql 服务密码。 12345678910111213141516version: "3.1"services:mysql: image: mysql environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password secrets: - db_root_password - my_other_secretsecrets: my_secret: file: ./my_secret.txt my_other_secret: external: true security_opt指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。 123security_opt: - label:user:USER - label:role:ROLE stop_signal设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。 1stop_signal: SIGUSR1 sysctls配置容器内核参数。 1234567sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0 ulimits指定容器的 ulimits 限制值。 例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。 12345ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 volumes数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。 该指令中路径支持相对路径。 1234volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro 其它指令此外，还有包括 domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir 等指令，基本跟 docker run 中对应参数的功能一致。 指定服务容器启动后执行的入口文件。 1entrypoint: /code/entrypoint.sh 指定容器中运行应用的用户名。 1user: nginx 指定容器中工作目录。 1working_dir: /code 指定容器中搜索域名、主机名、mac 地址等。 123domainname: your_website.comhostname: testmac_address: 08-00-27-00-0C-0A 允许容器中运行一些特权命令。 1privileged: true 指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。 1restart: always 以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。 1read_only: true 打开标准输入，可以接受外部输入。 1stdin_open: true 模拟一个伪终端。 1tty: true 读取变量Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。 例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 12345version: "3"services:db: image: "mongo:$&#123;MONGO_VERSION&#125;" 如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。在当前目录新建 .env 文件并写入以下内容。 12# 支持 # 号注释MONGO_VERSION=3.6 执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 命令说明]]></title>
    <url>%2F2013%2F07%2F12%2FLinux%2FDay59_DockerCompose%2F%E9%99%84%EF%BC%9ADocker%20Compose%20%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Docker Compose 命令说明命令对象与格式对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。 执行 docker-compose [COMMAND] --help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。docker-compose 命令的基本的使用格式是 1docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...] 命令选项 -f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 --x-networking 使用 Docker 的可拔插网络后端特性 --x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge --verbose 输出更多调试信息。 -v, --version 打印版本并退出。 build格式为 docker-compose build [options] [SERVICE...]。 构建（重新构建）项目中的服务容器。 服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。 可以随时在项目目录下运行 docker-compose build 来重新构建服务。 选项包括： --force-rm 删除构建过程中的临时容器。 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。 --pull 始终尝试通过 pull 来获取更新版本的镜像。 config验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。 down此命令将会停止 up 命令所启动的容器，并移除网络 exec进入指定的容器。 help获得一个命令的帮助。 images列出 Compose 文件中包含的镜像。 kill格式为 docker-compose kill [options] [SERVICE...]。 通过发送 SIGKILL 信号来强制停止服务容器。 支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。 1docker-compose kill -s SIGINT logs格式为 docker-compose logs [options] [SERVICE...]。 查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 --no-color 来关闭颜色。 该命令在调试问题的时候十分有用。 pause格式为 docker-compose pause [SERVICE...]。 暂停一个服务容器。 port格式为 docker-compose port [options] SERVICE PRIVATE_PORT。 打印某个容器端口所映射的公共端口。 选项： --protocol=proto 指定端口协议，tcp（默认值）或者 udp。 --index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。 ps格式为 docker-compose ps [options] [SERVICE...]。 列出项目中目前的所有容器。 选项： -q 只打印容器的 ID 信息。 pull格式为 docker-compose pull [options] [SERVICE...]。 拉取服务依赖的镜像。 选项： --ignore-pull-failures 忽略拉取镜像过程中的错误。 push推送服务依赖的镜像到 Docker 镜像仓库。 restart格式为 docker-compose restart [options] [SERVICE...]。 重启项目中的服务。 选项： -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。 rm格式为 docker-compose rm [options] [SERVICE...]。 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。 选项： -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。 -v 删除容器所挂载的数据卷。 run格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。 在指定服务上执行一个命令。 例如： 1docker-compose run ubuntu ping docker.com 将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。 默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。 该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。 两个不同点： 给定命令将会覆盖原有的自动运行命令； 不会自动创建端口，以避免冲突。 如果不希望自动启动关联的容器，可以使用 --no-deps 选项，例如 1docker-compose run --no-deps web python manage.py shell 将不会启动 web 容器所关联的其它容器。 选项： -d 后台运行容器。 --name NAME 为容器指定一个名字。 --entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, --user=&quot;&quot; 指定运行容器的用户名或者 uid。 --no-deps 不自动启动关联的服务容器。 --rm 运行命令后自动删除容器，d 模式下将忽略。 -p, --publish=[] 映射容器端口到本地主机。 --service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 scale格式为 docker-compose scale [options] [SERVICE=NUM...]。 设置指定服务运行的容器个数。 通过 service=num 的参数来设置数量。例如： 1docker-compose scale web=3 db=2 将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。 一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 start格式为 docker-compose start [SERVICE...]。 启动已经存在的服务容器。 stop格式为 docker-compose stop [options] [SERVICE...]。 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 top查看各个服务容器内运行的进程。 unpause格式为 docker-compose unpause [SERVICE...]。 恢复处于暂停状态中的服务。 up格式为 docker-compose up [options] [SERVICE...]。 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。 链接的服务都将会被自动启动，除非已经处于运行状态。 可以说，大部分时候都可以直接通过该命令来启动一个项目。 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。 当通过 Ctrl-C 停止命令时，所有容器将会停止。 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d &lt;SERVICE_NAME&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。 选项： -d 在后台运行服务容器。 --no-color 不使用颜色来区分不同的服务的控制台输出。 --no-deps 不启动服务所链接的容器。 --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。 --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。 --no-build 不自动构建缺失的服务镜像。 -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 version格式为 docker-compose version。 打印版本信息。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 网路设置]]></title>
    <url>%2F2013%2F07%2F11%2FLinux%2FDay59_DockerCompose%2F031.DockerCompose-%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Docker Compose 网络设置概述默认情况下，Compose 会为我们的应用创建一个网络，服务的每个容器都会加入该网络中。这样，容器就可被该网络中的其他容器访问，不仅如此，该容器还能以服务名称作为 Hostname 被其他容器访问。 默认情况下，应用程序的网络名称基于 Compose 的工程名称，而项目名称基于 docker-compose.yml 所在目录的名称。如需修改工程名称，可使用 --project-name 标识或 COMPOSE_PORJECT_NAME 环境变量。 假如一个应用程序在名为 myapp 的目录中，并且 docker-compose.yml 如下所示： 12345678version: '2'services: web: build: . ports: - "8000:8000" db: image: postgres 当我们运行 docker-compose up 时，将会执行以下几步： 创建一个名为 myapp_default 的网络 使用 web 服务的配置创建容器，它以 web 这个名称加入网络 myapp_default 使用 db 服务的配置创建容器，它以 db 这个名称加入网络 myapp_default 容器间可使用服务名称（web 或 db）作为 Hostname 相互访问。例如，web 这个服务可使用 postgres://db:5432 访问 db 容器。 当服务的配置发生更改时，可使用 docker-compose up 命令更新配置。此时，Compose 会删除旧容器并创建新容器。新容器会以不同的 IP 地址加入网络，名称保持不变。任何指向旧容器的连接都会被关闭，容器会重新找到新容器并连接上去。 使用 links默认情况下，服务之间可使用服务名称相互访问。links 允许我们定义一个别名，从而使用该别名访问其他服务。 12345678version: '2'services: web: build: . links: - "db:database" db: image: postgres 自定义网络一些场景下，默认的网络配置满足不了我们的需求，此时我们可使用 networks 命令自定义网络。networks 命令允许我们创建更加复杂的网络拓扑并指定自定义网络驱动和选项。不仅如此，我们还可使用 networks 将服务连接到不是由 Compose 管理的、外部创建的网络。 123456789101112131415161718192021222324252627version: '2'services: proxy: build: ./proxy networks: - front app: build: ./app networks: - front - back db: image: postgres networks: - backnetworks: front: # Use a custom driver driver: custom-driver-1 back: # Use a custom driver which takes special options driver: custom-driver-2 driver_opts: foo: "1" bar: "2" 其中，proxy 服务与 db 服务隔离，两者分别使用自己的网络；app 服务可与两者通信。使用 networks 命令，即可方便实现服务间的网络隔离与连接。 配置默认网络1234567891011121314version: '2'services: web: build: . ports: - "8000:8000" db: image: postgresnetworks: default: # Use a custom driver driver: custom-driver-1 这样，就可为该应用指定自定义的网络驱动 已存在的网络我们可以预先创建一个名为 myapp 的网络，让 Compose 加入这个新创建的网络，使所有 Compose 可以通信，此时使用 external 选项。 12345# 创建网络docker network create &lt;Network Name&gt;# 查看已存在的网络docker network list 1234networks: default: external: name: myapp 一次构建，到处运行请参考本节视频]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 部署 Harbor]]></title>
    <url>%2F2013%2F07%2F10%2FLinux%2FDay59_DockerCompose%2F030.DockerCompose-%E9%83%A8%E7%BD%B2%20Harbor%2F</url>
    <content type="text"><![CDATA[Docker Compose 部署 Harbor什么是 HarborHarbor 是一个用于存储和分发 Docker 镜像的企业级 Registry 服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源 Docker Distribution。作为一个企业级私有 Registry 服务器，Harbor 提供了更好的性能和安全。提升用户使用 Registry 构建和运行环境传输镜像的效率。Harbor 支持安装在多个 Registry 节点的镜像资源复制，镜像全部保存在私有 Registry 中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor 也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。 Harbor 特性 基于角色的访问控制 ： 用户与 Docker 镜像仓库通过 “项目” 进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限。 镜像复制 ： 镜像可以在多个 Registry 实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景。 图形化用户界面 ： 用户可以通过浏览器来浏览，检索当前 Docker 镜像仓库，管理项目和命名空间。 AD/LDAP 支持 ： Harbor 可以集成企业内部已有的 AD/LDAP，用于鉴权认证管理。 审计管理 ： 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。 国际化 ： 已拥有英文、中文、德文、日文和俄文的本地化版本。更多的语言将会添加进来。 RESTful API ： RESTful API 提供给管理员对于 Harbor 更多的操控，使得与其它管理软件集成变得更容易。 部署简单 ： 提供在线和离线两种安装工具， 也可以安装到 vSphere 平台 (OVA 方式) 虚拟设备。 Harbor 组件 Proxy： Harbor 的 registry, UI, token 等服务，通过一个前置的反向代理统一接收浏览器、Docker 客户端的请求，并将请求转发给后端不同的服务。 Registry： 负责储存 Docker 镜像，并处理 docker push/pull 命令。由于我们要对用户进行访问控制，即不同用户对 Docker image 有不同的读写权限，Registry 会指向一个 token 服务，强制用户的每次 docker pull/push 请求都要携带一个合法的 token, Registry 会通过公钥对 token 进行解密验证。 Core services： 这是 Harbor 的核心功能，主要提供以下服务： UI： 提供图形化界面，帮助用户管理 registry 上的镜像（image）, 并对用户进行授权。 WebHook： 为了及时获取 registry 上 image 状态变化的情况， 在 Registry 上配置 webhook，把状态变化传递给 UI 模块。 Token： 负责根据用户权限给每个 docker push/pull 命令签发 token. Docker 客户端向 - Registry 服务发起的请求，如果不包含 token，会被重定向到这里，获得 token 后再重新向 Registry 进行请求。 Database： 为 core services 提供数据库服务，负责储存用户权限、审计日志、Docker image 分组信息等数据。 Job Services： 提供镜像远程复制功能，可以把本地镜像同步到其他 Harbor 实例中。 Log Collector： 为了帮助监控 Harbor 运行，负责收集其他组件的 log，供日后进行分析。 安装 Harbor官方 GitHub 上下载最新离线安装版（我已经下载并放置在群分享的 Linux 目录下）并上传至服务器 解压安装包12345678tar -zxvf harbor-offline-installer-v1.8.0.tgz# 输出如下harbor/harbor.v1.8.0.tar.gzharbor/prepareharbor/LICENSEharbor/install.shharbor/harbor.yml 修改配置文件1234vi harbor.yml# 修改为域名或你服务器 IPhostname: 192.168.141.150 执行安装脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137./install.sh# 输出如下[Step 0]: checking installation environment ...Note: docker version: 18.09.6Note: docker-compose version: 1.24.0[Step 1]: loading Harbor images ...23d9f72a5270: Loading layer [==================================================&gt;] 33.25MB/33.25MB1d4a1da12c02: Loading layer [==================================================&gt;] 50.51MB/50.51MB8eb1a006f3b0: Loading layer [==================================================&gt;] 3.584kB/3.584kB41b6f75847f4: Loading layer [==================================================&gt;] 3.072kB/3.072kBec9bd6e4d4e8: Loading layer [==================================================&gt;] 2.56kB/2.56kB6d852bb664c2: Loading layer [==================================================&gt;] 3.072kB/3.072kB0e4ed2b5a5b8: Loading layer [==================================================&gt;] 3.584kB/3.584kB8dfb2b644f30: Loading layer [==================================================&gt;] 12.29kB/12.29kBLoaded image: goharbor/harbor-log:v1.8.0d8c53538042b: Loading layer [==================================================&gt;] 63.34MB/63.34MB1b5fb7ee22e0: Loading layer [==================================================&gt;] 47.96MB/47.96MBa8bdca5e9d71: Loading layer [==================================================&gt;] 6.656kB/6.656kBf7cec940b52c: Loading layer [==================================================&gt;] 2.048kB/2.048kB301a4a2af7db: Loading layer [==================================================&gt;] 7.68kB/7.68kBe588e1e3a775: Loading layer [==================================================&gt;] 2.56kB/2.56kB539f28a5d0ea: Loading layer [==================================================&gt;] 2.56kB/2.56kB8b4a72241226: Loading layer [==================================================&gt;] 2.56kB/2.56kBLoaded image: goharbor/harbor-db:v1.8.0c88db349fb2f: Loading layer [==================================================&gt;] 8.972MB/8.972MB1f2d4d72bba2: Loading layer [==================================================&gt;] 35.77MB/35.77MBdddbcf598df5: Loading layer [==================================================&gt;] 2.048kB/2.048kB0ced476c2d9c: Loading layer [==================================================&gt;] 3.072kB/3.072kBaf24eb0bf40b: Loading layer [==================================================&gt;] 35.77MB/35.77MBLoaded image: goharbor/chartmuseum-photon:v0.8.1-v1.8.0b185d348bd7d: Loading layer [==================================================&gt;] 2.56kB/2.56kBf032ded7f92e: Loading layer [==================================================&gt;] 1.536kB/1.536kBc6c822edbc47: Loading layer [==================================================&gt;] 66.9MB/66.9MB73ef3c4363bf: Loading layer [==================================================&gt;] 39.75MB/39.75MB0c490e002448: Loading layer [==================================================&gt;] 144.4kB/144.4kB31afe2abafb4: Loading layer [==================================================&gt;] 3.004MB/3.004MBLoaded image: goharbor/prepare:v1.8.0257ebcc1c9c4: Loading layer [==================================================&gt;] 8.967MB/8.967MB7579d3c94fca: Loading layer [==================================================&gt;] 38.68MB/38.68MB323611f7dd17: Loading layer [==================================================&gt;] 38.68MB/38.68MBLoaded image: goharbor/harbor-jobservice:v1.8.0587a5757a7f6: Loading layer [==================================================&gt;] 3.548MB/3.548MBLoaded image: goharbor/nginx-photon:v1.8.0a61ab2060e6e: Loading layer [==================================================&gt;] 8.967MB/8.967MB25359ae00f57: Loading layer [==================================================&gt;] 5.143MB/5.143MB610a1668f8bf: Loading layer [==================================================&gt;] 15.13MB/15.13MBdb2252abd9e0: Loading layer [==================================================&gt;] 26.47MB/26.47MB4f406312560b: Loading layer [==================================================&gt;] 22.02kB/22.02kB1cee0947e5a7: Loading layer [==================================================&gt;] 3.072kB/3.072kB48db2b9b0752: Loading layer [==================================================&gt;] 46.74MB/46.74MBLoaded image: goharbor/notary-server-photon:v0.6.1-v1.8.0aaf447150765: Loading layer [==================================================&gt;] 113MB/113MB6835441e1a1d: Loading layer [==================================================&gt;] 10.94MB/10.94MB9f4739e3a532: Loading layer [==================================================&gt;] 2.048kB/2.048kB928f489135f0: Loading layer [==================================================&gt;] 48.13kB/48.13kB1495a1a09ada: Loading layer [==================================================&gt;] 3.072kB/3.072kB1a5f5b141717: Loading layer [==================================================&gt;] 10.99MB/10.99MBLoaded image: goharbor/clair-photon:v2.0.8-v1.8.066006ea937c6: Loading layer [==================================================&gt;] 337.8MB/337.8MBd272ba122880: Loading layer [==================================================&gt;] 106.5kB/106.5kBLoaded image: goharbor/harbor-migrator:v1.8.005bc5efb1724: Loading layer [==================================================&gt;] 8.967MB/8.967MBaf3a6f89469a: Loading layer [==================================================&gt;] 46.85MB/46.85MB452d238b3e48: Loading layer [==================================================&gt;] 5.632kB/5.632kB36e1cb2d6ffa: Loading layer [==================================================&gt;] 27.14kB/27.14kB5385ffb8451e: Loading layer [==================================================&gt;] 46.85MB/46.85MBLoaded image: goharbor/harbor-core:v1.8.0268091c30a67: Loading layer [==================================================&gt;] 71.66MB/71.66MB4433bcd802e7: Loading layer [==================================================&gt;] 3.072kB/3.072kB420b26399278: Loading layer [==================================================&gt;] 59.9kB/59.9kB8864c4b9ac3d: Loading layer [==================================================&gt;] 61.95kB/61.95kBLoaded image: goharbor/redis-photon:v1.8.063645c97bf5d: Loading layer [==================================================&gt;] 8.968MB/8.968MBccb295818ad9: Loading layer [==================================================&gt;] 3.072kB/3.072kB1ec2d1eefa8f: Loading layer [==================================================&gt;] 2.56kB/2.56kBb88acf0f9f5f: Loading layer [==================================================&gt;] 20.1MB/20.1MB0e7375de12e6: Loading layer [==================================================&gt;] 20.1MB/20.1MBLoaded image: goharbor/registry-photon:v2.7.1-patch-2819-v1.8.0444b0c8bfeee: Loading layer [==================================================&gt;] 3.548MB/3.548MBed0415346760: Loading layer [==================================================&gt;] 6.568MB/6.568MB572bd51089e0: Loading layer [==================================================&gt;] 160.8kB/160.8kB1410c2919a92: Loading layer [==================================================&gt;] 215kB/215kB8ecdca210598: Loading layer [==================================================&gt;] 3.584kB/3.584kBLoaded image: goharbor/harbor-portal:v1.8.07fb66591fb58: Loading layer [==================================================&gt;] 8.968MB/8.968MB42ec4a6394bf: Loading layer [==================================================&gt;] 3.072kB/3.072kBbe6c2180cb57: Loading layer [==================================================&gt;] 20.1MB/20.1MBd956d9e974c5: Loading layer [==================================================&gt;] 3.072kB/3.072kBe2e0b4f17ad8: Loading layer [==================================================&gt;] 7.465MB/7.465MB7e29d670afe9: Loading layer [==================================================&gt;] 27.56MB/27.56MBLoaded image: goharbor/harbor-registryctl:v1.8.0453732ea69d4: Loading layer [==================================================&gt;] 13.72MB/13.72MBc985f3824f33: Loading layer [==================================================&gt;] 26.47MB/26.47MB76eaa2763221: Loading layer [==================================================&gt;] 22.02kB/22.02kB0ef55a752948: Loading layer [==================================================&gt;] 3.072kB/3.072kBc5749b90723d: Loading layer [==================================================&gt;] 45.33MB/45.33MBLoaded image: goharbor/notary-signer-photon:v0.6.1-v1.8.0[Step 2]: preparing environment ...prepare base dir is set to /usr/local/docker/harbor/harborGenerated configuration file: /config/log/logrotate.confGenerated configuration file: /config/nginx/nginx.confGenerated configuration file: /config/core/envGenerated configuration file: /config/core/app.confGenerated configuration file: /config/registry/config.ymlGenerated configuration file: /config/registryctl/envGenerated configuration file: /config/db/envGenerated configuration file: /config/jobservice/envGenerated configuration file: /config/jobservice/config.ymlGenerated and saved secret to file: /secret/keys/secretkeyGenerated certificate, key file: /secret/core/private_key.pem, cert file: /secret/registry/root.crtGenerated configuration file: /compose_location/docker-compose.ymlClean up the input dir[Step 3]: starting Harbor ...Creating network "harbor_harbor" with the default driverCreating harbor-log ... doneCreating harbor-db ... doneCreating registryctl ... doneCreating redis ... doneCreating registry ... doneCreating harbor-core ... doneCreating harbor-jobservice ... doneCreating harbor-portal ... doneCreating nginx ... done✔ ----Harbor has been installed and started successfully.----Now you should be able to visit the admin portal at http://192.168.141.150. For more details, please visit https://github.com/goharbor/harbor . 验证安装是否成功通过浏览器访问 http://192.168.141.150 ，看到登录页面 输入账号 admin，密码 Harbor12345，登录成功后 Harbor 启动和停止Harbor 的日常运维管理是通过 docker-compose 来完成的，Harbor 本身有多个服务进程，都放在 docker 容器之中运行，我们可以通过 docker ps 命令查看。 123456789101112docker ps | grep goharbor# 输出如下07b401504357 goharbor/nginx-photon:v1.8.0 "nginx -g 'daemon of…" 23 minutes ago Up 23 minutes (healthy) 0.0.0.0:80-&gt;80/tcp nginx050f39a147bc goharbor/harbor-portal:v1.8.0 "nginx -g 'daemon of…" 23 minutes ago Up 23 minutes (healthy) 80/tcp harbor-portal305077bc0a3e goharbor/harbor-jobservice:v1.8.0 "/harbor/start.sh" 23 minutes ago Up 23 minutes harbor-jobservice4eb33b09b268 goharbor/harbor-core:v1.8.0 "/harbor/start.sh" 23 minutes ago Up 23 minutes (healthy) harbor-coree9efb7a6abf9 goharbor/registry-photon:v2.7.1-patch-2819-v1.8.0 "/entrypoint.sh /etc…" 24 minutes ago Up 23 minutes (healthy) 5000/tcp registryf9bc75d47752 goharbor/harbor-registryctl:v1.8.0 "/harbor/start.sh" 24 minutes ago Up 23 minutes (healthy) registryctl76d33d1755f6 goharbor/redis-photon:v1.8.0 "docker-entrypoint.s…" 24 minutes ago Up 23 minutes 6379/tcp redis3870b3b93f46 goharbor/harbor-db:v1.8.0 "/entrypoint.sh post…" 24 minutes ago Up 23 minutes (healthy) 5432/tcp harbor-db6e848e4d8bc2 goharbor/harbor-log:v1.8.0 "/bin/sh -c /usr/loc…" 24 minutes ago Up 24 minutes (healthy) 127.0.0.1:1514-&gt;10514/tcp harbor-log 12345678# 启动docker-compose start# 停止docker-comose stop# 重启docker-compose restart 说明： nginx： nginx 负责流量转发和安全验证，对外提供的流量都是从 nginx 中转，所以开放 https 的 443 端口，它将流量分发到后端的 ui 和正在 docker 镜像存储的 docker registry。 harbor-jobservice： harbor-jobservice 是 harbor 的 job 管理模块，job 在 harbor 里面主要是为了镜像仓库之前同步使用的； harbor-ui： harbor-ui 是 web 管理页面，主要是前端的页面和后端 CURD 的接口； registry： registry 就是 docker 原生的仓库，负责保存镜像。 harbor-adminserver： harbor-adminserver 是 harbor 系统管理接口，可以修改系统配置以及获取系统信息。 harbor-db： harbor-db 是 harbor 的数据库，这里保存了系统的 job 以及项目、人员权限管理。由于本 harbor 的认证也是通过数据，在生产环节大多对接到企业的 ldap 中； harbor-log： harbor-log 是 harbor 的日志服务，统一管理 harbor 的日志。通过 inspect 可以看出容器统一将日志输出的 syslog。 这几个容器通过 Docker link 的形式连接在一起，这样，在容器之间可以通过容器名字互相访问。对终端用户而言，只需要暴露 proxy （即 Nginx）的服务端口。 配置客户端在 /etc/docker/daemon.json 中增加如下内容（如果文件不存在请新建该文件） 12345678&#123; "registry-mirrors": [ "https://registry.docker-cn.com" ], "insecure-registries": [ "192.168.141.150" ]&#125; 注意： 该文件必须符合 JSON 规范，否则 Docker 将不能启动。 重启服务 12systemctl daemon-reloadsystemctl restart docker 检查客户端配置是否生效使用 docker info 命令手动检查，如果从配置中看到如下内容，说明配置成功 123Insecure Registries: 192.168.141.150 127.0.0.0/8 Harbor 上传镜像新建项目我们以推送 Nginx 为例，首先需要在 Harbor 上创建一个 公开/私有 的项目 推送镜像 12345678# 在项目中标记镜像docker tag nginx 192.168.141.150/myshop/nginx:latest# 登录 Harbordocker login 192.168.141.150 -u admin -p Harbor12345# 推送镜像到项目docker push 192.168.141.150/myshop/nginx:latest 查看镜像 Harbor 下载镜像在其它机器下载镜像只需要配置好客户端即可 1docker pull 192.168.141.150/myshop/nginx:latest]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 部署 Nexus]]></title>
    <url>%2F2013%2F07%2F09%2FLinux%2FDay59_DockerCompose%2F029.DockerCompose-%E9%83%A8%E7%BD%B2%20Nexus%2F</url>
    <content type="text"><![CDATA[Docker Compose 部署 Nexus什么是 NexusNexus 是一个强大的 Maven 仓库管理器，极大地简化了内部仓库的维护和外部仓库的访问。2016 年 4 月 6 日 Nexus 3.0 版本发布，相较 2.x 版本有了很大的改变 对低层代码进行了大规模重构，提升性能，增加可扩展性以及改善用户体验。 升级界面，极大的简化了用户界面的操作和管理。 提供新的安装包，让部署更加简单。 增加对 Docker, NeGet, npm, Bower 的支持。 提供新的管理接口，以及增强对自动任务的管理。 部署 Nexus我们使用 Docker 来安装和运行 Nexus，docker-compose.yml 配置如下： 12345678910version: '3.1'services: nexus: restart: always image: sonatype/nexus3 container_name: nexus ports: - 8081:8081 volumes: - ./data:/nexus-data 注意： 启动时如果出现权限问题可以使用 chmod 777 /usr/local/docker/nexus/data 赋予数据卷目录可读可写的权限 验证安装是否成功 地址： http://ip:port/ 用户名： admin 密码： admin123 Maven 仓库介绍代理仓库(Proxy Repository) 第三方仓库 maven-central nuget.org-proxy 版本策略(Version Policy) Release： 正式版本 Snapshot： 快照版本 Mixed： 混合模式 布局策略(Layout Policy) Strict： 严格 Permissive： 宽松 宿主仓库(Hosted Repository) 存储本地上传的组件和资源的 maven-releases maven-snapshots nuget-hosted 部署策略(Deployment Policy) Allow Redeploy： 允许重新部署 Disable Redeploy： 禁止重新部署 Read-Only： 只读 仓库组(Repository Group)通常包含了多个代理仓库和宿主仓库，在项目中只要引入仓库组就可以下载到代理仓库和宿主仓库中的包 maven-public nuget-group 在项目中使用 Nexus配置认证信息在 Maven settings.xml 中添加 Nexus 认证信息 (servers 节点下) 1234567891011&lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; Snapshots 与 Releases 的区别 nexus-releases： 用于发布 Release 版本 nexus-snapshots： 用于发布 Snapshot 版本（快照版） Release 版本与 Snapshot 定义 12Release: 1.0.0/1.0.0-RELEASESnapshot: 1.0.0-SNAPSHOT 在项目 pom.xml 中设置的版本号添加 SNAPSHOT 标识的都会发布为 SNAPSHOT 版本，没有 SNAPSHOT 标识的都会发布为 RELEASE 版本。 SNAPSHOT 版本会自动加一个时间作为标识，如：1.0.0-SNAPSHOT 发布后为变成 1.0.0-SNAPSHOT-20180522.123456-1.jar 配置自动化部署在 pom.xml 中添加如下代码 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 注意事项 ID 名称必须要与 settings.xml 中 Servers 配置的 ID 名称保持一致 项目版本号中有 SNAPSHOT 标识的，会发布到 Nexus Snapshots Repository， 否则发布到 Nexus Release Repository，并根据 ID 去匹配授权账号 部署到仓库1mvn deploy 配置代理仓库1234567891011121314151617181920212223242526&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Plugin Repository&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 扩展阅读手动上传第三方依赖Nexus 3.1.x 开始支持页面上传第三方依赖功能，以下为手动上传命令 123456789# 如第三方JAR包：aliyun-sdk-oss-2.2.3.jarmvn deploy:deploy-file -DgroupId=com.aliyun.oss -DartifactId=aliyun-sdk-oss -Dversion=2.2.3 -Dpackaging=jar -Dfile=D:\aliyun-sdk-oss-2.2.3.jar -Durl=http://127.0.0.1:8081/repository/maven-3rd/ -DrepositoryId=nexus-releases 注意事项 建议在上传第三方 JAR 包时，创建单独的第三方 JAR 包管理仓库，便于管理有维护。（maven-3rd） -DrepositoryId=nexus-releases 对应的是 settings.xml 中 Servers 配置的 ID 名称。（授权）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 部署 GitLab]]></title>
    <url>%2F2013%2F07%2F08%2FLinux%2FDay59_DockerCompose%2F028.DockerCompose-%E9%83%A8%E7%BD%B2%20GitLab%2F</url>
    <content type="text"><![CDATA[Docker Compose 部署 GitLab什么是 GitLabGitLab 是利用 Ruby on Rails 一个开源的版本管理系统，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与 Github 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序 (Wall) 进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 部署 GitLab我们使用 Docker 来安装和运行 GitLab 中文版，docker-compose.yml 配置如下： 123456789101112131415161718192021version: '3'services: web: image: 'twang2218/gitlab-ce-zh' restart: always hostname: '192.168.75.145' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://192.168.75.145' gitlab_rails['gitlab_shell_ssh_port'] = 2222 unicorn['port'] = 8888 nginx['listen_port'] = 80 ports: - '80:80' - '443:443' - '2222:22' volumes: - ./config:/etc/gitlab - ./data:/var/opt/gitlab - ./logs:/var/log/gitlab 配置 GitLab 访问地址：http://ip:8080 设置管理员初始密码，这里的密码最好是 字母 + 数字组合，并且大于等于 8 位 配置完成后登录，管理员账号是 root 注意： 如果服务器配置较低，启动运行可能需要较长时间，请耐心等待 设置 GitLab第一次使用时可以做一些初始化设置，点击 管理区域 -&gt; 设置 关闭头像功能，由于 Gravatar 头像为网络头像，在网络情况不理想时可能导致访问时卡顿 由于是内部代码托管服务器，可以直接关闭注册功能，由管理员统一创建用户即可 账户管理使用时请不要直接通过 root 用户操作，需要先创建用户，然后通过创建的用户操作，如果你是管理员还需要为其他开发人员分配账户 创建账户，点击 管理区域 -&gt; 新建用户 设置账户信息，同时你可以将自己设置为管理员 修改用户密码，由于我们创建时并没有配置邮箱，所以还需要重新编辑用户信息并手动设置密码 退出并使用新账户登录 注意： 创建完账户，第一次登录时还会提示你修改登录密码 项目管理 点击 + 号 -&gt; 新建项目 输入项目名称及描述信息，设置可见等级为私有，这样别人就看不见你的项目 我们选择通过增加一个 README 的方式来初始化项目 直接提交修改即可 使用 SSH 方式拉取和推送生成 SSH KEY 使用 ssh-keygen 工具生成，位置在 Git 安装目录下，我的是 C:\Program Files\Git\usr\bin，输入命令： 1ssh-keygen -t rsa -C "your_email@example.com" 执行成功后的效果： 1234567891011121314151617181920212223242526Microsoft Windows [版本 10.0.14393](c) 2016 Microsoft Corporation。保留所有权利。C:\Program Files\Git\usr\bin&gt;ssh-keygen -t rsa -C &quot;topsale@vip.qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Lusifer/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/Lusifer/.ssh/id_rsa.Your public key has been saved in /c/Users/Lusifer/.ssh/id_rsa.pub.The key fingerprint is:SHA256:cVesJKa5VnQNihQOTotXUAIyphsqjb7Z9lqOji2704E topsale@vip.qq.comThe key&apos;s randomart image is:+---[RSA 2048]----+| + ..=o=. .+. || o o + B .+.o.o ||o . + +=o+.. ||.= . oo... ||= o So ||oE . o || .. .. . || o*o+ || *B*oo |+----[SHA256]-----+C:\Program Files\Git\usr\bin&gt; 复制 SSH-KEY 信息到 GitLab 密钥位置在：C:\Users\你的用户名\.ssh 目录下，找到 id_rsa.pub 并使用编辑器打开，如： 登录 GitLab，点击“用户头像”–&gt;“设置”–&gt;“SSH 密钥” 成功增加密钥后的效果 使用 TortoiseGit克隆项目 新建一个存放代码仓库的本地文件夹 在文件夹空白处按右键 选择 Git 克隆… 复制项目地址到 URL 如果弹出连接信息请选择是 成功克隆项目到本地 推送项目 创建或修改文件（这里的文件为所有文件，包括：代码、图片等） 我们以创建 .gitignore 过滤配置文件为例，该文件的主要作用为过滤不需要上传的文件，比如：IDE 生成的工程文件、编译后的 class 文件等 在工程目录下，新建 .gitignore 文件，并填入如下配置 1234567891011121314151617181920212223242526target/!.mvn/wrapper/maven-wrapper.jar## STS ##.apt_generated.classpath.factorypath.project.settings.springBeans## IntelliJ IDEA ##.idea*.iws*.iml*.ipr## JRebel ##rebel.xml## MAC ##.DS_Store## Other ##logs/temp/ 右键呼出菜单，选择 提交 Master… 点击 全部 并填入 日志信息 点击 提交并推送 成功后的效果图 查看 GitLab 确认提交成功]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 部署应用程序]]></title>
    <url>%2F2013%2F07%2F07%2FLinux%2FDay59_DockerCompose%2F027.DockerCompose-%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Docker Compose 部署应用程序部署 Tomcat123456789101112version: '3.1'services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 8080:8080 volumes: - ./webapps:/usr/local/tomcat/webapps environment: TZ: Asia/Shanghai 部署 MySQL12345678910111213141516171819202122232425version: '3.1'services: db: # 目前 latest 版本为 MySQL8.x image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: 123456 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - ./data:/var/lib/mysql # MySQL 的 Web 客户端 adminer: image: adminer restart: always ports: - 8080:8080 部署应用程序请参考本节视频]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 使用]]></title>
    <url>%2F2013%2F07%2F06%2FLinux%2FDay59_DockerCompose%2F026.DockerCompose-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Docker Compose 使用术语首先介绍几个术语。 服务 (Service)：一个应用容器，实际上可以运行多个相同镜像的实例。 项目 (Project)：由一组关联的应用容器组成的一个完整业务单元。 可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。 场景最常见的项目是 Web 网站，该项目应该包含 Web 应用和缓存。下面我们用 Python 来建立一个能够记录页面访问次数的 Web 网站。 Python 应用新建文件夹，在该目录中编写 app.py 文件 12345678910111213from flask import Flaskfrom redis import Redisapp = Flask(__name__)redis = Redis(host='redis', port=6379)@app.route('/')def hello(): count = redis.incr('hits') return 'Hello World! 该页面已被访问 &#123;&#125; 次。\n'.format(count)if __name__ == "__main__": app.run(host="0.0.0.0", debug=True) Dockerfile编写 Dockerfile 文件，内容为 12345FROM python:3.6-alpineADD . /codeWORKDIR /codeRUN pip install redis flaskCMD ["python", "app.py"] Docker Compose 模板编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。 123456789version: '3'services: web: build: . ports: - "5000:5000" redis: image: "redis:alpine" 运行 Compose 项目1docker-compose up -d 此时访问本地 5000 端口，每次刷新页面，计数就会加 1。 扩展阅读YAML 配置文件语言YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。YAML 语言的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。它的基本语法规则如下： 大小写敏感 使用缩进表示层级关系 缩进时不允许使用 TAB 键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。YAML 支持的数据结构有三种： 对象： 键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组： 一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）： 单个的、不可再分的值 YAML 对象对象的一组键值对，使用冒号结构表示 1animal: pets YAML 数组一组连词线开头的行，构成一个数组 123- Cat- Dog- Goldfish 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格 1234- Array - Cat - Dog - Goldfish YAML 复合结构对象和数组可以结合使用，形成复合结构 123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org YAML 纯量纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量 字符串 布尔值 整数 浮点数 Null 时间 日期 修改 IP 和 DNS课程演示会采用多虚拟机模拟分布式场景，为防止 IP 冲突，无法联网等问题，需要预先设置好主机名、IP、DNS 配置 修改主机名 修改 cloud.cfg 防止重启后主机名还原 1234vi /etc/cloud/cloud.cfg# 该配置默认为 false，修改为 true 即可preserve_hostname: true 修改主机名 1234567# 修改主机名hostnamectl set-hostname deployment# 配置 hostscat &gt;&gt; /etc/hosts &lt;&lt; EOF192.168.141.130 deploymentEOF 修改 IP编辑 vi /etc/netplan/50-cloud-init.yaml 配置文件，修改内容如下 12345678network: ethernets: ens33: addresses: [192.168.141.130/24] gateway4: 192.168.141.2 nameservers: addresses: [192.168.141.2] version: 2 使用 netplan apply 命令让配置生效 修改 DNS12# 取消 DNS 行注释，并增加 DNS 配置如：114.114.114.114，修改后重启下计算机vi /etc/systemd/resolved.conf]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 简介]]></title>
    <url>%2F2013%2F07%2F05%2FLinux%2FDay59_DockerCompose%2F025.DockerCompose-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Docker Compose 简介概述Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 OpenStack 中的 Heat 十分类似。 其代码目前在 https://github.com/docker/compose 上开源。 Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。 我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。 Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（Project）。Compose 中有两个重要的概念： 服务 (Service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (Project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。 安装 Docker ComposeCompose 支持 Linux、macOS、Windows 10 三大平台。在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。 12curl -L https://github.com/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 验证安装是否成功1234567docker-compose version# 输出如下docker-compose version 1.24.0, build 0aa59064docker-py version: 3.7.2CPython version: 3.6.8OpenSSL version: OpenSSL 1.1.0j 20 Nov 2018]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dockerfile 指令]]></title>
    <url>%2F2013%2F07%2F04%2FLinux%2FDay58_DockerFile%2F024.Dockerfile-%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Dockerfile 指令概述我们已经介绍了 FROM，RUN，还提及了 COPY, ADD，其实 Dockerfile 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。 COPY格式： COPY &lt;源路径&gt;... &lt;目标路径&gt; COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如： 1COPY package.json /usr/src/app/ &lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： 12COPY hom* /mydir/COPY hom?.txt /mydir/ &lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 ADDADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。 比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。 如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。 在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中： 12FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz / 但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。 在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。 另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。 因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。 CMDCMD 指令的格式和 RUN 相似，也是两种格式： shell 格式：CMD &lt;命令&gt; exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...] 参数列表格式：CMD [&quot;参数1&quot;, &quot;参数2&quot;...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 &quot;，而不要使用单引号。 如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如： 1CMD echo $HOME 在实际执行中，会将其变更为： 1CMD [ "sh", "-c", "echo $HOME" ] 这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。 提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。 Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。 一些初学者将 CMD 写为： 1CMD service nginx start 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如： 1CMD ["nginx", "-g", "daemon off;"] ENTRYPOINTENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： 1&lt;ENTRYPOINT&gt; "&lt;CMD&gt;" 那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 &lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 有什么好处么？让我们来看几个场景。 场景一：让镜像变成像命令一样使用假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现： 12345FROM ubuntu:16.04RUN apt-get update \ &amp;&amp; apt-get install -y curl \ &amp;&amp; rm -rf /var/lib/apt/lists/*CMD [ "curl", "-s", "http://ip.cn" ] 假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行： 12docker run myip当前 IP：61.148.226.66 来自：北京市 联通 嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？ 12docker run myip -idocker: Error response from daemon: invalid header field value "oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in $PATH\"\n". 我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s http://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。 那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令： 1docker run myip curl -s http://ip.cn -i 这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像： 12345FROM ubuntu:16.04RUN apt-get update \ &amp;&amp; apt-get install -y curl \ &amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [ "curl", "-s", "http://ip.cn" ] 这次我们再来尝试直接使用 docker run myip -i： 123456789101112131415161718docker run myip当前 IP：61.148.226.66 来自：北京市 联通docker run myip -iHTTP/1.1 200 OKServer: nginx/1.8.0Date: Tue, 22 Nov 2016 05:12:40 GMTContent-Type: text/html; charset=UTF-8Vary: Accept-EncodingX-Powered-By: PHP/5.6.24-1~dotdeb+7.1X-Cache: MISS from cache-2X-Cache-Lookup: MISS from cache-2:80X-Cache: MISS from proxy-2_6Transfer-Encoding: chunkedVia: 1.1 cache-2:80, 1.1 proxy-2_6:8006Connection: keep-alive当前 IP：61.148.226.66 来自：北京市 联通 可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。 场景二：应用运行前的准备工作启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。 比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。 此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。 这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 &lt;CMD&gt;）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的： 12345FROM alpine:3.4RUN addgroup -S redis &amp;&amp; adduser -S -G redis redisENTRYPOINT ["docker-entrypoint.sh"]EXPOSE 6379CMD [ "redis-server" ] 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。 123456789#!/bin/sh# allow the container to be started with `--user`if [ "$1" = 'redis-server' -a "$(id -u)" = '0' ]; then chown -R redis . exec su-exec redis "$0" "$@"fiexec "$@" 该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如： 12docker run -it redis iduid=0(root) gid=0(root) groups=0(root) ENV格式有两种： ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。 12ENV VERSION=1.0 DEBUG=on \ NAME=&quot;Happy Feet&quot; 这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码： 123456789ENV NODE_VERSION 7.2.0RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \ &amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \ &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \ &amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=1 \ &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \ &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs 在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。 下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。 可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。 VOLUME格式为： VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...] VOLUME &lt;路径&gt; 之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 1VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如： 1docker run -d -v mydata:/data xxxx 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 EXPOSE格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]。 EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 --icc=false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 --links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 --icc=false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR格式为 WORKDIR &lt;工作目录路径&gt;。 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误： 12RUN cd /appRUN echo "hello" &gt; world.txt 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。 之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dockerfile 定制镜像]]></title>
    <url>%2F2013%2F07%2F03%2FLinux%2FDay58_DockerFile%2F023.Dockerfile-%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[Dockerfile 定制镜像概述Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 以之前的 Nginx 镜像为例，这次我们使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为 Dockerfile 123mkdir mynginxcd mynginxtouch Dockerfile 其内容为： 12FROM nginxRUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。 FROM 指定基础镜像所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 Nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。 1FROM scratch 如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。 不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构语言的原因之一。 RUN 执行命令RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式： RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 1RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html exec 格式： RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式。 既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样： 123456789FROM debian:jessieRUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz"RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install 之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。 而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。这是很多初学 Docker 的人常犯的一个错误。 注意： Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。 上面的 Dockerfile 正确的写法应该是这样： 1234567891011121314FROM debian:jessieRUN buildDeps='gcc libc6-dev make' \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y $buildDeps \ &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \ &amp;&amp; mkdir -p /usr/src/redis \ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \ &amp;&amp; make -C /usr/src/redis \ &amp;&amp; make -C /usr/src/redis install \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm redis.tar.gz \ &amp;&amp; rm -r /usr/src/redis \ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 首先，之前所有的命令只有一个目的，就是编译、安装 Redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。 此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。 很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。 构建镜像好了，让我们再回到之前定制的 Nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。在 Dockerfile 文件所在目录执行： 1234567891011docker build -t nginx:v3 .# 输出如下Sending build context to Docker daemon 2.048 kBStep 1 : FROM nginx ---&gt; e43d811ce2f4Step 2 : RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html ---&gt; Running in 9cdc27646c7b ---&gt; 44aa4490ce2cRemoving intermediate container 9cdc27646c7bSuccessfully built 44aa4490ce2c 从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。 这里我们使用了 docker build 命令进行镜像构建。其格式为： 1docker build [选项] &lt;上下文路径/URL/-&gt; 在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。 镜像构建上下文如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？ 首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？ 这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： 1COPY ./package.json /app/ 这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。 因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。 如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程： 1234docker build -t nginx:v3 .# 输出如下Sending build context to Docker daemon 2.048 kB 理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。 这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。 当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 常用命令]]></title>
    <url>%2F2013%2F07%2F02%2FLinux%2FDay57_Docker%2F%E9%99%84%EF%BC%9ADocker%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[附：Docker 常用命令查看 Docker 版本1docker version 从 Docker 文件构建 Docker 映像1docker build -t image-name docker-file-location 运行 Docker 映像1docker run -d image-name 查看可用的 Docker 映像1docker images 查看最近的运行容器1docker ps -l 查看所有正在运行的容器1docker ps -a 停止运行容器1docker stop container_id 删除一个镜像1docker rmi image-name 删除所有镜像1docker rmi $(docker images -q) 强制删除所有镜像1docker rmi -f $(docker images -q) 删除所有虚悬镜像1docker rmi $(docker images -q -f dangling=true) 删除所有容器1docker rm $(docker ps -a -q) 进入 Docker 容器1docker exec -it container-id /bin/bash 查看所有数据卷1docker volume ls 删除指定数据卷1docker volume rm [volume_name] 删除所有未关联的数据卷1docker volume rm $(docker volume ls -qf dangling=true) 从主机复制文件到容器1docker cp host_path containerID:container_path 从容器复制文件到主机1docker cp containerID:container_path host_path]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 操作容器]]></title>
    <url>%2F2013%2F07%2F01%2FLinux%2FDay57_Docker%2F022.Docker-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Docker 操作容器启动容器所需要的命令主要为 docker run。例如，下面的命令输出一个 “Hello World”，之后终止容器。 12docker run ubuntu:16.04 /bin/echo 'Hello world'Hello world 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 终止容器可以使用 docker container stop 来终止一个运行中的容器。此外，当 Docker 容器中指定的应用终结时，容器也自动终止。 例如对于只启动了一个终端的容器，用户通过 exit 命令或 ctrl + d 来退出终端时，所创建的容器立刻终止。终止状态的容器可以用 docker container ls -a 命令看到。例如 123456docker container ls -a# 输出如下CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESba267838cc1b ubuntu:14.04 "/bin/bash" 30 minutes ago Exited (0) About a minute ago trusting_newton98e5efa7d997 training/webapp:latest "python app.py" About an hour ago Exited (0) 34 minutes ago backstabbing_pike 启动已终止容器处于终止状态的容器，可以通过 docker container start 命令来重新启动。此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。 1docker container start [container ID or NAMES] 守护态运行更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。如果不使用 -d 参数运行容器。 1234567docker run ubuntu:16.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"# 输出如下hello worldhello worldhello worldhello world 容器会把输出的结果 (STDOUT) 打印到宿主机上面，如果使用了 -d 参数运行容器。 1234docker run -d ubuntu:17.10 /bin/sh -c "while true; do echo hello world; sleep 1; done"# 输出如下77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a 此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。 注意： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。 容器日志要获取容器的输出信息，可以通过 docker container logs 命令。 123456docker container logs [container ID or NAMES]# 输出如下hello worldhello worldhello world 进入容器在使用 -d 参数时，容器启动后会进入后台。某些时候需要进入容器进行操作，docker exec 命令能让我们以交互的方式进入容器。 docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。 12docker exec -it 69d1 bashroot@69d137adef7a:/# 如果从这个 stdin 中 exit，不会导致容器的停止。更多参数说明请使用 docker exec --help 查看。 删除容器可以使用 docker container rm 来删除一个处于终止状态的容器。例如 12docker container rm trusting_newtontrusting_newton 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。 清理所有处于终止状态的容器用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。 1docker container prune]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 操作镜像]]></title>
    <url>%2F2013%2F06%2F30%2FLinux%2FDay57_Docker%2F021.Docker-%E6%93%8D%E4%BD%9C%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[Docker 操作镜像获取镜像之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。 从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为： 1docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。 镜像仓库地址： 地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。 仓库名： 如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 12345678910docker pull nginx# 输出如下Using default tag: latestlatest: Pulling from library/nginxfc7181108d40: Pull complete c4277fc40ec2: Pull complete 780053e98559: Pull complete Digest: sha256:bdbf36b7f1f77ffe7bd2a32e59235dff6ecf131e3b6b5b96061c652f30685f3aStatus: Downloaded newer image for nginx:latest 列出镜像要想列出已经下载下来的镜像，可以使用 docker image ls 命令。 1234567891011docker image ls# 输出如下REPOSITORY TAG IMAGE ID CREATED SIZEredis latest 5f515359c7f8 5 days ago 183 MBnginx latest 05a60462f8ba 5 days ago 181 MBmongo 3.2 fe9198c04d62 5 days ago 342 MB&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MBubuntu 16.04 f753707788c5 4 weeks ago 127 MBubuntu latest f753707788c5 4 weeks ago 127 MBubuntu 14.04 1e0c3dd64ccd 4 weeks ago 188 MB 列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。 其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。因此，在上面的例子中，我们可以看到 ubuntu:16.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。 镜像体积如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:16.04 镜像大小，在这里是 127 MB，但是在 Docker Hub 显示的却是 50 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。 另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。 你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。 12345678docker system df# 输出如下TYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 24 0 1.992GB 1.992GB (100%)Containers 1 0 62.82MB 62.82MB (100%)Local Volumes 9 0 652.2MB 652.2MB (100%)Build Cache 0B 0B 虚悬镜像上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 &lt;none&gt; 1&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MB 这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 &lt;none&gt;。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 &lt;none&gt; 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像： 12345docker image ls -f dangling=true# 输出如下REPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MB 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。 1docker image prune 中间层镜像为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 1docker image ls -a 这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。 删除镜像如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为： 1docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 用 ID、镜像名、摘要删除镜像其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。 比如我们有这么一些镜像： 12345678docker image ls# 输出如下REPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 0584b3d2cf6d 3 weeks ago 196.5 MBredis alpine 501ad78535f0 3 weeks ago 21.03 MBdocker latest cf693ec9b5c7 3 weeks ago 105.1 MBnginx latest e43d811ce2f4 5 weeks ago 181.5 MB 我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。docker image ls 默认列出的就已经是短 ID 了，一般取前 3 个字符以上，只要足够区分于别的镜像就可以了。 比如这里，如果我们要删除 redis:alpine 镜像，可以执行： 1234567891011docker image rm 501# 输出如下Untagged: redis:alpineUntagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899bDeleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2faDeleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7 我们也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。 1234567docker image rm centos# 输出如下Untagged: centos:latestUntagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366cDeleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8aDeleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38 当然，更精确的是使用 镜像摘要 删除镜像。 12345678910docker image ls --digests# 输出如下REPOSITORY TAG DIGEST IMAGE ID CREATED SIZEnode slim sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 6e0c4c8e3913 3 weeks ago 214 MBdocker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228# 输出如下Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 用 docker image ls 命令来配合像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。 比如，我们需要删除所有仓库名为 redis 的镜像： 1docker image rm $(docker image ls -q redis) 或者删除所有在 mongo:3.2 之前的镜像： 1docker image rm $(docker image ls -q -f before=mongo:3.2) 充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。 扩展阅读列出部分镜像不加任何参数的情况下，docker image ls 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。 根据仓库名列出镜像 1234567docker image ls ubuntu# 输出如下REPOSITORY TAG IMAGE ID CREATED SIZEubuntu 16.04 f753707788c5 4 weeks ago 127 MBubuntu latest f753707788c5 4 weeks ago 127 MBubuntu 14.04 1e0c3dd64ccd 4 weeks ago 188 MB 列出特定的某个镜像，也就是说指定仓库名和标签 12345docker image ls ubuntu:16.04# 输出如下REPOSITORY TAG IMAGE ID CREATED SIZEubuntu 16.04 f753707788c5 4 weeks ago 127 MB 除此以外，docker image ls 还支持强大的过滤器参数 --filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令： 123456docker image ls -f since=mongo:3.2# 输出如下REPOSITORY TAG IMAGE ID CREATED SIZEredis latest 5f515359c7f8 5 days ago 183 MBnginx latest 05a60462f8ba 5 days ago 181 MB 想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。 此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。 1docker image ls -f label=com.example.version=0.1 以特定格式显示默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 docker image ls 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。 12345678910docker image ls -q# 输出如下5f515359c7f805a60462f8bafe9198c04d6200285df0df87f753707788c5f753707788c51e0c3dd64ccd --filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。 另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。 比如，下面的命令会直接列出镜像结果，并且只包含镜像 ID 和仓库名： 12345678910docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"# 输出如下5f515359c7f8: redis05a60462f8ba: nginxfe9198c04d62: mongo00285df0df87: &lt;none&gt;f753707788c5: ubuntuf753707788c5: ubuntu1e0c3dd64ccd: ubuntu 或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列： 1234567891011docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"# 输出如下IMAGE ID REPOSITORY TAG5f515359c7f8 redis latest05a60462f8ba nginx latestfe9198c04d62 mongo 3.200285df0df87 &lt;none&gt; &lt;none&gt;f753707788c5 ubuntu 16.04f753707788c5 ubuntu latest1e0c3dd64ccd ubuntu 14.04]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 概述]]></title>
    <url>%2F2013%2F06%2F29%2FLinux%2FDay57_Docker%2F020.Docker-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Docker 概述Docker 引擎Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。 一种服务器，它是一种称为守护进程并且长时间运行的程序。 REST API 用于指定程序可以用来与守护进程通信的接口，并指示它做什么。 一个有命令行界面 (CLI) 工具的客户端。 Docker 架构 Docker 使用客户端 - 服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。 Docker 容器通过 Docker 镜像来创建。 容器与镜像的关系类似于面向对象编程中的对象与类。 Docker 面向对象 容器 对象 镜像 类 标题 说明 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 容器(Container) 容器是独立运行的一个或一组应用。 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 安装]]></title>
    <url>%2F2013%2F06%2F28%2FLinux%2FDay57_Docker%2F019.Docker-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装 Docker平台支持Docker CE 支持多种平台，如下表所示 桌面 平台 架构 Docker Desktop for Mac (macOS) X64 Docker Desktop for Windows (Microsoft Windows 10) X64 服务器 平台 x86_64 / amd64 ARM ARM64 / AARCH64 IBM Power (ppc64le) IBM Z (s390x) CentOS ✔ ✔ Debian ✔ ✔ ✔ Fedora ✔ ✔ Ubuntu ✔ ✔ ✔ ✔ ✔ 准备安装卸载旧版本1apt-get remove docker docker-engine docker.io containerd runc 使用 APT 安装12345678910# 更新数据源apt-get update# 安装所需依赖apt-get -y install apt-transport-https ca-certificates curl software-properties-common# 安装 GPG 证书curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 新增数据源add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"# 更新并安装 Docker CEapt-get update &amp;&amp; apt-get install -y docker-ce 验证安装是否成功123456789101112131415161718192021docker version# 输出如下Client: Version: 18.09.6 API version: 1.39 Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 02:35:57 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.6 API version: 1.39 (minimum version 1.12) Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 01:59:36 2019 OS/Arch: linux/amd64 Experimental: false 配置 Docker 镜像加速器阿里云加速器（推荐）点击链接获取 官方提供中国区镜像1https://registry.docker-cn.com 配置加速器以配置阿里云加速器为例，首先 登录阿里云（没有账号请先注册），搜索 容器镜像服务 找到你的专属加速器 通过修改 daemon 配置文件 /etc/docker/daemon.json 来使用加速器 12345678tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://xxxxxxxx.mirror.aliyuncs.com"]&#125;EOF# 重启 Dockerservice docker restart 验证配置是否成功1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253docker info# 输出如下Containers: 38 Running: 18 Paused: 0 Stopped: 20Images: 10Server Version: 18.09.6Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: trueLogging Driver: json-fileCgroup Driver: cgroupfsPlugins: Volume: local Network: bridge host macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslogSwarm: inactiveRuntimes: runcDefault Runtime: runcInit Binary: docker-initcontainerd version: bb71b10fd8f58240ca47fbb579b9d1028eea7c84runc version: 2b18fe1d885ee5083ef9f0838fee39b62d653e30init version: fec3683Security Options: apparmor seccomp Profile: defaultKernel Version: 4.15.0-51-genericOperating System: Ubuntu 18.04.2 LTSOSType: linuxArchitecture: x86_64CPUs: 2Total Memory: 1.924GiBName: kubernetes-masterID: PJ4H:7AF2:P5UT:6FMR:W4DI:SSWR:IQQR:J6QO:ARES:BOAC:ZVMO:SV2YDocker Root Dir: /var/lib/dockerDebug Mode (client): falseDebug Mode (server): falseRegistry: https://index.docker.io/v1/Labels:Experimental: falseInsecure Registries: 127.0.0.0/8## 这里是你配置的镜像加速器Registry Mirrors: https://xxxxxxxx.mirror.aliyuncs.com/Live Restore Enabled: falseProduct License: Community EngineWARNING: No swap limit support 运行第一个容器我们以 Nginx 为例，体验 Docker 是如何运行容器的 12345# 下载镜像docker pull nginx# 运行容器docker run --name nginx-container -p 80:80 -d nginx 浏览器输入虚拟机地址即可访问 Nginx]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 简介]]></title>
    <url>%2F2013%2F06%2F27%2FLinux%2FDay57_Docker%2F018.Docker-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Docker 简介什么是 Docker官网地址：https://www.docker.com/ Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 [2013 年 3 月以 Apache 2.0 授权协议开源][docker-soft]，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为 容器 。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 为什么需要 Docker概述作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。 持续交付和部署对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 [docker-soft]:]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux LVM 磁盘扩容]]></title>
    <url>%2F2013%2F06%2F26%2FLinux%2FDay56_linux%2F017.Linux-LVM%20%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Linux LVM 磁盘扩容LVM 的基本概念 物理卷 Physical Volume (PV)： 可以在上面建立卷组的媒介，可以是硬盘分区，也可以是硬盘本身或者回环文件（loopback file）。物理卷包括一个特殊的 header，其余部分被切割为一块块物理区域（physical extents） 卷组 Volume group (VG)： 将一组物理卷收集为一个管理单元 逻辑卷 Logical volume (LV)： 虚拟分区，由物理区域（physical extents）组成 物理区域 Physical extent (PE)： 硬盘可供指派给逻辑卷的最小单位（通常为 4MB） 磁盘操作相关命令 查看挂载点 1234567891011121314df -h# 输出如下Filesystem Size Used Avail Use% Mounted onudev 955M 0 955M 0% /devtmpfs 198M 1.8M 196M 1% /run## 此处为我们磁盘的挂载点/dev/mapper/ubuntu--vg-ubuntu--lv 19G 6.0G 12G 35% /tmpfs 986M 0 986M 0% /dev/shmtmpfs 5.0M 0 5.0M 0% /run/locktmpfs 986M 0 986M 0% /sys/fs/cgroup/dev/loop1 91M 91M 0 100% /snap/core/6350/dev/loop0 89M 89M 0 100% /snap/core/6964/dev/sda2 976M 143M 767M 16% /boot 显示当前的 logical volume：lvdisplay 12345678910111213141516171819lvdisplay# 输出如下--- Logical volume ---LV Path /dev/ubuntu-vg/ubuntu-lvLV Name ubuntu-lvVG Name ubuntu-vgLV UUID e2fKkR-oZeH-WV2A-ltCi-P76v-N9yv-aUtIg1LV Write Access read/writeLV Creation host, time ubuntu-server, 2019-05-14 03:13:57 +0800LV Status available# open 1LV Size &lt;19.00 GiBCurrent LE 4863Segments 1Allocation inheritRead ahead sectors auto- currently set to 256Block device 253:0 显示当前的 volume group 123456789101112131415161718192021222324vgdisplay# 输出如下--- Volume group ---VG Name ubuntu-vgSystem ID Format lvm2Metadata Areas 1Metadata Sequence No 2VG Access read/writeVG Status resizableMAX LV 0Cur LV 1Open LV 1Max PV 0Cur PV 1Act PV 1## 这里应该是你当前的可用空间大小，待扩容完毕，这里显示的应该是最终的大小VG Size &lt;19.00 GiBPE Size 4.00 MiBTotal PE 4863Alloc PE / Size 4863 / &lt;19.00 GiBFree PE / Size 0 / 0 VG UUID dhI9ns-7lOI-pXf8-IOWL-F96N-JIYG-ZF6u82 显示当前的 physical volume 12345678910111213pvdisplay# 输出如下--- Physical volume ---PV Name /dev/sda3VG Name ubuntu-vgPV Size &lt;19.00 GiB / not usable 0 Allocatable yes (but full)PE Size 4.00 MiBTotal PE 4863Free PE 0Allocated PE 4863PV UUID TDFe2b-xsce-R8So-ldxR-ohcp-fx5J-n2JNOa 开始 LVM 扩容查看 fdisk1234567891011121314151617181920212223242526272829fdisk -l# 输出如下Disk /dev/loop0: 88.4 MiB, 92733440 bytes, 181120 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/loop1: 91 MiB, 95408128 bytes, 186344 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: gptDisk identifier: F96F20D7-1F28-4B03-87CF-4FA3E81FDE29Device Start End Sectors Size Type/dev/sda1 2048 4095 2048 1M BIOS boot/dev/sda2 4096 2101247 2097152 1G Linux filesystem/dev/sda3 2101248 41940991 39839744 19G Linux filesystemDisk /dev/mapper/ubuntu--vg-ubuntu--lv: 19 GiB, 20396900352 bytes, 39837696 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes 查看所有储存设备1234567891011fdisk -l |grep '/dev'# 输出如下Disk /dev/loop0: 88.4 MiB, 92733440 bytes, 181120 sectorsDisk /dev/loop1: 91 MiB, 95408128 bytes, 186344 sectors## 目前只有一块磁盘 sdaDisk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors/dev/sda1 2048 4095 2048 1M BIOS boot/dev/sda2 4096 2101247 2097152 1G Linux filesystem/dev/sda3 2101248 41940991 39839744 19G Linux filesystemDisk /dev/mapper/ubuntu--vg-ubuntu--lv: 19 GiB, 20396900352 bytes, 39837696 sectors 1234567891011121314# 在虚拟机中挂载多一块磁盘，再操作fdisk -l |grep '/dev'# 输出如下Disk /dev/loop0: 88.4 MiB, 92733440 bytes, 181120 sectorsDisk /dev/loop1: 91 MiB, 95408128 bytes, 186344 sectors## 挂载的第一块磁盘 sdaDisk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors/dev/sda1 2048 4095 2048 1M BIOS boot/dev/sda2 4096 2101247 2097152 1G Linux filesystem/dev/sda3 2101248 41940991 39839744 19G Linux filesystem## 挂载的第二块磁盘 sdbDisk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectorsDisk /dev/mapper/ubuntu--vg-ubuntu--lv: 19 GiB, 20396900352 bytes, 39837696 sectors 创建 sdb 分区1234567891011121314151617181920212223242526272829303132fdisk /dev/sdb# 输出如下Welcome to fdisk (util-linux 2.31.1).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition table.Created a new DOS disklabel with disk identifier 0x0de15f1d.## 在此处输入命令## n：新建分区## l: 选择逻辑分区，如果没有，则首先创建主分区（p），然后再添加逻辑分区（硬盘最多四个分区 P-P-P-P 或 P-P-P-E）Command (m for help): nPartition type p primary (0 primary, 0 extended, 4 free) e extended (container for logical partitions)Select (default p):Using default response p.Partition number (1-4, default 1): First sector (2048-41943039, default 2048): Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-41943039, default 41943039): Created a new partition 1 of type 'Linux' and of size 20 GiB.## 在此处输入命令## w：写入磁盘Command (m for help): wThe partition table has been altered.Calling ioctl() to re-read partition table.Syncing disks. 格式化磁盘 查看分区 12345678910111213fdisk -l |grep '/dev'# 输出如下Disk /dev/loop0: 88.4 MiB, 92733440 bytes, 181120 sectorsDisk /dev/loop1: 91 MiB, 95408128 bytes, 186344 sectorsDisk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors/dev/sda1 2048 4095 2048 1M BIOS boot/dev/sda2 4096 2101247 2097152 1G Linux filesystem/dev/sda3 2101248 41940991 39839744 19G Linux filesystemDisk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors## 此时可以看见新创建的分区 /dev/sdb1/dev/sdb1 2048 41943039 41940992 20G 83 LinuxDisk /dev/mapper/ubuntu--vg-ubuntu--lv: 19 GiB, 20396900352 bytes, 39837696 sectors 格式化 1234567891011121314mkfs -t ext4 /dev/sdb1# 输出如下mke2fs 1.44.1 (24-Mar-2018)Creating filesystem with 5242624 4k blocks and 1310720 inodesFilesystem UUID: 6f11063f-c118-4099-90fc-2b083c181b23Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000Allocating group tables: done Writing inode tables: done Creating journal (32768 blocks): doneWriting superblocks and filesystem accounting information: done 创建 PV123456pvcreate /dev/sdb1# 输出如下WARNING: ext4 signature detected on /dev/sdb1 at offset 1080. Wipe it? [y/n]: y Wiping ext4 signature on /dev/sdb1. Physical volume "/dev/sdb1" successfully created. 查看卷组123456pvscan# 输出如下PV /dev/sda3 VG ubuntu-vg lvm2 [&lt;19.00 GiB / 0 free]PV /dev/sdb1 lvm2 [&lt;20.00 GiB]Total: 2 [&lt;39.00 GiB] / in use: 1 [&lt;19.00 GiB] / in no VG: 1 [&lt;20.00 GiB] 扩容 VG 查看 VG 123456789101112131415161718192021222324vgdisplay# 输出如下--- Volume group ---## 我们需要用到 VG NameVG Name ubuntu-vgSystem ID Format lvm2Metadata Areas 1Metadata Sequence No 2VG Access read/writeVG Status resizableMAX LV 0Cur LV 1Open LV 1Max PV 0Cur PV 1Act PV 1VG Size &lt;19.00 GiBPE Size 4.00 MiBTotal PE 4863Alloc PE / Size 4863 / &lt;19.00 GiBFree PE / Size 0 / 0 VG UUID dhI9ns-7lOI-pXf8-IOWL-F96N-JIYG-ZF6u82 扩容 VG 1234vgextend ubuntu-vg /dev/sdb1# 输出如下Volume group "ubuntu-vg" successfully extended 扩容 LV 查看 VG 123456789101112131415161718192021222324vgdisplay# 输出如下--- Volume group ---VG Name ubuntu-vgSystem ID Format lvm2Metadata Areas 2Metadata Sequence No 3VG Access read/writeVG Status resizableMAX LV 0Cur LV 1Open LV 1Max PV 0Cur PV 2Act PV 2VG Size 38.99 GiBPE Size 4.00 MiBTotal PE 9982Alloc PE / Size 4863 / &lt;19.00 GiB## 这里是可以扩容的大小Free PE / Size 5119 / &lt;20.00 GiBVG UUID dhI9ns-7lOI-pXf8-IOWL-F96N-JIYG-ZF6u82 查看 LV 1234567891011121314151617181920lvdisplay# 输出如下--- Logical volume ---## 我们需要用到 LV PathLV Path /dev/ubuntu-vg/ubuntu-lvLV Name ubuntu-lvVG Name ubuntu-vgLV UUID e2fKkR-oZeH-WV2A-ltCi-P76v-N9yv-aUtIg1LV Write Access read/writeLV Creation host, time ubuntu-server, 2019-05-14 03:13:57 +0800LV Status available# open 1LV Size &lt;19.00 GiBCurrent LE 4863Segments 1Allocation inheritRead ahead sectors auto- currently set to 256Block device 253:0 扩容 LV 123456789# 按固定大小追加lvextend -L +10G /dev/ubuntu-vg/ubuntu-lv# 按百分比追加lvextend -l +100%FREE /dev/ubuntu-vg/ubuntu-lv# 输出如下Size of logical volume ubuntu-vg/ubuntu-lv changed from &lt;19.00 GiB (4863 extents) to 38.99 GiB (9982 extents).Logical volume ubuntu-vg/ubuntu-lv successfully resized. 刷新分区 123456resize2fs /dev/ubuntu-vg/ubuntu-lv# 输出如下Filesystem at /dev/ubuntu-vg/ubuntu-lv is mounted on /; on-line resizing requiredold_desc_blocks = 3, new_desc_blocks = 5The filesystem on /dev/ubuntu-vg/ubuntu-lv is now 10221568 (4k) blocks long. 验证是否成功 12345678910111213141516171819lvdisplay--- Logical volume ---LV Path /dev/ubuntu-vg/ubuntu-lvLV Name ubuntu-lvVG Name ubuntu-vgLV UUID e2fKkR-oZeH-WV2A-ltCi-P76v-N9yv-aUtIg1LV Write Access read/writeLV Creation host, time ubuntu-server, 2019-05-14 03:13:57 +0800LV Status available# open 1## 可以看到磁盘扩容成功了LV Size 38.99 GiBCurrent LE 9982Segments 2Allocation inheritRead ahead sectors auto- currently set to 256Block device 253:0 注意： 不要卸载扩容的磁盘，可能出现丢失数据或是系统无法启动]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 部署应用程序]]></title>
    <url>%2F2013%2F06%2F25%2FLinux%2FDay56_linux%2F016.Linux-%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Linux 部署应用程序安装 Java解压缩并移动到指定目录 解压缩：tar -zxvf jdk-8u152-linux-x64.tar.gz 创建目录：mkdir -p /usr/local/java 移动安装包：mv jdk1.8.0_152/ /usr/local/java/ 设置所有者：chown -R root:root /usr/local/java/ 配置环境变量 配置系统环境变量：vi /etc/environment 修改系统环境变量 1234PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;export JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib 配置用户环境变量：vi /etc/profile 修改用户环境变量 1234567891011121314151617181920212223242526272829if [ &quot;$PS1&quot; ]; then if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then # The file bash.bashrc already sets the default PS1. # PS1=&apos;\h:\w\$ &apos; if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc fi else if [ &quot;`id -u`&quot; -eq 0 ]; then PS1=&apos;# &apos; else PS1=&apos;$ &apos; fi fifiexport JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/binif [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset ifi 使用户环境变量生效：source /etc/profile 验证安装是否成功123456java -version# 输出如下java version "1.8.0_152"Java(TM) SE Runtime Environment (build 1.8.0_152-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode) 安装 Tomcat解压缩并移动到指定目录 解压缩：tar -zxvf apache-tomcat-8.5.23.tar.gz 变更目录：mv apache-tomcat-8.5.23 tomcat 移动目录：mv tomcat/ /usr/local/ 验证安装是否成功 启动： /usr/local/tomcat/bin/startup.sh ./startup.sh 停止： /usr/local/tomcat/bin/shutdown.sh ./shutdown.sh 安装 MySQL安装 更新数据源：apt-get update 安装数据库：apt-get install mysql-server 注意： 系统将提示您在安装过程中创建 root 密码。选择一个安全的密码，并确保你记住它，因为你以后需要它。接下来，我们将完成 MySQL 的配置。 配置 注意： 因为是全新安装，您需要运行附带的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和示例用户。在旧版本的 MySQL 上，您需要手动初始化数据目录，但最新的 MySQL 已经自动完成了。 1mysql_secure_installation 这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。 验证安装是否成功按上边方式安装完成后，MySQL 应该已经开始自动运行了。要测试它，请检查其状态。 123456789101112systemctl status mysql# 输出如下● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled) Active: active (running) since Tue 2017-11-21 13:04:34 CST; 3min 24s ago Main PID: 2169 (mysqld) CGroup: /system.slice/mysql.service └─2169 /usr/sbin/mysqldNov 21 13:04:33 ubuntu systemd[1]: Starting MySQL Community Server...Nov 21 13:04:34 ubuntu systemd[1]: Started MySQL Community Server. 常用命令 查看版本：mysqladmin -p -u root version 启动：service mysql start 停止：service mysql stop 重启：service mysql restart 登录：mysql -u root -p 授权：grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;Your Password&#39;; 扩展阅读配置使用密码方式登录在安装过程中可能没有提示密码设置的环节此时默认使用的是 auth_socket 方式登录，我们需要修改为 mysql_native_password 方式，操作步骤如下 本地登录 MySQL，此时无需输入密码 1mysql -u root -p 切换数据库到 mysql 1use mysql; 修改 root 账号密码 1update user set authentication_string=password('123456') where user='root'; 设置登录模式 1update user set plugin="mysql_native_password"; 刷新配置 1flush privileges; 退出 MySQL 1exit; 重新启动 MySQL 1systemctl restart mysql 配置远程访问 修改配置文件 1vi /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉(语句前面加上 # 即可)： 1# bind-address = 127.0.0.1 重启 MySQL 1service mysql restart 登录 MySQL 1mysql -u root -p 授权 root 用户允许所有人连接 1grant all privileges on *.* to 'root'@'%' identified by 'Your Password'; 因弱口令无法成功授权解决步骤 查看和设置密码安全级别 12select @@validate_password_policy;set global validate_password_policy=0; 查看和设置密码长度限制 12select @@validate_password_length;set global validate_password_length=1; 其它配置修改配置文件：vi /etc/mysql/mysql.conf.d/mysqld.cnf 12345678[client]default-character-set=utf8[mysqld]default-storage-engine=INNODBcharacter-set-server=utf8collation-server=utf8_general_cilower-case-table-names=1 注意： 配置内容追加到对应节点的底部即可 应用部署实战请参考本节视频]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 软件包管理]]></title>
    <url>%2F2013%2F06%2F24%2FLinux%2FDay56_linux%2F015.Linux-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux 软件包管理概述APT(Advanced Packaging Tool) 是 Debian/Ubuntu 类 Linux 系统中的软件包管理程序, 使用它可以找到想要的软件包, 而且安装、卸载、更新都很简便；也可以用来对 Ubuntu 进行升级; APT 的源文件为 /etc/apt/ 目录下的 sources.list 文件。 修改数据源由于国内的网络环境问题，我们需要将 Ubuntu 的数据源修改为国内数据源，操作步骤如下： 查看系统版本12345678lsb_release -a# 输出如下No LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 18.04.2 LTSRelease: 18.04Codename: bionic 注意： Codename 为 bionic，该名称为我们 Ubuntu 系统的名称，修改数据源需要用到该名称 编辑数据源1vi /etc/apt/sources.list 删除全部内容并修改为 1234deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 更新数据源1apt-get update 常用 APT 命令 安装软件包：apt-get install &lt;Package Name&gt; 删除软件包：apt-get remove &lt;Package Name&gt; 更新软件包列表：apt-get update 升级有可用更新的系统(慎用)：apt-get upgrade 搜索：apt-cache search &lt;Package Name&gt; 获取包信息：apt-cache show &lt;Package Name&gt; 删除包及配置文件：apt-get remove &lt;Package Name&gt; --purge 了解使用依赖：apt-cache depends &lt;Package Name&gt; 查看被哪些包依赖：apt-cache rdepends &lt;Package Name&gt; 安装相关的编译环境：apt-get build-dep &lt;Package Name&gt; 下载源代码：apt-get source &lt;Package Name&gt; 清理无用的包：apt-get clean &amp;&amp; apt-get autoclean 检查是否有损坏的依赖：apt-get check]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 文件权限管理]]></title>
    <url>%2F2013%2F06%2F23%2FLinux%2FDay56_linux%2F014.Linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux 文件权限管理查看文件和目录的权限概述ls –al 使用 ls 不带参数只显示文件名称，通过 ls –al 可以显示文件或者目录的权限信息。 ls -l 文件名 显示信息包括：文件类型 (d 目录，- 普通文件，l 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称 -rw-r--r-- 1 lusifer lusifer 675 Oct 26 17:20 .profile -：普通文件 rw-：说明用户 lusifer 有读写权限，没有运行权限 r--：表示用户组 lusifer 只有读权限，没有写和运行的权限 r--：其他用户只有读权限，没有写权限和运行的权限 -rw-r–r– 1 lusifer lusifer 675 Oct 26 17:20 .profile 文档类型及权限 连接数 文档所属用户 文档所属组 文档大小 文档最后被修改日期 文档名称 - rw- r– r– 文档类型 文档所有者权限（user） 文档所属用户组权限（group） 其他用户权限（other） 文档类型 d 表示目录 l 表示软连接 – 表示文件 c 表示串行端口字符设备文件 b 表示可供存储的块设备文件 余下的字符 3 个字符为一组。r 只读，w 可写，x 可执行，- 表示无此权限 连接数指有多少个文件指向同一个索引节点。 文档所属用户和所属组就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的 文档大小默认是 bytes 更改操作权限chown是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组 chown [-R] 用户名称 文件或者目录 chown [-R] 用户名称 用户组名称 文件或目录 -R： 进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限 chmod改变访问权限 chmod [who] [+ | - | =] [mode] 文件名 who表示操作对象可以是以下字母的一个或者组合 u：用户 user g：用户组 group o：表示其他用户 a：表示所有用户是系统默认的 操作符号 +：表示添加某个权限 -：表示取消某个权限 =：赋予给定的权限，取消文档以前的所有权限 mode表示可执行的权限，可以是 r、w、x 文件名文件名可以使空格分开的文件列表 示例123456lusifer@UbuntuBase:~$ ls -al test.txt -rw-rw-r-- 1 lusifer lusifer 6 Nov 2 21:47 test.txtlusifer@UbuntuBase:~$ chmod u=rwx,g+r,o+r test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrw-r-- 1 lusifer lusifer 6 Nov 2 21:47 test.txtlusifer@UbuntuBase:~$ 数字设定法数字设定法中数字表示的含义 0 表示没有任何权限 1 表示有可执行权限 = x 2 表示有可写权限 = w 4 表示有可读权限 = r 也可以用数字来表示权限如 chmod 755 file\_name r w x r – x r - x 4 2 1 4 - 1 4 - 1 user group others 若要 rwx 属性则 4+2+1=7 若要 rw- 属性则 4+2=6 若要 r-x 属性则 4+1=5 1234567lusifer@UbuntuBase:~$ chmod 777 test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrwxrwx 1 lusifer lusifer 6 Nov 2 21:47 test.txtlusifer@UbuntuBase:~$ chmod 770 test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrwx--- 1 lusifer lusifer 6 Nov 2 21:47 test.txt]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 用户组和组管理]]></title>
    <url>%2F2013%2F06%2F22%2FLinux%2FDay56_linux%2F013.Linux-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux 用户和组管理概述Linux 操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰。 使用 Root 用户在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。 设置 Root 账户密码 1sudo passwd root 切换到 Root 1su 设置允许远程登录 Root 12345678910vi /etc/ssh/sshd_config# Authentication:LoginGraceTime 120#PermitRootLogin without-password //注释此行PermitRootLogin yes //加入此行StrictModes yes# 重启服务service ssh restart 用户账户说明 普通用户： 普通用户在系统上的任务是进行普通操作 超级管理员： 管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。 安装时创建的系统用户： 此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 sudo 就是一个普通用户。 组账户说明 私有组： 当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。 标准组： 当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。 扩展阅读账户系统文件说明/etc/passwd每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息： root:x:0:0:root:/root:/bin/bash 用户名： 就是账号，用来对应 UID，root UID 是 0。 口令： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。 用户标示号（UID）： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。 组标示号（GID）： 与 /etc/group 相关用来规定组名和 GID 相对应。 注释： 注释账号 宿主目录（主文件夹）： 用户登录系统后所进入的目录 root 在 /root/itcast 命令解释器（shell）： 指定该用户使用的 shell ，默认的是 /bin/bash /etc/shadow为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息： root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7::: 账号名称： 需要和 /etc/passwd 一致。 密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下： -rw——- 1 root root 1560 Oct 26 17:20 passwd- 只有root能都读写 最近修改密码日期： 从1970-1-1起，到用户最后一次更改口令的天数 密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数 密码最大时间间隔： 从1970-1-1起，必须更改的口令天数 密码到期警告时间： 在口令过期之前几天通知 密码到期后账号宽限时间 密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数 保留 /etc/group用户组的配置文件 root:x:0: 用户组名称 用户组密码： 给用户组管理员使用，通常不用 GID： 用户组的ID 此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root:x:0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。 /etc/gshadow该文件用户定义用户组口令，组管理员等信息只有root用户可读。 root:\*:: 用户组名 密码列 用户组管理员的账号 用户组所属账号 账户管理常用命令增加用户123456useradd 用户名useradd -u (UID号)useradd -p (口令)useradd -g (分组)useradd -s (SHELL)useradd -d (用户目录) 如：useradd lusifer 增加用户名为 lusifer 的账户 修改用户12345678usermod -u (新UID)usermod -d (用户目录)usermod -g (组名)usermod -s (SHELL)usermod -p (新口令)usermod -l (新登录名)usermod -L (锁定用户账号密码)usermod -U (解锁用户账号) 如：usermod -u 1024 -g group2 -G root lusifer 将 lusifer 用户 uid 修改为 1024，默认组改为系统中已经存在的 group2，并且加入到系统管理员组 删除用户12userdel 用户名 (删除用户账号)userdel -r 删除账号时同时删除目录 如：userdel -r lusifer 删除用户名为 lusifer 的账户并同时删除 lusifer 的用户目录 组账户维护12345groupadd 组账户名 (创建新组)groupadd -g 指定组GIDgroupmod -g 更改组的GIDgroupmod -n 更改组账户名groupdel 组账户名 (删除指定组账户) 口令维护1234567passwd 用户账户名 (设置用户口令)passwd -l 用户账户名 (锁定用户账户)passwd -u 用户账户名 (解锁用户账户)passwd -d 用户账户名 (删除账户口令)gpasswd -a 用户账户名 组账户名 (将指定用户添加到指定组)gpasswd -d 用户账户名 组账户名 (将用户从指定组中删除)gpasswd -A 用户账户名 组账户名 (将用户指定为组的管理员) 用户和组状态1234su 用户名(切换用户账户)id 用户名(显示用户的UID，GID)whoami (显示当前用户名称)groups (显示用户所属组)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Vim 编辑器]]></title>
    <url>%2F2013%2F06%2F21%2FLinux%2FDay56_linux%2F012.Linux-Vim%20%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Linux Vim 编辑器概述Vim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 Vim 则可以说是程序开发者的一项很好用的工具。 运行模式 编辑模式：等待编辑命令输入 插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息 命令模式：在编辑模式下，输入 : 进行命令模式 命令模式 :q：直接退出vi :wq：保存后退出vi ，并可以新建文件 :q!：强制退出 :w file：将当前内容保存成某个文件 /：查找字符串 :set number： 在编辑文件显示行号 :set nonumber：在编辑文件不显示行号 :set paste：原样粘贴]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统管理]]></title>
    <url>%2F2013%2F06%2F20%2FLinux%2FDay56_linux%2F011.Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux 系统管理系统管理命令 命令 说明 stat 显示指定文件的相关信息,比 ls 命令显示内容更多 who 显示在线登录用户 hostname 显示主机名称 uname 显示系统信息 top 显示当前系统中耗费资源最多的进程 ps 显示瞬间的进程状态 du 显示指定的文件（目录）已使用的磁盘空间的总量 df 显示文件系统磁盘空间的使用情况 free 显示当前内存和交换空间的使用情况 ifconfig 显示网络接口信息 ping 测试网络的连通性 netstat 显示网络状态信息 clear 清屏 kill 杀死一个进程 开关机命令shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 命令 语法 参数 参数说明 shutdown shutdown [-t seconds] [-rkhncfF] time [message] -t seconds 设定在几秒钟之后进行关机程序 -k 并不会真的关机，只是将警告讯息传送给所有只用者 -r 关机后重新开机（重启） -h 关机后停机 -n 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机 -c 取消目前已经进行中的关机动作 -f 关机时，不做 fcsk 动作(检查 Linux 档系统) -F 关机时，强迫进行 fsck 动作 time 设定关机的时间 message 传送给所有使用者的警告讯息 重启 sudo reboot sudo shutdown -r now 关机 shutdown -h now]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 目录管理]]></title>
    <url>%2F2013%2F06%2F19%2FLinux%2FDay56_linux%2F010.Linux-%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux 目录管理目录结构 目录 说明 bin 存放二进制可执行文件(ls, cat, mkdir 等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有 root 才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录 /usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 操作文件目录 命令 说明 语法 参数 参数说明 ls 显示文件和目录列表 ls [-alrtAFR] [name…] -l 列出文件的详细信息 -a 列出当前目录所有文件，包含隐藏文件 mkdir 创建目录 mkdir [-p] dirName -p 父目录不存在情况下先生成父目录 cd 切换目录 cd [dirName] touch 生成一个空文件 echo 生成一个带内容文件 echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt cat 显示文本文件内容 cat [-AbeEnstTuv] [–help] [–version] fileName cp 复制文件或目录 cp [options] source dest rm 删除文件 rm [options] name… -f 强制删除文件或目录 -r 同时删除该目录下的所有文件 mv 移动文件或目录 mv [options] source dest find 在文件系统中查找指定的文件 -name 文件名 grep 在指定的文本文件中查找指定的字符串 tree 用于以树状图列出目录的内容 pwd 显示当前工作目录 ln 建立软链接 more 分页显示文本文件内容 head 显示文件开头内容 tail 显示文件结尾内容 -f 跟踪输出 压缩解压缩tar 命令 语法 参数 参数说明 tar tar [-cxzjvf] 压缩打包文档的名称 欲打包目录 -c 建立一个归档文件的参数指令 -x 解开一个归档文件的参数指令 -z 是否需要用 gzip 压缩 -j 是否需要用 bzip2 压缩 -v 压缩的过程中显示文件 -f 使用档名，在 f 之后要立即接档名 -tf 查看归档文件里面的文件 例子： 压缩文件夹：tar -zcvf test.tar.gz test\ 解压文件夹：tar -zxvf test.tar.gz gzip 命令 语法 参数 参数说明 gzip gzip [选项] 压缩（解压缩）的文件名 -d 解压缩 -l 对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字 -v 对每一个压缩和解压的文件，显示文件名和压缩比 -num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6 压缩文件后缀为 gz bzip2 命令 语法 参数 参数说明 bzip2 bzip2 [-cdz] -d 解压缩 -z 压缩参数 -num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6 压缩文件后缀为 bz2]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 远程控制管理]]></title>
    <url>%2F2013%2F06%2F18%2FLinux%2FDay56_linux%2F009.Linux-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux 远程控制管理概述传统的网络服务程序，FTP、POP、Telnet 本质上都是不安全的，因为它们在网络上通过明文传送口令和数据，这些数据非常容易被截获。SSH 叫做 Secure Shell。通过 SSH，可以把传输数据进行加密，预防攻击，传输的数据进行了压缩，可以加快传输速度。 OpenSSHSSH 是芬兰一家公司开发。但是受到版权和加密算法限制，现在很多人都使用 OpenSSH。OpenSSH 是 SSH 的替代软件，免费。OpenSSH 由客户端和服务端组成。 基于口令的安全验证： 知道服务器的帐号密码即可远程登录，口令和数据在传输过程中都会被加密。 基于密钥的安全验证： 此时需要在创建一对密钥，把公有密钥放到远程服务器上自己的宿主目录中，而私有密钥则由自己保存。 安装流程如下： 检查软件是否安装 1sudo apt-cache policy openssh-client openssh-server 安装服务端 1sudo apt-get install openssh-server 安装客户端 1sudo apt-get install openssh-client OpenSSH 服务器的主要配置文件为 /etc/ssh/sshd\_config，几乎所有的配置信息都在此文件中。 XShellXShell 是一个强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议。XShell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。 XShell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。 FinalShellFinalShell 是一体化的的服务器，网络管理软件，不仅是 SSH 客户端，还是功能强大的开发，运维工具，充分满足开发，运维需求。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux简介]]></title>
    <url>%2F2013%2F06%2F17%2FLinux%2FDay56_linux%2F008.Linux-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Linux 简介概述Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。 Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。 Linux 与 Windows 比较目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下 比较 Windows Linux 界面 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。 驱动程序 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。 由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在 Windows 下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。 使用 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。 图形界面使用简单，容易入门。文字界面，需要学习才能掌握。 学习 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。 软件 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。 大部分软件都可以自由获取，同样功能的软件选择较少。 安装 Linux 操作系统原生云应用基本都是基于云服务器部署，本地化的 Linux 操作基本也都是在虚拟机中进行模拟操作。故我们只需要安装虚拟机并在虚拟机上安装对应的 Linux 操作系统即可。本套课程全部基于 Ubuntu Server 18.04 LTS 操作系统进行实践。 安装中需要设置镜像地址，我们使用阿里云镜像地址，http://mirrors.aliyun.com/ubuntu/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro]]></title>
    <url>%2F2013%2F06%2F16%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FShiro%2F</url>
    <content type="text"><![CDATA[Shiro一. Shiro权限 什么是权限控制： 忽略特别细的概念，比如权限能细分很多种，功能权限，数据权限，管理权限等 理解两个概念：用户和资源，让指定的用户，只能操作指定的资源（CRUD） 初学javaweb时怎么做 Filter接口中有一个doFilter方法，自己编写好业务Filter，并配置对哪个web资源进行拦截后 如果访问的路径命中对应的Filter，则会执行doFilter()方法，然后判断是否有权限进行访问对应的资源 /api/user/info?id=1 123456789101112public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) &#123; HttpServletRequest httpRequest=(HttpServletRequest)request; HttpServletResponse httpResponse=(HttpServletResponse)response; HttpSession session=httpRequest.getSession(); if(session.getAttribute(&quot;username&quot;)!=null)&#123; chain.doFilter(request, response); //如果可以放行 &#125; else &#123; httpResponse.sendRedirect(httpRequest.getContextPath()+&quot;/login.jsp&quot;); &#125;&#125; 二. 权限框架ACL和RBAC2.1 什么是ACL和RBAC ACL: Access Control List 访问控制列表 以前盛行的一种权限设计，它的核心在于用户直接和权限挂钩 优点：简单易用，开发便捷 缺点：用户和权限直接挂钩，导致在授予时的复杂性，比较分散，不便于管理 例子：常见的文件系统权限设计, 直接给用户加权限 RBAC: Role Based Access Control 基于角色的访问控制系统。权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限 优点：简化了用户与权限的管理，通过对用户进行分类，使得角色与权限关联起来 缺点：开发对比ACL相对复杂 例子：基于RBAC模型的权限验证框架与应用 Apache Shiro、spring Security BAT企业 ACL，一般是对报表系统，阿里的ODPS 总结：不能过于复杂，规则过多，维护性和性能会下降， 更多分类 ABAC、PBAC等 2.2 主流权限框架介绍和技术选型讲解 什么是 spring Security：官网基础介绍 官网：https://spring.io/projects/spring-security 123Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。一句话：Spring Security 的前身是 Acegi Security ，是 Spring 项目组中用来提供安全认证服务的框架 什么是 Apache Shiro：官网基础介绍 https://github.com/apache/shiro 123Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。一句话：Shiro是一个强大易用的Java安全框架,提供了认证、授权、加密和会话管理等功能 两个优缺点，应该怎么选择 Apache Shiro比Spring Security , 前者使用更简单 Shiro 功能强大、 简单、灵活， 不跟任何的框架或者容器绑定，可以独立运行 Spring Security 对Spring 体系支持比较好，脱离Spring体系则很难开发 SpringSecutiry 支持Oauth鉴权 https://spring.io/projects/spring-security-oauth，Shiro需要自己实现 三. Apache Shiro基础概念和架构3.1 Shiro核心知识之架构图交互和四大模块 直达Apache Shiro官网 http://shiro.apache.org/introduction.html 什么是身份认证 Authentication，身份证认证，一般就是登录 什么是授权 Authorization，给用户分配角色或者访问某些资源的权限 什么是会话管理 Session Management, 用户的会话管理员，多数情况下是web session 什么是加密 Cryptography, 数据加解密，比如密码加解密等 3.2 Shrio权限控制流程和概念 Subject 我们把用户或者程序称为主体（如用户，第三方服务，cron作业），主体去访问系统或者资源 SecurityManager 安全管理器，Subject的认证和授权都要在安全管理器下进行 Authenticator 认证器，主要负责Subject的认证 Realm 数据域，Shiro和安全数据的连接器，好比jdbc连接数据库； 通过realm获取认证授权相关信息 Authorizer 授权器，主要负责Subject的授权, 控制subject拥有的角色或者权限 Cryptography 加解密，Shiro的包含易于使用和理解的数据加解密方法，简化了很多复杂的api Cache Manager 缓存管理器，比如认证或授权信息，通过缓存进行管理，提高性能 更多资料导航：http://shiro.apache.org/reference.html 四. Spring boot整合Shiro4.1 依赖12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt; &lt;!-- mybatis分页支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; &lt;!-- tk.mybatis对mybatis做了二次封装--&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;4.1.5&lt;/version&gt;&lt;/dependency&gt; &lt;!-- tk.mybatis与spring boot整合 --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt;&lt;/dependency&gt; 4.2 数据库表的设计权限标准五张表： sys_user sys_role sys_user_role sys_permission sys_role_permission 4.3 自定义realm1234567891011121314151617181920public class CustomRealm extends AuthorizingRealm &#123; /** * 进行权限校验的时候回调用 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)&#123; SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); return simpleAuthorizationInfo; &#125; /** * 用户登录的时候会调用 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; return new SimpleAuthenticationInfo(username, user.getPassword(), this.getClass().getName()); &#125;&#125; 4.3 shiro配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394@Configurationpublic class ShiroConfig &#123; @Bean public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager); shiroFilterFactoryBean.setLoginUrl("/no_login"); shiroFilterFactoryBean.setUnauthorizedUrl("/no_auth"); Map&lt;String, String&gt; chainFilter = new LinkedHashMap&lt;&gt;(); chainFilter.put("/login", "anon"); //允许登录 chainFilter.put("/**", "authc"); shiroFilterFactoryBean.setFilterChainDefinitionMap(chainFilter); return shiroFilterFactoryBean; &#125; /** * 该类的作用是，实现注解的方式来设置权限 */ @Bean public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator()&#123; DefaultAdvisorAutoProxyCreator advisor = new DefaultAdvisorAutoProxyCreator(); advisorAutoProxyCreator.setProxyTargetClass(true); return advisorAutoProxyCreator; &#125; /** * 实现注解的方式来配置权限 */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager)&#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; &#125; /** @Bean public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125; */ /** * SecurityManager的配置 */ @Bean public SecurityManager securityManager(SessionManager manager, Realm realm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setSessionManager(sessionManager); securityManager.setRealm(realm); return securityManager; &#125; /** * SessionManager的配置 */ @Bean public SessionManager sessionManager()&#123; SessionManager sessionManager = new CustomSessionManager(); return sessionManager; &#125; /** * Realm * @param addSaltCredentialsMatch * @return */ @Bean public Realm realm(AddSaltCredentialsMatch addSaltCredentialsMatch) &#123; CustomRealm realm = new CustomRealm(); realm.setCredentialsMatcher(addSaltCredentialsMatch); //密码规则 return realm; &#125; /** * 自定义的密码加盐规则 * @return */ @Bean public AddSaltCredentialsMatch addSaltCredentialsMatch() &#123; return new AddSaltCredentialsMatch(); &#125;&#125; 4.4 自定义SessionManager123456789101112131415161718192021222324252627public class CustomSessionManager extends DefaultWebSessionManager &#123; /** * 重写默认的session * @param request * @param response * @return */ @Override protected Serializable getSessionId(ServletRequest request, ServletResponse response) &#123; String sessionId = WebUtils.toHttp(request).getHeader("token"); if(null != sessionId) &#123; request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, ShiroHttpServletRequest.COOKIE_SESSION_ID_SOURCE); request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, sessionId); //automatically mark it valid here. If it is invalid, the //onUnknownSession method below will be invoked and we'll remove the attribute at that time. request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE); return sessionId; &#125;else &#123; return super.getSessionId(request, response); &#125; &#125;&#125; 五. 权限数据缓存​ redis作为企业使用最为频繁的中间件，用来缓存各种业务数据，在使用shiro的缓存的时候，课程中还是采用redis来作为缓存中间件。下载地址：https://github.com/MicrosoftArchive/redis/releases 5.1 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt;&lt;/dependency&gt; 5.2 配置RedisManager123456@Beanpublic RedisManager redisManager() &#123; RedisManager redisManager = new RedisManager(); redisManager.setHost(&quot;localhost:6379&quot;); return redisManager;&#125; 5.3 配置CacheManager123456@Beanpublic CacheManager cacheManager(RedisManager redisManager) &#123; RedisCacheManager cacheManager = new RedisCacheManager(); cacheManager.setRedisManager(redisManager); return cacheManager;&#125; 5.4 在SecurityManager中加入缓存管理1securityManager.setCacheManager(cacheManager); 六. Session数据的缓存6.1 配置RedisSessionDao123456@Beanpublic RedisSessionDAO redisSessionDAO(RedisManager redisManager) &#123; RedisSessionDAO redisSessionDAO = new RedisSessionDAO(); redisSessionDAO.setRedisManager(redisManager); return redisSessionDAO;&#125; 6.2 SessionManager的设置123456@Beanpublic SessionManager sessionManager(RedisSessionDAO redisSessionDAO)&#123; CustomSessionManager sessionManager = new CustomSessionManager(); sessionManager.setSessionDAO(redisSessionDAO); return sessionManager;&#125;]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Schedule(定时任务)]]></title>
    <url>%2F2013%2F06%2F15%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FSchedule(%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1)%2F</url>
    <content type="text"><![CDATA[Schedule(定时任务)⼀张图来说明（任务执⾏⻓度超过周期的情况）： ​ 虽然定时任务可以嵌⼊到web应⽤程序和WAR⽂件中，但下⾯演⽰⼀种更简单的⽅法创建了⼀个独⽴的应⽤程序。您将所有的内容打包在⼀个单⼀的、可执⾏的JAR⽂件中，⽤⼀个传统Java main()⽅法驱动。这也就是springboot的启动类。 一. 入门案例1.1 主程序12345678910111213package com.qianfeng.test.task;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableSchedulingpublic class Application &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Application.class); &#125;&#125; 1.2 任务类代码12345678910111213141516171819202122@Componentpublic class MyScheduled &#123; /** * fixedRate: 固定时间去执行。 * fixedDelay: 固定的延迟。 * * cron有六个站位符号： 第一个表示秒，第二个是分，第三个小时，第四是日， * 第五个是月份，第六个是星期 * 0/2 * * * * * 每两秒执行一次 * 0 25 11 * * * 每天11:25执行 * 0 0/1 11 * * * 每天的11点，每隔5分钟执行一次 * 0 0 20 * * * 每天晚上8点钟执行 * 0 0 8,20 * * * 每天早晚8点执行一次 * 0 0 8-20 * * * 每天早上8点到晚8点，每个小时执行一次 * 0 0 12 L * * * 每个月的最后一天12钟执行。 */ @Scheduled(fixedRate = 5000) public void test1() &#123; System.out.println("定时任务触发了"); &#125;&#125; 二. 参数介绍fixedRate ​ fixedRate表⽰从调⽤开始每次延迟多少毫秒继续调⽤ ⽤法@Scheduled(fixedRate=5000)，5000的单位是毫秒，也就是间隔时间是5秒。 fixedDelay ​ fixedDelay表⽰从调⽤开始延时多少毫秒继续调⽤下⼀个周期 ⽤法@Scheduled(fixedDelay=5000)，5000的单位是毫秒，也就是间隔时间是5秒。 initialDelay​ fixedDelay表⽰在第⼀次执⾏fixedRate()或fixedDelay()任务之前延迟的毫秒数。 ⽤@Scheduled(fixedDelay=5000, initialDelay=10000)，单位是毫秒，表⽰第⼀次执⾏fixedDelay()任务之前先延迟10秒。@Scheduled(cron=”0 0 ”) ​ cron表达式相⽐于前⼏个是⽐较复杂的。 该模式是6个单独的空间分隔字段的列表：表示秒、分钟、小时、日、月、星期。 12345678910&quot;0 0 * * * *&quot; = 每天每时整点&quot;*/10 * * * * *&quot; = 每⼗秒（10:20:00, 10:20:10, 10:20:20 ...）触发&quot;0 0 8-10 * * *&quot; = 每天早上8:00、9:00 和 10:00 触发&quot;0 0 6,19 * * *&quot; = 每天6:00 和 19:00 触发&quot;0 0/30 8-10 * * *&quot; = 每天8:00, 8:30, 9:00, 9:30, 10:00 和 10:30 触发&quot;0 0 9-17 * * MON-FRI&quot; = 朝九晚五（周⼀⾄周五9:00-17:00的整点）触发&quot;0 0 0 25 12 ?&quot; = 圣诞节（每年的12⽉25⽇00:00）触发&quot;0 15 10 L * ?&quot; = 每⽉最后⼀⽇的上午10:15触发&quot;0 15 10 ? * 6L&quot; = 每⽉的最后⼀个星期五上午10:15触发&quot;0 15 10 ? * 6#3&quot; = 每⽉的第三个星期五上午10:15触发 1234567891011 三. 并⾏执⾏任务​ 上⾯的方式中,如果我们开启多个定时任务,他们会使⽤同⼀个线程开启任务,可能会因为某个任务阻塞而导致执⾏失败,所以我们可以使⽤多线程并⾏执⾏任务,只需要添加⼀个线程池即可 3.1 并行类1234567891011121314@Componentpublic class MySheduleConfig implements SchedulingConfigurer &#123; public Executor getExecutor() &#123; return Executors.newScheduledThreadPool(3); //开启特定的任务线程，开启3个 &#125; // @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.setScheduler(getExecutor()); &#125;&#125; 3.2 任务类12345678910111213141516171819202122@Componentpublic class MySchedule &#123; @Scheduled(cron = "0/5 * * * * *") public void doSomething() &#123; System.out.println("每五秒执行的任务线程名：" + Thread.currentThread().getName()); System.out.println("定时任务开始................"); &#125; @Scheduled(cron = "0/3 * * * * *") public void doSomething1() &#123; System.out.println("每3秒执行的任务线程名：" + Thread.currentThread().getName()); System.out.println("定时任务每3秒执行一次次，任务开始执行..."); &#125; @Scheduled(cron = "0/10 * * * * *") public void doSomething2() &#123; System.out.println("每10秒执行的任务线程名：" + Thread.currentThread().getName()); System.out.println("定时任务每天早8点到晚8点，每20分钟执行一次，开始"); &#125;&#125;]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ 自定义 Binding]]></title>
    <url>%2F2013%2F06%2F14%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRocketMQ%2F5.RocketMQ%20%E8%87%AA%E5%AE%9A%E4%B9%89%20Binding%2F</url>
    <content type="text"><![CDATA[RocketMQ 自定义 Binding概述在实际生产中，我们需要发布和订阅的消息可能不止一种 Topic ，故此时就需要使用自定义 Binding 来帮我们实现多 Topic 的发布和订阅功能 生产者自定义 Output 接口，代码如下： 1234567public interface MySource &#123; @Output("output1") MessageChannel output1(); @Output("output2") MessageChannel output2();&#125; 发布消息的案例代码如下： 123456@Autowiredprivate MySource source;public void send(String msg) throws Exception &#123; source.output1().send(MessageBuilder.withPayload(msg).build());&#125; 消费者自定义 Input 接口，代码如下： 12345678910111213public interface MySink &#123; @Input("input1") SubscribableChannel input1(); @Input("input2") SubscribableChannel input2(); @Input("input3") SubscribableChannel input3(); @Input("input4") SubscribableChannel input4();&#125; 接收消息的案例代码如下： 1234@StreamListener("input1")public void receiveInput1(String receiveMsg) &#123; System.out.println("input1 receive: " + receiveMsg);&#125; Application配置 Input 和 Output 的 Binding 信息并配合 @EnableBinding 注解使其生效，代码如下： 1234567@SpringBootApplication@EnableBinding(&#123; MySource.class, MySink.class &#125;)public class RocketMQApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RocketMQApplication.class, args); &#125;&#125; application.yml生产者1234567891011spring: application: name: rocketmq-provider cloud: stream: rocketmq: binder: namesrv-addr: 192.168.10.149:9876 bindings: output1: &#123;destination: test-topic1, content-type: application/json&#125; output2: &#123;destination: test-topic2, content-type: application/json&#125; 消费者123456789101112131415spring: application: name: rocketmq-consumer cloud: stream: rocketmq: binder: namesrv-addr: 192.168.10.149:9876 bindings: input: &#123;consumer.orderly: true&#125; bindings: input1: &#123;destination: test-topic1, content-type: text/plain, group: test-group, consumer.maxAttempts: 1&#125; input2: &#123;destination: test-topic1, content-type: text/plain, group: test-group, consumer.maxAttempts: 1&#125; input3: &#123;destination: test-topic2, content-type: text/plain, group: test-group, consumer.maxAttempts: 1&#125; input4: &#123;destination: test-topic2, content-type: text/plain, group: test-group, consumer.]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ 消费者]]></title>
    <url>%2F2013%2F06%2F13%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRocketMQ%2F4.RocketMQ%20%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[RocketMQ 消费者POM主要增加了 org.springframework.cloud:spring-cloud-starter-stream-rocketmq 依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-alibaba-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba-rocketmq-consumer&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-alibaba-rocketmq-consumer&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rocketmq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.alibaba.rocketmq.consumer.RocketMQConsumerApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 消息消费者服务主要使用 @StreamListener(&quot;input&quot;) 注解来订阅从名为 input 的 Binding 中接收的消息 12345678910111213package com.funtl.hello.spring.cloud.alibaba.rocketmq.consumer.receive;import org.springframework.cloud.stream.annotation.StreamListener;import org.springframework.stereotype.Service;@Servicepublic class ConsumerReceive &#123; @StreamListener("input") public void receiveInput(String message) &#123; System.out.println("Receive input: " + message); &#125;&#125; Application配置 Input(Sink.class) 的 Binding 信息并配合 @EnableBinding 注解使其生效 1234567891011121314package com.funtl.hello.spring.cloud.alibaba.rocketmq.consumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.cloud.stream.messaging.Sink;@SpringBootApplication@EnableBinding(&#123;Sink.class&#125;)public class RocketMQConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RocketMQConsumerApplication.class, args); &#125;&#125; application.yml123456789101112131415161718192021spring: application: name: rocketmq-consumer cloud: stream: rocketmq: binder: namesrv-addr: 192.168.10.149:9876 bindings: input: &#123;consumer.orderly: true&#125; bindings: input: &#123;destination: test-topic, content-type: text/plain, group: test-group, consumer.maxAttempts: 1&#125;server: port: 9094management: endpoints: web: exposure: include: '*' 运行成功后即可在控制台接收到消息：Receive input: Hello RocketMQ]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ 生产者]]></title>
    <url>%2F2013%2F06%2F12%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRocketMQ%2F3.RocketMQ%20%E7%94%9F%E4%BA%A7%E8%80%85%2F</url>
    <content type="text"><![CDATA[RocketMQ 生产者概述RocketMQ 是一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 由于本教程整个案例基于 Spring Cloud，故我们采用 Spring Cloud Stream 完成一次发布和订阅 官方教程 Spring Cloud StreamSpring Cloud Stream 是一个用于构建基于消息的微服务应用框架。它基于 Spring Boot 来创建具有生产级别的单机 Spring 应用，并且使用 Spring Integration 与 Broker 进行连接。 Spring Cloud Stream 提供了消息中间件配置的统一抽象，推出了 publish-subscribe、consumer groups、partition 这些统一的概念。 Spring Cloud Stream 内部有两个概念： Binder： 跟外部消息中间件集成的组件，用来创建 Binding，各消息中间件都有自己的 Binder 实现。 Binding： 包括 Input Binding 和 Output Binding。 Binding 在消息中间件与应用程序提供的 Provider 和 Consumer 之间提供了一个桥梁，实现了开发者只需使用应用程序的 Provider 或 Consumer 生产或消费数据即可，屏蔽了开发者与底层消息中间件的接触。 解决连接超时问题在之前的 基于 Docker 安装 RocketMQ 章节中，我们采用 Docker 部署了 RocketMQ 服务，此时 RocketMQ Broker 暴露的地址和端口(10909，10911)是基于容器的，会导致我们开发机无法连接，从而引发 org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout 异常 注意下图中的 IP 地址，这个是容器的 IP，开发机与容器不在一个局域网所以无法连接。 解决方案是在 broker.conf 配置文件中增加 brokerIP1=宿主机IP 即可 POM主要增加了 org.springframework.cloud:spring-cloud-starter-stream-rocketmq 依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-alibaba-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba-rocketmq-provider&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-alibaba-rocketmq-provider&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rocketmq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.alibaba.rocketmq.provider.RocketMQProviderApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 消息生产者服务12345678910111213141516package com.funtl.hello.spring.cloud.alibaba.rocketmq.provider.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.messaging.MessageChannel;import org.springframework.messaging.support.MessageBuilder;import org.springframework.stereotype.Service;@Servicepublic class ProviderService &#123; @Autowired private MessageChannel output; public void send(String message) &#123; output.send(MessageBuilder.withPayload(message).build()); &#125;&#125; Application配置 Output(Source.class) 的 Binding 信息并配合 @EnableBinding 注解使其生效 12345678910111213141516171819202122232425262728293031package com.funtl.hello.spring.cloud.alibaba.rocketmq.provider;import com.funtl.hello.spring.cloud.alibaba.rocketmq.provider.service.ProviderService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.cloud.stream.messaging.Source;@SpringBootApplication@EnableBinding(&#123;Source.class&#125;)public class RocketMQProviderApplication implements CommandLineRunner &#123; @Autowired private ProviderService providerService; public static void main(String[] args) &#123; SpringApplication.run(RocketMQProviderApplication.class, args); &#125; /** * 实现了 CommandLineRunner 接口，只是为了 Spring Boot 启动时执行任务，不必特别在意 * @param args * @throws Exception */ @Override public void run(String... args) throws Exception &#123; providerService.send("Hello RocketMQ"); &#125;&#125; application.yml123456789101112131415161718192021spring: application: name: rocketmq-provider cloud: stream: rocketmq: binder: # RocketMQ 服务器地址 name-server: 192.168.10.149:9876 bindings: # 这里是个 Map 类型参数，&#123;&#125; 为 YAML 中 Map 的行内写法 output: &#123;destination: test-topic, content-type: application/json&#125;server: port: 9093management: endpoints: web: exposure: include: '*' 运行成功后即可在 RocketMQ 控制台的 消息 列表中选择 test-topic 主题即可看到发送的消息]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ 简介]]></title>
    <url>%2F2013%2F06%2F11%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRocketMQ%2F2.RocketMQ%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[RocketMQ 简介概述消息队列作为高并发系统的核心组件之一，能够帮助业务系统解构提升开发效率和系统稳定性。主要具有以下优势： 削峰填谷： 主要解决瞬时写压力大于应用服务能力导致消息丢失、系统奔溃等问题 系统解耦： 解决不同重要程度、不同能力级别系统之间依赖导致一死全死 提升性能： 当存在一对多调用时，可以发一条消息给消息系统，让消息系统通知相关系统 蓄流压测： 线上有些链路不好压测，可以通过堆积一定量消息再放开来压测 RocketMQApache Alibaba RocketMQ 是一个消息中间件。消息中间件中有两个角色：消息生产者和消息消费者。RocketMQ 里同样有这两个概念，消息生产者负责创建消息并发送到 RocketMQ 服务器，RocketMQ 服务器会将消息持久化到磁盘，消息消费者从 RocketMQ 服务器拉取消息并提交给应用消费。 RocketMQ 特点RocketMQ 是一款分布式、队列模型的消息中间件，具有以下特点： 支持严格的消息顺序 支持 Topic 与 Queue 两种模式 亿级消息堆积能力 比较友好的分布式特性 同时支持 Push 与 Pull 方式消费消息 历经多次天猫双十一海量消息考验 RocketMQ 优势目前主流的 MQ 主要是 RocketMQ、kafka、RabbitMQ，其主要优势有： 支持事务型消息（消息发送和 DB 操作保持两方的最终一致性，RabbitMQ 和 Kafka 不支持） 支持结合 RocketMQ 的多个系统之间数据最终一致性（多方事务，二方事务是前提） 支持 18 个级别的延迟消息（RabbitMQ 和 Kafka 不支持） 支持指定次数和时间间隔的失败消息重发（Kafka 不支持，RabbitMQ 需要手动确认） 支持 Consumer 端 Tag 过滤，减少不必要的网络传输（RabbitMQ 和 Kafka 不支持） 支持重复消费（RabbitMQ 不支持，Kafka 支持） 消息队列对比参照表 基于 Docker 安装 RocketMQdocker-compose.yml注意：启动 RocketMQ Server + Broker + Console 至少需要 2G 内存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455version: '3.5'services: rmqnamesrv: image: foxiswho/rocketmq:server container_name: rmqnamesrv ports: - 9876:9876 volumes: - ./data/logs:/opt/logs - ./data/store:/opt/store networks: rmq: aliases: - rmqnamesrv rmqbroker: image: foxiswho/rocketmq:broker container_name: rmqbroker ports: - 10909:10909 - 10911:10911 volumes: - ./data/logs:/opt/logs - ./data/store:/opt/store - ./data/brokerconf/broker.conf:/etc/rocketmq/broker.conf environment: NAMESRV_ADDR: "rmqnamesrv:9876" JAVA_OPTS: " -Duser.home=/opt" JAVA_OPT_EXT: "-server -Xms128m -Xmx128m -Xmn128m" command: mqbroker -c /etc/rocketmq/broker.conf depends_on: - rmqnamesrv networks: rmq: aliases: - rmqbroker rmqconsole: image: styletang/rocketmq-console-ng container_name: rmqconsole ports: - 8080:8080 environment: JAVA_OPTS: "-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false" depends_on: - rmqnamesrv networks: rmq: aliases: - rmqconsolenetworks: rmq: name: rmq driver: bridge broker.confRocketMQ Broker 需要一个配置文件，按照上面的 Compose 配置，我们需要在 ./data/brokerconf/ 目录下创建一个名为 broker.conf 的配置文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# Licensed to the Apache Software Foundation (ASF) under one or more# contributor license agreements. See the NOTICE file distributed with# this work for additional information regarding copyright ownership.# The ASF licenses this file to You under the Apache License, Version 2.0# (the &quot;License&quot;); you may not use this file except in compliance with# the License. You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.# 所属集群名字brokerClusterName=DefaultCluster# broker 名字，注意此处不同的配置文件填写的不一样，如果在 broker-a.properties 使用: broker-a,# 在 broker-b.properties 使用: broker-bbrokerName=broker-a# 0 表示 Master，&gt; 0 表示 SlavebrokerId=0# nameServer地址，分号分割# namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876# 启动IP,如果 docker 报 com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;192.168.0.120:10909&gt; failed# 解决方式1 加上一句 producer.setVipChannelEnabled(false);，解决方式2 brokerIP1 设置宿主机IP，不要使用docker 内部IP# brokerIP1=192.168.0.253# 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4# 是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭 ！！！这里仔细看是 false，false，falseautoCreateTopicEnable=true# 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true# Broker 对外服务的监听端口listenPort=10911# 删除文件时间点，默认凌晨4点deleteWhen=04# 文件保留时间，默认48小时fileReservedTime=120# commitLog 每个文件的大小默认1GmapedFileSizeCommitLog=1073741824# ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整mapedFileSizeConsumeQueue=300000# destroyMapedFileIntervalForcibly=120000# redeleteHangedFileInterval=120000# 检测物理文件磁盘空间diskMaxUsedSpaceRatio=88# 存储路径# storePathRootDir=/home/ztztdata/rocketmq-all-4.1.0-incubating/store# commitLog 存储路径# storePathCommitLog=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/commitlog# 消费队列存储# storePathConsumeQueue=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/consumequeue# 消息索引存储路径# storePathIndex=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/index# checkpoint 文件存储路径# storeCheckpoint=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/checkpoint# abort 文件存储路径# abortFile=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/abort# 限制的消息大小maxMessageSize=65536# flushCommitLogLeastPages=4# flushConsumeQueueLeastPages=2# flushCommitLogThoroughInterval=10000# flushConsumeQueueThoroughInterval=60000# Broker 的角色# - ASYNC_MASTER 异步复制Master# - SYNC_MASTER 同步双写Master# - SLAVEbrokerRole=ASYNC_MASTER# 刷盘方式# - ASYNC_FLUSH 异步刷盘# - SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH# 发消息线程池数量# sendMessageThreadPoolNums=128# 拉消息线程池数量# pullMessageThreadPoolNums=128 RocketMQ 控制台访问 http://rmqIP:8080 登入控制台]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列的流派]]></title>
    <url>%2F2013%2F06%2F10%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRocketMQ%2F1.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%B5%81%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[消息队列的流派注：因为之前录制过相关视频，此处就不再单独录制了 什么是 MQMessage Queue（MQ），消息队列中间件。很多人都说：MQ 通过将消息的发送和接收分离来实现应用程序的异步和解偶，这个给人的直觉是——MQ 是异步的，用来解耦的，但是这个只是 MQ 的效果而不是目的。MQ 真正的目的是为了通讯，屏蔽底层复杂的通讯协议，定义了一套应用层的、更加简单的通讯协议。一个分布式系统中两个模块之间通讯要么是 HTTP，要么是自己开发的 TCP，但是这两种协议其实都是原始的协议。HTTP 协议很难实现两端通讯——模块 A 可以调用 B，B 也可以主动调用 A，如果要做到这个两端都要背上 WebServer，而且还不支持长连接（HTTP 2.0 的库根本找不到）。TCP 就更加原始了，粘包、心跳、私有的协议，想一想头皮就发麻。MQ 所要做的就是在这些协议之上构建一个简单的“协议”——生产者/消费者模型。MQ 带给我的“协议”不是具体的通讯协议，而是更高层次通讯模型。它定义了两个对象——发送数据的叫生产者；接收数据的叫消费者， 提供一个 SDK 让我们可以定义自己的生产者和消费者实现消息通讯而无视底层通讯协议 有 Broker 的 MQ这个流派通常有一台服务器作为 Broker，所有的消息都通过它中转。生产者把消息发送给它就结束自己的任务了，Broker 则把消息主动推送给消费者（或者消费者主动轮询） 重 Topickafka、JMS（ActiveMQ）就属于这个流派，生产者会发送 key 和数据到 Broker，由 Broker 比较 key 之后决定给哪个消费者。这种模式是我们最常见的模式，是我们对 MQ 最多的印象。在这种模式下一个 topic 往往是一个比较大的概念，甚至一个系统中就可能只有一个 topic，topic 某种意义上就是 queue，生产者发送 key 相当于说：“hi，把数据放到 key 的队列中” 如上图所示，Broker 定义了三个队列，key1，key2，key3，生产者发送数据的时候会发送 key1 和 data，Broker 在推送数据的时候则推送 data（也可能把 key 带上）。 虽然架构一样但是 kafka 的性能要比 jms 的性能不知道高到多少倍，所以基本这种类型的 MQ 只有 kafka 一种备选方案。如果你需要一条暴力的数据流（在乎性能而非灵活性）那么 kafka 是最好的选择 轻 Topic这种的代表是 RabbitMQ（或者说是 AMQP）。生产者发送 key 和数据，消费者定义订阅的队列，Broker 收到数据之后会通过一定的逻辑计算出 key 对应的队列，然后把数据交给队列 这种模式下解耦了 key 和 queue，在这种架构中 queue 是非常轻量级的（在 RabbitMQ 中它的上限取决于你的内存），消费者关心的只是自己的 queue；生产者不必关心数据最终给谁只要指定 key 就行了，中间的那层映射在 AMQP 中叫 exchange（交换机）。 AMQP 中有四种 exchange Direct exchange：key 就等于 queue Fanout exchange：无视 key，给所有的 queue 都来一份 Topic exchange：key 可以用“宽字符”模糊匹配 queue Headers exchange：无视 key，通过查看消息的头部元数据来决定发给那个 queue（AMQP 头部元数据非常丰富而且可以自定义） 这种结构的架构给通讯带来了很大的灵活性，我们能想到的通讯方式都可以用这四种 exchange 表达出来。如果你需要一个企业数据总线（在乎灵活性）那么 RabbitMQ 绝对的值得一用 无 Broker 的 MQ无 Broker 的 MQ 的代表是 ZeroMQ。该作者非常睿智，他非常敏锐的意识到——MQ 是更高级的 Socket，它是解决通讯问题的。所以 ZeroMQ 被设计成了一个“库”而不是一个中间件，这种实现也可以达到——没有 Broker 的目的 节点之间通讯的消息都是发送到彼此的队列中，每个节点都既是生产者又是消费者。ZeroMQ 做的事情就是封装出一套类似于 Socket 的 API 可以完成发送数据，读取数据 ZeroMQ 其实就是一个跨语言的、重量级的 Actor 模型邮箱库。你可以把自己的程序想象成一个 Actor，ZeroMQ 就是提供邮箱功能的库；ZeroMQ 可以实现同一台机器的 RPC 通讯也可以实现不同机器的 TCP、UDP 通讯，如果你需要一个强大的、灵活、野蛮的通讯能力，别犹豫 ZeroMQ 附：Queue 和 Topic 的区别 Queue： 一个发布者发布消息，下面的接收者按队列顺序接收，比如发布了 10 个消息，两个接收者 A,B 那就是 A,B 总共 会收到 10 条消息，不重复。 Topic： 一个发布者发布消息，有两个接收者 A,B 来订阅，那么发布了 10 条消息，A,B 各收到 10 条消息。 类型 Topic Queue 概要 Publish Subscribe Messaging 发布订阅消息 Point-to-Point 点对点 有无状态 Topic 数据默认不落地，是无状态的。 Queue 数据默认会在 MQ 服务器上以文件形式保存，比如 ActiveMQ 一般保存在 $AMQ_HOME\data\kr-store\data 下面。也可以配置成 DB 存储。 完整性保障 并不保证 Publisher 发布的每条数据，Subscriber 都能接受到。 Queue 保证每条数据都能被 Receiver 接收。 消息是否会丢失 一般来说 Publisher 发布消息到某一个 Topic 时，只有正在监听该 Topic 地址的 Sub 能够接收到消息；如果没有 Sub 在监听，该 Topic 就丢失了。 Sender 发送消息到目标 Queue，Receiver 可以异步接收这个 Queue 上的消息。Queue 上的消息如果暂时没有 Receiver 来取，也不会丢失。 消息发布接收策略 一对多的消息发布接收策略，监听同一个 Topic 地址的多个 Sub 都能收到 Publisher 发送的消息。Sub 接收完通知 MQ 服务器 一对一的消息发布接收策略，一个 Sender 发送的消息，只能有一个 Receiver 接收。Receiver 接收完后，通知 MQ 服务器已接收，MQ 服务器对 Queue 里的消息采取删除或其他操作。]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置 MyBatis Redis 二级缓存]]></title>
    <url>%2F2013%2F06%2F09%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRedis%2F6.Redis%20MyBatis%20%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[配置 MyBatis Redis 二级缓存MyBatis 缓存介绍一级缓存MyBatis 会在表示会话的 SqlSession 对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。 一级缓存是 SqlSession 级别的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个（内存区域）数据结构（HashMap）用于存储缓存数据。不同的 sqlSession 之间的缓存数据区域（HashMap）是互相不影响的。其作用域是同一个 SqlSession，在同一个 sqlSession 中两次执行相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个 sqlSession 结束后该 sqlSession 中的一级缓存也就不存在了。Mybatis 默认开启一级缓存。 二级缓存二级缓存是 mapper 级别的缓存，多个 SqlSession 去操作同一个 Mapper 的 sql 语句，多个 SqlSession 去操作数据库得到数据会存在二级缓存区域，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。其作用域是 mapper 的同一个 namespace，不同的 sqlSession 两次执行相同 namespace下的 sql 语句且向 sql 中传递参数也相同即最终执行相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis 默认没有开启二级缓存需要在 setting 全局参数中配置开启二级缓存。 配置 MyBatis 二级缓存Spring Boot 中开启 MyBatis 二级缓存以 myshop-service-user-provider 项目为例，完整配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# Spring boot applicationspring: application: name: myshop-service-user-provider datasource: druid: url: jdbc:mysql://192.168.10.131:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true driver-class-name: com.mysql.cj.jdbc.Driver redis: lettuce: pool: max-active: 8 max-idle: 8 max-wait: -1ms min-idle: 0 sentinel: master: mymaster nodes: 192.168.10.131:26379, 192.168.10.131:26380, 192.168.10.131:26381server: port: 8501# MyBatis Config propertiesmybatis: configuration: cache-enabled: true type-aliases-package: com.funtl.myshop.commons.domain mapper-locations: classpath:mapper/*.xml# Services Versionsservices: versions: redis: v1: 1.0.0 user: v1: 1.0.0# Dubbo Config propertiesdubbo: ## Base packages to scan Dubbo Component：@com.alibaba.dubbo.config.annotation.Service scan: basePackages: com.funtl.myshop.service.user.provider.api.impl ## ApplicationConfig Bean application: id: myshop-service-user-provider name: myshop-service-user-provider qos-port: 22222 qos-enable: true ## ProtocolConfig Bean protocol: id: dubbo name: dubbo port: 20881 status: server serialization: kryo ## RegistryConfig Bean registry: id: zookeeper address: zookeeper://192.168.10.131:2181?backup=192.168.10.131:2182,192.168.10.131:2183# Enables Dubbo All Endpointsmanagement: endpoint: dubbo: enabled: true dubbo-shutdown: enabled: true dubbo-configs: enabled: true dubbo-services: enabled: true dubbo-references: enabled: true dubbo-properties: enabled: true # Dubbo Health health: dubbo: status: ## StatusChecker Name defaults (default : "memory", "load" ) defaults: memory ## StatusChecker Name extras (default : empty ) extras: load,threadpoollogging: level.com.funtl.myshop.commons.mapper: DEBUG 主要增加了如下配置： MyBaits 二级缓存配置 123mybatis: configuration: cache-enabled: true Redis 配置 1234567891011spring: redis: lettuce: pool: max-active: 8 max-idle: 8 max-wait: -1ms min-idle: 0 sentinel: master: mymaster nodes: 192.168.10.131:26379, 192.168.10.131:26380, 192.168.10.131:26381 实体类实现序列化接口并声明序列号1private static final long serialVersionUID = 8289770415244673535L; 实现 MyBatis Cache 接口，自定义缓存为 Redis为了增加通用性，请在 myshop-commons-mapper 项目中创建一个名为 RedisCache 的工具类，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.funtl.myshop.commons.utils;import com.funtl.myshop.commons.context.ApplicationContextHolder;import org.apache.ibatis.cache.Cache;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * Redis 缓存工具类 * &lt;p&gt;Title: RedisCache&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * * @author Lusifer * @version 1.0.0 * @date 2018/8/13 6:03 */public class RedisCache implements Cache &#123; private static final Logger logger = LoggerFactory.getLogger(RedisCache.class); private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private final String id; // cache instance id private RedisTemplate redisTemplate; private static final long EXPIRE_TIME_IN_MINUTES = 30; // redis过期时间 public RedisCache(String id) &#123; if (id == null) &#123; throw new IllegalArgumentException("Cache instances require an ID"); &#125; this.id = id; &#125; @Override public String getId() &#123; return id; &#125; /** * Put query result to redis * * @param key * @param value */ @Override public void putObject(Object key, Object value) &#123; try &#123; RedisTemplate redisTemplate = getRedisTemplate(); ValueOperations opsForValue = redisTemplate.opsForValue(); opsForValue.set(key, value, EXPIRE_TIME_IN_MINUTES, TimeUnit.MINUTES); logger.debug("Put query result to redis"); &#125; catch (Throwable t) &#123; logger.error("Redis put failed", t); &#125; &#125; /** * Get cached query result from redis * * @param key * @return */ @Override public Object getObject(Object key) &#123; try &#123; RedisTemplate redisTemplate = getRedisTemplate(); ValueOperations opsForValue = redisTemplate.opsForValue(); logger.debug("Get cached query result from redis");// System.out.println("****" + opsForValue.get(key).toString()); return opsForValue.get(key); &#125; catch (Throwable t) &#123; logger.error("Redis get failed, fail over to db", t); return null; &#125; &#125; /** * Remove cached query result from redis * * @param key * @return */ @Override @SuppressWarnings("unchecked") public Object removeObject(Object key) &#123; try &#123; RedisTemplate redisTemplate = getRedisTemplate(); redisTemplate.delete(key); logger.debug("Remove cached query result from redis"); &#125; catch (Throwable t) &#123; logger.error("Redis remove failed", t); &#125; return null; &#125; /** * Clears this cache instance */ @Override public void clear() &#123; RedisTemplate redisTemplate = getRedisTemplate(); redisTemplate.execute((RedisCallback) connection -&gt; &#123; connection.flushDb(); return null; &#125;); logger.debug("Clear all the cached query result from redis"); &#125; /** * This method is not used * * @return */ @Override public int getSize() &#123; return 0; &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return readWriteLock; &#125; private RedisTemplate getRedisTemplate() &#123; if (redisTemplate == null) &#123; redisTemplate = ApplicationContextHolder.getBean("redisTemplate"); &#125; return redisTemplate; &#125;&#125; Mapper 接口中增加注解在 Mapper 接口中增加 @CacheNamespace(implementation = RedisCache.class) 注解，声明需要使用二级缓存 123456789package com.funtl.myshop.commons.mapper;import com.funtl.myshop.commons.domain.TbUser;import com.funtl.myshop.commons.utils.RedisCache;import org.apache.ibatis.annotations.CacheNamespace;import tk.mybatis.mapper.MyMapper;@CacheNamespace(implementation = RedisCache.class)public interface TbUserMapper extends MyMapper&lt;TbUser&gt; &#123;&#125; 附：IDEA 生成序列号的方法 使用 GenerateSerialVersionUID 插件生成，安装完插件后在实现了序列化接口的类中使用快捷键 alt + insert 即可呼出生成菜单 IDEA 提示生成序列号 默认情况下 Intellij IDEA 不会提示继承了 Serializable 接口的类生成 serialVersionUID 的警告。如果需要生成 serialVersionUID，需要手动配置。 1File -&gt; Settings -&gt; Inspections -&gt; Serialization issues -&gt; Serialization class without ‘serialVersionUID’]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 项目集成]]></title>
    <url>%2F2013%2F06%2F08%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRedis%2F5.Redis%20%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[创建缓存服务提供者创建缓存服务接口项目创建一个名为 myshop-service-redis-api 项目，该项目只负责定义接口 POM123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../myshop-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;myshop-service-redis-api&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt;&lt;/project&gt; RedisService12345678910111213141516171819202122232425262728293031package com.funtl.myshop.service.redis.api;public interface RedisService &#123; /** * 设置缓存 * @param key * @param value */ void set(String key, Object value); /** * 设置缓存 * @param key * @param value * @param seconds 缓存有效期 */ void set(String key, Object value, int seconds); /** * 获取缓存 * @param key * @return */ Object get(String key); /** * 删除缓存 * @param key */ void delete(String key);&#125; 创建缓存服务提供者创建一个名为 myshop-service-redis-provider 项目 POM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../myshop-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;myshop-service-redis-provider&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Starter Settings --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Commons Settings --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.javakaffee&lt;/groupId&gt; &lt;artifactId&gt;kryo-serializers&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Projects Settings --&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-commons-dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-service-redis-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.myshop.service.redis.provider.MyShopServiceRedisProviderApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要增加了 org.springframework.boot:spring-boot-starter-data-redis，org.apache.commons:commons-pool2 两个依赖 Application1234567891011121314151617package com.funtl.myshop.service.redis.provider;import com.alibaba.dubbo.container.Main;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.hystrix.EnableHystrix;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;@EnableHystrix@EnableHystrixDashboard@SpringBootApplicationpublic class MyShopServiceRedisProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyShopServiceRedisProviderApplication.class, args); Main.main(args); &#125;&#125; RedisServiceImpl1234567891011121314151617181920212223242526272829303132333435package com.funtl.myshop.service.redis.provider.api.impl;import com.alibaba.dubbo.config.annotation.Service;import com.funtl.myshop.service.redis.api.RedisService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import java.util.concurrent.TimeUnit;@Service(version = "$&#123;services.versions.redis.v1&#125;")public class RedisServiceImpl implements RedisService &#123; @Autowired private RedisTemplate redisTemplate; @Override public void set(String key, Object value) &#123; redisTemplate.opsForValue().set(key, value); &#125; @Override public void set(String key, Object value, int seconds) &#123; redisTemplate.opsForValue().set(key, value, seconds, TimeUnit.SECONDS); &#125; @Override public Object get(String key) &#123; return redisTemplate.opsForValue().get(key); &#125; @Override public void delete(String key) &#123; redisTemplate.delete(key); &#125;&#125; application.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# Spring boot applicationspring: application: name: myshop-service-redis-provider redis: lettuce: pool: max-active: 8 max-idle: 8 max-wait: -1ms min-idle: 0 sentinel: master: mymaster nodes: 192.168.10.131:26379, 192.168.10.131:26380, 192.168.10.131:26381server: port: 8503# Services Versionsservices: versions: redis: v1: 1.0.0# Dubbo Config propertiesdubbo: ## Base packages to scan Dubbo Component：@com.alibaba.dubbo.config.annotation.Service scan: basePackages: com.funtl.myshop.service.redis.provider.api.impl ## ApplicationConfig Bean application: id: myshop-service-redis-provider name: myshop-service-redis-provider qos-port: 22224 qos-enable: true ## ProtocolConfig Bean protocol: id: dubbo name: dubbo port: 20883 status: server serialization: kryo ## RegistryConfig Bean registry: id: zookeeper address: zookeeper://192.168.10.131:2181?backup=192.168.10.131:2182,192.168.10.131:2183# Enables Dubbo All Endpointsmanagement: endpoint: dubbo: enabled: true dubbo-shutdown: enabled: true dubbo-configs: enabled: true dubbo-services: enabled: true dubbo-references: enabled: true dubbo-properties: enabled: true # Dubbo Health health: dubbo: status: ## StatusChecker Name defaults (default : "memory", "load" ) defaults: memory ## StatusChecker Name extras (default : empty ) extras: load,threadpool 缓存服务消费者在需要 Redis 服务的项目中增加 myshop-service-redis-api 依赖，直接远程调用即可]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 命令汇总]]></title>
    <url>%2F2013%2F06%2F07%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRedis%2F5.Redis%20%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Redis 命令汇总参考资料 http://redisdoc.com/ http://redis.io/commands 连接操作相关的命令 ping：测试连接是否存活如果正常会返回 pong echo：打印 select：切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值 quit：关闭连接（connection） auth：简单密码认证 服务端相关命令 time：返回当前服务器时间 client list: 返回所有连接到服务器的客户端信息和统计数据 参见 http://redisdoc.com/server/client_list.html client kill ip:port：关闭地址为 ip:port 的客户端 save：将数据同步保存到磁盘 bgsave：将数据异步保存到磁盘 lastsave：返回上次成功将数据保存到磁盘的Unix时戳 shundown：将数据同步保存到磁盘，然后关闭服务 info：提供服务器的信息和统计 config resetstat：重置 info 命令中的某些统计数据 config get：获取配置文件信息 config set：动态地调整 Redis 服务器的配置(configuration)而无须重启，可以修改的配置参数可以使用命令 CONFIG GET * 来列出 config rewrite：Redis 服务器时所指定的 redis.conf 文件进行改写 monitor：实时转储收到的请求 slaveof：改变复制策略设置 发布订阅相关命令 psubscribe：订阅一个或多个符合给定模式的频道 例如 psubscribe news. tweet. publish：将信息 message 发送到指定的频道 channel 例如 publish msg “good morning” pubsub channels：列出当前的活跃频道 例如 PUBSUB CHANNELS news.i* pubsub numsub：返回给定频道的订阅者数量 例如 PUBSUB NUMSUB news.it news.internet news.sport news.music pubsub numpat：返回客户端订阅的所有模式的数量总和 punsubscribe：指示客户端退订所有给定模式。 subscribe：订阅给定的一个或多个频道的信息。例如 subscribe msg chat_room unsubscribe：指示客户端退订给定的频道。 对 KEY 操作的命令 exists(key)：确认一个 key 是否存在 del(key)：删除一个 key type(key)：返回值的类型 keys(pattern)：返回满足给定 pattern 的所有 key randomkey：随机返回 key 空间的一个 keyrename(oldname, newname)：重命名 key dbsize：返回当前数据库中 key 的数目 expire：设定一个 key 的活动时间（s） ttl：获得一个 key 的活动时间 move(key, dbindex)：移动当前数据库中的 key 到 dbindex 数据库 flushdb：删除当前选择数据库中的所有 key flushall：删除所有数据库中的所有 key 对 String 操作的命令 set(key, value)：给数据库中名称为 key 的 string 赋予值 value get(key)：返回数据库中名称为 key 的 string 的 value getset(key, value)：给名称为 key 的 string 赋予上一次的 value mget(key1, key2,…, key N)：返回库中多个 string 的 value setnx(key, value)：添加 string，名称为 key，值为 value setex(key, time, value)：向库中添加 string，设定过期时间 time mset(key N, value N)：批量设置多个 string 的值 msetnx(key N, value N)：如果所有名称为 key i 的 string 都不存在 incr(key)：名称为 key 的 string 增 1 操作 incrby(key, integer)：名称为 key 的 string 增加 integer decr(key)：名称为 key 的 string 减 1 操作 decrby(key, integer)：名称为 key 的 string 减少 integer append(key, value)：名称为 key 的 string 的值附加 value substr(key, start, end)：返回名称为 key 的 string 的 value 的子串 对 List 操作的命令 rpush(key, value)：在名称为 key 的 list 尾添加一个值为 value 的元素 lpush(key, value)：在名称为 key 的 list 头添加一个值为 value 的元素 llen(key)：返回名称为 key 的 list 的长度 lrange(key, start, end)：返回名称为 key 的 list 中 start 至 end 之间的元素 ltrim(key, start, end)：截取名称为 key 的 list lindex(key, index)：返回名称为 key 的 list 中 index 位置的元素 lset(key, index, value)：给名称为 key 的 list 中 index 位置的元素赋值 lrem(key, count, value)：删除 count 个 key 的 list 中值为 value 的元素 lpop(key)：返回并删除名称为 key 的 list 中的首元素 rpop(key)：返回并删除名称为 key 的 list 中的尾元素 blpop(key1, key2,… key N, timeout)：lpop 命令的 block 版本。 brpop(key1, key2,… key N, timeout)：rpop 的 block 版本。 rpoplpush(srckey, dstkey)：返回并删除名称为 srckey 的 list 的尾元素，并将该元素添加到名称为 dstkey 的 list 的头部 对 Set 操作的命令 sadd(key, member)：向名称为 key 的 set 中添加元素 member srem(key, member) ：删除名称为 key 的 set 中的元素 member spop(key) ：随机返回并删除名称为 key 的 set 中一个元素 smove(srckey, dstkey, member) ：移到集合元素 scard(key) ：返回名称为 key 的 set 的基数 sismember(key, member) ：member 是否是名称为 key 的 set 的元素 sinter(key1, key2,…key N) ：求交集 sinterstore(dstkey, (keys)) ：求交集并将交集保存到 dstkey 的集合 sunion(key1, (keys)) ：求并集 sunionstore(dstkey, (keys)) ：求并集并将并集保存到 dstkey 的集合 sdiff(key1, (keys)) ：求差集 sdiffstore(dstkey, (keys)) ：求差集并将差集保存到 dstkey 的集合 smembers(key) ：返回名称为 key 的 set 的所有元素 srandmember(key) ：随机返回名称为 key 的 set 的一个元素 对 Hash 操作的命令 hset(key, field, value)：向名称为 key 的 hash 中添加元素 field hget(key, field)：返回名称为 key 的 hash 中 field 对应的 value hmget(key, (fields))：返回名称为 key 的 hash 中 field i 对应的 value hmset(key, (fields))：向名称为 key 的 hash 中添加元素 field hincrby(key, field, integer)：将名称为 key 的 hash 中 field 的 value 增加 integer hexists(key, field)：名称为 key 的 hash 中是否存在键为 field 的域 hdel(key, field)：删除名称为 key 的 hash 中键为 field 的域 hlen(key)：返回名称为 key 的 hash 中元素个数 hkeys(key)：返回名称为 key 的 hash 中所有键 hvals(key)：返回名称为 key 的 hash 中所有键对应的 value hgetall(key)：返回名称为 key 的 hash 中所有的键（field）及其对应的 value Redis Sentinel ping ：返回 pong sentinel masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。 sentinel slaves：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。 sentinel get-master-addr-by-name：返回给定名字的主服务器的 IP 地址和端口号。如果这个主服务器正在执行故障转移操作，或者针对这个主服务器的故障转移操作已经完成，那么这个命令返回新的主服务器的 IP 地址和端口号。 sentinel reset：重置所有名字和给定模式 pattern 相匹配的主服务器。pattern 参数是一个 Glob 风格的模式 重置操作清楚主服务器目前的所有状态，包括正在执行中的故障转移，并移除目前已经发现和关联的，主服务器的所有从服务器和 Sentinel 。 sentinel failover：当主服务器失效时，在不询问其他 Sentinel 意见的情况下，强制开始一次自动故障迁移（不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis Sentinel 集群部署]]></title>
    <url>%2F2013%2F06%2F06%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRedis%2F4.Redis%20Sentinel%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Redis Sentinel 集群部署概述Redis 集群可以在一组 redis 节点之间实现高可用性和 sharding。在集群中会有 1 个 master 和多个 slave 节点。当 master 节点失效时，应选举出一个 slave 节点作为新的 master。然而 Redis 本身(包括它的很多客户端)没有实现自动故障发现并进行主备切换的能力，需要外部的监控方案来实现自动故障恢复。 Redis Sentinel 是官方推荐的高可用性解决方案。它是 Redis 集群的监控管理工具，可以提供节点监控、通知、自动故障恢复和客户端配置发现服务。 Redis Sentinel 核心配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204# Example sentinel.conf# *** IMPORTANT ***## By default Sentinel will not be reachable from interfaces different than# localhost, either use the &apos;bind&apos; directive to bind to a list of network# interfaces, or disable protected mode with &quot;protected-mode no&quot; by# adding it to this configuration file.## Before doing that MAKE SURE the instance is protected from the outside# world via firewalling or other means.## For example you may use one of the following:## bind 127.0.0.1 192.168.1.1## protected-mode no# port &lt;sentinel-port&gt;# The port that this sentinel instance will run onport 26379# sentinel announce-ip &lt;ip&gt;# sentinel announce-port &lt;port&gt;## The above two configuration directives are useful in environments where,# because of NAT, Sentinel is reachable from outside via a non-local address.## When announce-ip is provided, the Sentinel will claim the specified IP address# in HELLO messages used to gossip its presence, instead of auto-detecting the# local address as it usually does.## Similarly when announce-port is provided and is valid and non-zero, Sentinel# will announce the specified TCP port.## The two options don&apos;t need to be used together, if only announce-ip is# provided, the Sentinel will announce the specified IP and the server port# as specified by the &quot;port&quot; option. If only announce-port is provided, the# Sentinel will announce the auto-detected local IP and the specified port.## Example:## sentinel announce-ip 1.2.3.4# dir &lt;working-directory&gt;# Every long running process should have a well-defined working directory.# For Redis Sentinel to chdir to /tmp at startup is the simplest thing# for the process to don&apos;t interfere with administrative tasks such as# unmounting filesystems.dir /tmp# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;## Tells Sentinel to monitor this master, and to consider it in O_DOWN# (Objectively Down) state only if at least &lt;quorum&gt; sentinels agree.## Note that whatever is the ODOWN quorum, a Sentinel will require to# be elected by the majority of the known Sentinels in order to# start a failover, so no failover can be performed in minority.## Slaves are auto-discovered, so you don&apos;t need to specify slaves in# any way. Sentinel itself will rewrite this configuration file adding# the slaves using additional configuration options.# Also note that the configuration file is rewritten when a# slave is promoted to master.## Note: master name should not include special characters or spaces.# The valid charset is A-z 0-9 and the three characters &quot;.-_&quot;.sentinel monitor mymaster 127.0.0.1 6379 2# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;## Set the password to use to authenticate with the master and slaves.# Useful if there is a password set in the Redis instances to monitor.## Note that the master password is also used for slaves, so it is not# possible to set a different password in masters and slaves instances# if you want to be able to monitor these instances with Sentinel.## However you can have Redis instances without the authentication enabled# mixed with Redis instances requiring the authentication (as long as the# password set is the same for all the instances requiring the password) as# the AUTH command will have no effect in Redis instances with authentication# switched off.## Example:## sentinel auth-pass mymaster MySUPER--secret-0123passw0rd# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;## Number of milliseconds the master (or any attached slave or sentinel) should# be unreachable (as in, not acceptable reply to PING, continuously, for the# specified period) in order to consider it in S_DOWN state (Subjectively# Down).## Default is 30 seconds.sentinel down-after-milliseconds mymaster 30000# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;## How many slaves we can reconfigure to point to the new slave simultaneously# during the failover. Use a low number if you use the slaves to serve query# to avoid that all the slaves will be unreachable at about the same# time while performing the synchronization with the master.sentinel parallel-syncs mymaster 1# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;## Specifies the failover timeout in milliseconds. It is used in many ways:## - The time needed to re-start a failover after a previous failover was# already tried against the same master by a given Sentinel, is two# times the failover timeout.## - The time needed for a slave replicating to a wrong master according# to a Sentinel current configuration, to be forced to replicate# with the right master, is exactly the failover timeout (counting since# the moment a Sentinel detected the misconfiguration).## - The time needed to cancel a failover that is already in progress but# did not produced any configuration change (SLAVEOF NO ONE yet not# acknowledged by the promoted slave).## - The maximum time a failover in progress waits for all the slaves to be# reconfigured as slaves of the new master. However even after this time# the slaves will be reconfigured by the Sentinels anyway, but not with# the exact parallel-syncs progression as specified.## Default is 3 minutes.sentinel failover-timeout mymaster 180000# SCRIPTS EXECUTION## sentinel notification-script and sentinel reconfig-script are used in order# to configure scripts that are called to notify the system administrator# or to reconfigure clients after a failover. The scripts are executed# with the following rules for error handling:## If script exits with &quot;1&quot; the execution is retried later (up to a maximum# number of times currently set to 10).## If script exits with &quot;2&quot; (or an higher value) the script execution is# not retried.## If script terminates because it receives a signal the behavior is the same# as exit code 1.## A script has a maximum running time of 60 seconds. After this limit is# reached the script is terminated with a SIGKILL and the execution retried.# NOTIFICATION SCRIPT## sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;# # Call the specified notification script for any sentinel event that is# generated in the WARNING level (for instance -sdown, -odown, and so forth).# This script should notify the system administrator via email, SMS, or any# other messaging system, that there is something wrong with the monitored# Redis systems.## The script is called with just two arguments: the first is the event type# and the second the event description.## The script must exist and be executable in order for sentinel to start if# this option is provided.## Example:## sentinel notification-script mymaster /var/redis/notify.sh# CLIENTS RECONFIGURATION SCRIPT## sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;## When the master changed because of a failover a script can be called in# order to perform application-specific tasks to notify the clients that the# configuration has changed and the master is at a different address.# # The following arguments are passed to the script:## &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;## &lt;state&gt; is currently always &quot;failover&quot;# &lt;role&gt; is either &quot;leader&quot; or &quot;observer&quot;# # The arguments from-ip, from-port, to-ip, to-port are used to communicate# the old address of the master and the new address of the elected slave# (now a master).## This script should be resistant to multiple invocations.## Example:## sentinel client-reconfig-script mymaster /var/redis/reconfig.sh# SECURITY## By default SENTINEL SET will not be able to change the notification-script# and client-reconfig-script at runtime. This avoids a trivial security issue# where clients can set the script to anything and trigger a failover in order# to get the program executed.sentinel deny-scripts-reconfig yes 搭建 Redis 集群搭建一主两从环境，docker-compose.yml 配置如下： 123456789101112131415161718192021version: '3.1'services: master: image: redis container_name: redis-master ports: - 6379:6379 slave1: image: redis container_name: redis-slave-1 ports: - 6380:6379 command: redis-server --slaveof redis-master 6379 slave2: image: redis container_name: redis-slave-2 ports: - 6381:6379 command: redis-server --slaveof redis-master 6379 搭建 Sentinel 集群我们至少需要创建三个 Sentinel 服务，docker-compose.yml 配置如下： 12345678910111213141516171819202122232425262728version: '3.1'services: sentinel1: image: redis container_name: redis-sentinel-1 ports: - 26379:26379 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - ./conf/sentinel1.conf:/usr/local/etc/redis/sentinel.conf sentinel2: image: redis container_name: redis-sentinel-2 ports: - 26380:26379 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - ./conf/sentinel2.conf:/usr/local/etc/redis/sentinel.conf sentinel3: image: redis container_name: redis-sentinel-3 ports: - 26381:26379 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - ./conf/sentinel3.conf:/usr/local/etc/redis/sentinel.conf 修改 Sentinel 配置文件需要三份 sentinel.conf 配置文件，分别为 sentinel1.conf，sentinel2.conf，sentinel3.conf，配置文件内容相同 12345678port 26379dir /tmp# 自定义集群名，其中 127.0.0.1 为 redis-master 的 ip，6379 为 redis-master 的端口，2 为最小投票数（因为有 3 台 Sentinel 所以可以设置成 2）sentinel monitor mymaster 127.0.0.1 6379 2sentinel down-after-milliseconds mymaster 30000sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 180000sentinel deny-scripts-reconfig yes 查看集群是否生效进入 Sentinel 容器，使用 Sentinel API 查看监控情况： 1234docker exec -it redis-sentinel-1 /bin/bashredis-cli -p 26379sentinel master mymastersentinel slaves mymaster]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis HA 方案]]></title>
    <url>%2F2013%2F06%2F05%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRedis%2F3.Redis%20HA%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Redis HA 方案概述HA(High Available，高可用性群集)机集群系统简称，是保证业务连续性的有效解决方案，一般有两个或两个以上的节点，且分为活动节点及备用节点。通常把正在执 行业务的称为活动节点，而作为活动节点的一个备份的则称为备用节点。当活动节点出现问题，导致正在运行的业务（任务）不能正常运行时，备用节点此时就会侦测到，并立即接续活动节点来执行业务。从而实现业务的不中断或短暂中断。 Redis 一般以主/从方式部署（这里讨论的应用从实例主要用于备份，主实例提供读写）该方式要实现 HA 主要有如下几种方案： keepalived： 通过 keepalived 的虚拟 IP，提供主从的统一访问，在主出现问题时， 通过 keepalived 运行脚本将从提升为主，待主恢复后先同步后自动变为主，该方案的好处是主从切换后，应用程序不需要知道(因为访问的虚拟 IP 不变)，坏处是引入 keepalived 增加部署复杂性，在有些情况下会导致数据丢失 zookeeper： 通过 zookeeper 来监控主从实例， 维护最新有效的 IP， 应用通过 zookeeper 取得 IP，对 Redis 进行访问，该方案需要编写大量的监控代码 sentinel： 通过 Sentinel 监控主从实例，自动进行故障恢复，该方案有个缺陷：因为主从实例地址( IP &amp; PORT )是不同的，当故障发生进行主从切换后，应用程序无法知道新地址，故在 Jedis2.2.2 中新增了对 Sentinel 的支持，应用通过 redis.clients.jedis.JedisSentinelPool.getResource() 取得的 Jedis 实例会及时更新到新的主实例地址 注意： sentinel 是解决 HA 问题的，cluster 是解决主从复制问题的，不重复，并且经常一起用]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 持久化]]></title>
    <url>%2F2013%2F06%2F04%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRedis%2F2.Redis%20%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Redis 持久化概述Redis作为缓存服务器，数据存储在内存中，基于内存物理特性，内存数据会存在断电丢失的风险，Redis提供了俩种持久化方案，RDB快照持久化和AOF追加文件持久化 持久化方案RDB快照持久化RDB持久化方式是通过快照snapshotting完成的，当符合一定条件时，Redis会自动将内存中所有数据以二进制方式生成一份副本并存储在硬盘上。当Redis重启时，并且AOF持久化未开启时，Redis会读取RDB持久化生成的二进制文件(默认名称dump.rdb，可通过设置dbfilename进行数据恢复，对于持久化信息可以用过命令info Persistence查看。 RDB快照触发条件RDB生成快照可自动促发，也可以使用命令手动触发，以下是Redis触发执行快照条件，后续会对每个条件详细说明： 客户端执行命令save和bgsave会生成快照 根据配置文件save m n规则进行自动快照 PS：在指定的m秒内，Redis中有n个键发生改变 主从复制时，从库全量复制同步主库数据，此时主库会执行bgsave命令进行快照 客户端执行数据库清空命令FLUSHALL时候，触发快照 客户端执行shutdown关闭Redis时，触发快照 RDB持久化配置 123456789101112131415161718192021save m n#配置快照(rdb)促发规则，格式：save &lt;seconds&gt; &lt;changes&gt;#save 900 1 900秒内至少有1个key被改变则做一次快照#save 300 10 300秒内至少有300个key被改变则做一次快照#save 60 10000 60秒内至少有10000个key被改变则做一次快照#关闭该规则使用save &quot;&quot;dbfilename dump.rdb#rdb持久化存储数据库文件名，默认为dump.rdbstop-write-on-bgsave-error yes #yes代表当使用bgsave命令持久化出错时候停止写RDB快照文件,no表明忽略错误继续写文件。rdbchecksum yes#在写入文件和读取文件时是否开启rdb文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。dir &quot;/data/`Redis`&quot;#数据文件存放目录，rdb快照文件和aof文件都会存放至该目录，请确保有写权限rdbcompression yes#是否开启RDB文件压缩，该功能可以节约磁盘空间 AOF追加文件持久化当Redis存储非临时数据时，为了降低Redis故障而引起的数据丢失，Redis提供了AOF(Append Only File)持久化，从单词意思讲，将命令追加到文件。AOF可以将Redis执行的每一条写命令追加到磁盘文件(appendonly.aof)中,在Redis启动时候优先选择从AOF文件恢复数据。由于每一次的写操作，Redis都会记录到文件中，所以开启AOF持久化会对性能有一定的影响，但是大部分情况下这个影响是可以接受的，我们可以使用读写速率高的硬盘提高AOF性能。与RDB持久化相比，AOF持久化数据丢失更少，其消耗内存更少(RDB方式执行bgsave会有内存拷贝)。 开启AOF默认情况下，Redis是关闭了AOF持久化，开启AOF通过配置appendonly为yes开启，我们修改配置文件或者在命令行直接使用config set修改，在用config rewrite同步到配置文件。通过客户端修改好处是不用重启Redis，AOF持久化直接生效。 AOF持久化过程Redis`AOF`持久化过程可分为以下阶段： 1.追加写入 Redis将每一条写命令以Redis通讯协议添加至缓冲区aof_buf,这样的好处在于在大量写请求情况下，采用缓冲区暂存一部分命令随后根据策略一次性写入磁盘，这样可以减少磁盘的I/O次数，提高性能。 2.同步命令到硬盘 当写命令写入aof_buf缓冲区后，Redis会将缓冲区的命令写入到文件，Redis提供了三种同步策略，由配置参数appendfsync决定，下面是每个策略所对应的含义： no：不使用fsync方法同步，而是交给操作系统write函数去执行同步操作，在linux操作系统中大约每30秒刷一次缓冲。这种情况下，缓冲区数据同步不可控，并且在大量的写操作下，aof_buf缓冲区会堆积会越来越严重，一旦Redis出现故障，数据丢失严重。 always：表示每次有写操作都调用fsync方法强制内核将数据写入到AOF文件。这种情况下由于每次写命令都写到了文件中, 虽然数据比较安全，但是因为每次写操作都会同步到AOF文件中，所以在性能上会有影响，同时由于频繁的IO操作，硬盘的使用寿命会降低。 everysec：数据将使用调用操作系统write写入文件，并使用fsync每秒一次从内核刷新到磁盘。 这是折中的方案，兼顾性能和数据安全，所以Redis默认推荐使用该配置。 3.文件重写(bgrewriteaof) 当开启的AOF时，随着时间推移，AOF文件会越来越大,当然Redis也对AOF文件进行了优化，即触发AOF文件重写条件（后续会说明）时候，Redis将使用bgrewriteaof对AOF文件进行重写。这样的好处在于减少AOF文件大小，同时有利于数据的恢复。 为什么重写？比如先后执行了set foo bar1; set foo bar2; set foo bar3 此时AOF文件会记录三条命令，这显然不合理，因为文件中应只保留set foo bar3这个最后设置的值，前面的set命令都是多余的，下面是一些重写时候策略： 重复或无效的命令不写入文件 过期的数据不再写入文件 多条命令合并写入（当多个命令能合并一条命令时候会对其优化合并作为一个命令写入，例如RPUSH list1 a RPUSH list1 b 合并为RPUSH list1 a b ） 重写触发条件AOF文件触发条件可分为手动触发和自动触发： 手动触发：客户端执行bgrewriteaof命令。 自动触发：自动触发通过以下两个配置协作生效： auto-aof-rewrite-min-size: AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写,4.0默认配置64mb。 auto-aof-rewrite-percentage：当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。 Redis开启在AOF功能开启的情况下，会维持以下三个变量 记录当前AOF文件大小的变量aof_current_size。 记录最后一次AOF重写之后，AOF文件大小的变量aof_rewrite_base_size。 增长百分比变量aof_rewrite_perc。 每次当serverCron（服务器周期性操作函数）函数执行时，它会检查以下条件是否全部满足，如果全部满足的话，就触发自动的AOF重写操作： 没有BGSAVE命令（RDB持久化）/AOF持久化在执行； 没有BGREWRITEAOF在进行； 当前AOF文件大小要大于server.aof_rewrite_min_size的值； 当前AOF文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比（auto-aof-rewrite-percentage参数） AOF实现本质AOF实现本质是基于Redis通讯协议，将命令以纯文本的方式写入到文件中。 Redis协议： 首先Redis是以行来划分，每行以\r\n行结束。每一行都有一个消息头，消息头共分为5种分别如下: (+) 表示一个正确的状态信息，具体信息是当前行+后面的字符。 (-) 表示一个错误信息，具体信息是当前行－后面的字符。 () 表示消息体总共有多少行，不包括当前行,后面是具体的行数。 ($) 表示下一行数据长度，不包括换行符长度\r\n,$后面则是对应的长度的数据。 (:) 表示返回一个数值，：后面是相应的数字节符。 数据恢复之前已经提到当AOF开启时候，Redis数据恢复优先选用AOF进行数据恢复，以下使用停止Redis来模拟Redis故障,然后在重写启动进行恢复。 AOF配置参数123456789101112131415161718192021222324auto-aof-rewrite-min-size 64mb#AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写,4.0默认配置64mb。auto-aof-rewrite-percentage 100#当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。appendfsync everysec#no：不使用fsync方法同步，而是交给操作系统write函数去执行同步操作，在linux操作系统中大约每30秒刷一次缓冲。这种情况下，缓冲区数据同步不可控，并且在大量的写操作下，aof_buf缓冲区会堆积会越来越严重，一旦redis出现故障，数据#always：表示每次有写操作都调用fsync方法强制内核将数据写入到`AOF`文件。这种情况下由于每次写命令都写到了文件中, 虽然数据比较安全，但是因为每次写操作都会同步到AOF文件中，所以在性能上会有影响，同时由于频繁的IO操作，硬盘的使用寿命会降低。#everysec：数据将使用调用操作系统write写入文件，并使用fsync每秒一次从内核刷新到磁盘。 这是折中的方案，兼顾性能和数据安全，所以redis默认推荐使用该配置。aof-load-truncated yes#当redis突然运行崩溃时，会出现aof文件被截断的情况，Redis可以在发生这种情况时退出并加载错误，以下选项控制此行为。#如果aof-load-truncated设置为yes，则加载截断的AOF文件，Redis服务器启动发出日志以通知用户该事件。#如果该选项设置为no，则服务将中止并显示错误并停止启动。当该选项设置为no时，用户需要在重启之前使用“redis-check-aof”实用程序修复AOF文件在进行启动。appendonly no #yes开启AOF，no关闭AOFappendfilename appendonly.aof#指定AOF文件名，4.0无法通过config set 设置，只能通过修改配置文件设置。dir /etc/redis#RDB文件和AOF文件存放目录 混合持久化Redis4.0相对与3.X版本其中一个比较大的变化是4.0添加了新的混合持久化方式。前面已经详细介绍了持久化以及RDB持久化，这里介绍的混合持久化就是同时结合RDB持久化以及AOF持久化混合写入AOF文件。这样做的好处是可以结合 RDB和 AOF的优点, 快速加载同时避免丢失过多的数据，缺点是 AOF里面的 RDB部分就是压缩格式不再是 AOF格式，可读性差。 开启混合持久化4.0版本的混合持久化默认关闭的，通过aof-use-rdb-preamble配置参数控制，yes则表示开启，no表示禁用，默认是禁用的，可通过config set修改。 混合持久化过程了解了AOF持久化过程和RDB持久化过程以后，混合持久化过程就相对简单了。 混合持久化同样也是通过bgrewriteaof完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据 优缺点RDB优点： RDB是一个非常紧凑（compact）的文件，体积小，因此在传输速度上比较快，因此适合灾难恢复。 RDB可以最大化 Redis 的性能：父进程在保存 RDB文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。 RDB在恢复大数据集时的速度比 AOF 的恢复速度要快。 缺点： RDB是一个快照过程，无法完整的保存所以数据，尤其在数据量比较大时候，一旦出现故障丢失的数据将更多。 当Redis中数据集比较大时候，RDB由于RDB方式需要对数据进行完成拷贝并生成快照文件，fork的子进程会耗CPU，并且数据越大，RDB快照生成会越耗时。 RDB文件是特定的格式，阅读性差，由于格式固定，可能存在不兼容情况。 AOF 优点： 数据更完整，秒级数据丢失(取决于设置fsync策略)。 兼容性较高，由于是基于Redis通讯协议而形成的命令追加方式，无论何种版本的redis都兼容，再者aof文件是明文的，可阅读性较好。 缺点： 数据文件体积较大,即使有重写机制，但是在相同的数据集情况下，AOF文件通常比RDB文件大。 相对RDB方式，AOF速度慢于RDB，并且在数据量大时候，恢复速度AOF速度也是慢于RDB。 由于频繁地将命令同步到文件中，AOF持久化对性能的影响相对RDB较大，但是对于我们来说是可以接受的。 混合持久化优点： 混合持久化结合了RDB持久化 和 AOF 持久化的优点, 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。 缺点： 兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该aof文件，同时由于前部分是RDB格式，阅读性较差]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 简介]]></title>
    <url>%2F2013%2F06%2F03%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay75%20Redis%20RocketMQ%2FRedis%2F1.Redis%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Redis 简介什么是 RedisRedis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止 Redis 支持的键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 Redis 的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 分布式集群架构中的 session 分离 聊天室的在线好友列表 任务队列（秒杀、抢购、12306 等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒）]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 解决跨域问题]]></title>
    <url>%2F2013%2F06%2F02%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay74%20Nginx%2FNginx%2F5.Nginx%20%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Nginx 解决跨域问题概述在浏览器端进行 Ajax 请求时会出现跨域问题，那么什么是跨域，如何解决跨域呢？先看浏览器端出现跨域问题的现象，如下图所示 什么是跨域问题？跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。 什么是同源？所谓同源是指，域名，协议，端口均相同 http://www.funtl.com –&gt; http://admin.funtl.com 跨域 http://www.funtl.com –&gt; http://www.funtl.com 非跨域 http://www.funtl.com –&gt; http://www.funtl.com:8080 跨域 http://www.funtl.com –&gt; https://www.funtl.com 跨域 如何解决跨域问题？使用 CORS（跨资源共享）解决跨域问题CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信（在 header 中设置：Access-Control-Allow-Origin） 使用 JSONP 解决跨域问题JSONP（JSON with Padding）是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与 server2.example.com 的服务器沟通，而 HTML 的 &lt;script&gt; 元素是一个例外。利用 &lt;script&gt; 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的 JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析（需要目标服务器配合一个 callback 函数）。 CORS 与 JSONP 的比较CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。 JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。 使用 Nginx 反向代理解决跨域问题以上跨域问题解决方案都需要服务器支持，当服务器无法设置 header 或提供 callback 时我们就可以采用 Nginx 反向代理的方式解决跨域问题。 以下为文件上传的跨域配置方案： 1234567891011121314151617181920212223242526272829303132333435user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name upload.myshop.com; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range'; location / &#123; proxy_pass http://192.168.0.104:8888; if ($request_method = 'OPTIONS') &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,PATCH,OPTIONS; # 解决假请求问题，如果是简单请求则没有这个问题，但这里是上传文件，首次请求为 OPTIONS 方式，实际请求为 POST 方式 # Provisional headers are shown. # Request header field Cache-Control is not allowed by Access-Control-Allow-Headers in preflight response. add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range; return 200; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 负载均衡]]></title>
    <url>%2F2013%2F06%2F01%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay74%20Nginx%2FNginx%2F4.Nginx%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[Nginx 负载均衡什么是负载均衡负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡，英文名称为 Load Balance，其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 Nginx 实现负载均衡 nginx 作为负载均衡服务器，用户请求先到达 nginx，再由 nginx 根据负载配置将请求转发至 tomcat 服务器 nginx 负载均衡服务器：192.168.75.145:80 tomcat1 服务器：192.168.75.145:9090 tomcat2 服务器：192.168.75.145:9091 Nginx 配置负载均衡修改 /usr/local/docker/nginx/conf 目录下的 nginx.conf 配置文件： 1234567891011121314151617181920212223242526272829user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream myapp1 &#123; server 192.168.75.145:9090 weight=10; server 192.168.75.145:9091 weight=10; &#125; server &#123; listen 80; server_name nginx.funtl.com; location / &#123; proxy_pass http://myapp1; index index.jsp index.html index.htm; &#125; &#125;&#125; 相关配置说明1234567# 定义负载均衡设备的 Ip及设备状态 upstream myServer &#123; server 127.0.0.1:9090 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6060; server 127.0.0.1:7070 backup;&#125; 在需要使用负载的 Server 节点下添加 1proxy_pass http://myServer; upstream：每个设备的状态: down：表示当前的 server 暂时不参与负载 weight：默认为 1 weight 越大，负载的权重就越大。 max_fails：允许请求失败的次数默认为 1 当超过最大次数时，返回 proxy_next_upstream 模块定义的错误 fail_timeout:max_fails 次失败后，暂停的时间。 backup：其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器。所以这台机器压力会最轻]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 反向代理]]></title>
    <url>%2F2013%2F05%2F31%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay74%20Nginx%2FNginx%2F3.Nginx%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Nginx 反向代理什么是代理服务器？代理服务器，客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据，存放在代理服务器的硬盘中，再发送给客户机。 为什么要使用代理服务器？提高访问速度由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门站点能明显提高请求速度。 防火墙作用由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可在代理服务器上设限，过滤某些不安全信息。 通过代理服务器访问不能访问的目标站点互联网上有许多开放的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，虽然不能出国，但也可直接访问外网。 什么是正向代理？正向代理，架设在客户机与目标主机之间，只用于代理内部网络对 Internet 的连接请求，客户机必须指定代理服务器,并将本来要直接发送到 Web 服务器上的 Http 请求发送到代理服务器中。 什么是反向代理？反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器与目标主机一起对外表现为一个服务器。 反向代理有哪些主要应用？现在许多大型 web 网站都用到反向代理。除了可以防止外网对内网服务器的恶性攻击、缓存以减少服务器的压力和访问安全控制之外，还可以进行负载均衡，将用户请求分配给多个服务器。 使用 Nginx 反向代理 Tomcat需求 两个 tomcat 服务通过 nginx 反向代理 nginx 服务器：192.168.75.145:80 tomcat1 服务器：192.168.75.145:9090 tomcat2 服务器：192.168.75.145:9091 启动 Tomcat 容器启动两个 Tomcat 容器，映射端口为 9090 和 9091，docker-compose.yml 如下： 12345678910111213version: &apos;3&apos;services: tomcat1: image: tomcat container_name: tomcat1 ports: - 9090:8080 tomcat2: image: tomcat container_name: tomcat2 ports: - 9091:8080 配置 Nginx 反向代理修改 /usr/local/docker/nginx/conf 目录下的 nginx.conf 配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置一个代理即 tomcat1 服务器 upstream tomcatServer1 &#123; server 192.168.75.145:9090; &#125; # 配置一个代理即 tomcat2 服务器 upstream tomcatServer2 &#123; server 192.168.75.145:9091; &#125; # 配置一个虚拟主机 server &#123; listen 80; server_name admin.service.itoken.funtl.com; location / &#123; # 域名 admin.service.itoken.funtl.com 的请求全部转发到 tomcat_server1 即 tomcat1 服务上 proxy_pass http://tomcatServer1; # 欢迎页面，按照从左到右的顺序查找页面 index index.jsp index.html index.htm; &#125; &#125; server &#123; listen 80; server_name admin.web.itoken.funtl.com; location / &#123; # 域名 admin.web.itoken.funtl.com 的请求全部转发到 tomcat_server2 即 tomcat2 服务上 proxy_pass http://tomcatServer2; index index.jsp index.html index.htm; &#125; &#125;&#125; 注意：新版 Nginx 的 upstream 配置中的名称不可以有下划线(“_”)，否则会报 400 错误]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 虚拟主机]]></title>
    <url>%2F2013%2F05%2F30%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay74%20Nginx%2FNginx%2F2.Nginx%20%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Nginx 虚拟主机概述什么是虚拟主机？虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的。 通过 Nginx 可以实现虚拟主机的配置，Nginx 支持三种类型的虚拟主机配置 基于 IP 的虚拟主机 基于域名的虚拟主机 基于端口的虚拟主机 Nginx 配置文件的结构12345678910111213141516# ...events &#123; # ...&#125;http &#123; # ... server&#123; # ... &#125; # ... server&#123; # ... &#125;&#125; 注： 每个 server 就是一个虚拟主机 基于端口的虚拟主机配置需求 Nginx 对外提供 80 和 8080 两个端口监听服务 请求 80 端口则请求 html80 目录下的 html 请求 8080 端口则请求 html8080 目录下的 html 创建目录及文件在 /usr/local/docker/nginx/wwwroot 目录下创建 html80 和 html8080 两个目录，并分辨创建两个 index.html 文件 配置虚拟主机修改 /usr/local/docker/nginx/conf 目录下的 nginx.conf 配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 启动进程,通常设置成和 CPU 的数量相等worker_processes 1;events &#123; # epoll 是多路复用 IO(I/O Multiplexing) 中的一种方式 # 但是仅用于 linux2.6 以上内核,可以大大提高 nginx 的性能 use epoll; # 单个后台 worker process 进程的最大并发链接数 worker_connections 1024;&#125;http &#123; # 设定 mime 类型,类型由 mime.type 文件定义 include mime.types; default_type application/octet-stream; # sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， # 必须设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的 uptime. sendfile on; # 连接超时时间 keepalive_timeout 65; # 设定请求缓冲 client_header_buffer_size 2k; # 配置虚拟主机 192.168.75.145 server &#123; # 监听的ip和端口，配置 192.168.75.145:80 listen 80; # 虚拟主机名称这里配置ip地址 server_name 192.168.75.145; # 所有的请求都以 / 开始，所有的请求都可以匹配此 location location / &#123; # 使用 root 指令指定虚拟主机目录即网页存放目录 # 比如访问 http://ip/index.html 将找到 /usr/local/docker/nginx/wwwroot/html80/index.html # 比如访问 http://ip/item/index.html 将找到 /usr/local/docker/nginx/wwwroot/html80/item/index.html root /usr/share/nginx/wwwroot/html80; # 指定欢迎页面，按从左到右顺序查找 index index.html index.htm; &#125; &#125; # 配置虚拟主机 192.168.75.245 server &#123; listen 8080; server_name 192.168.75.145; location / &#123; root /usr/share/nginx/wwwroot/html8080; index index.html index.htm; &#125; &#125;&#125; 基于域名的虚拟主机配置需求 两个域名指向同一台 Nginx 服务器，用户访问不同的域名显示不同的网页内容 两个域名是 admin.service.itoken.funtl.com 和 admin.web.itoken.funtl.com Nginx 服务器使用虚拟机 192.168.75.145 配置 Windows Hosts 文件 通过 host 文件指定 admin.service.itoken.funtl.com 和 admin.web.itoken.funtl.com 对应 192.168.75.145 虚拟机： 修改 window 的 hosts 文件：（C:\Windows\System32\drivers\etc） 12192.168.75.145 admin.service.itoken.funtl.com192.168.75.145 admin.web.itoken.funtl.com 创建目录及文件在 /usr/local/docker/nginx/wwwroot 目录下创建 htmlservice 和 htmlweb 两个目录，并分别创建两个 index.html 文件 配置虚拟主机12345678910111213141516171819202122232425262728293031323334user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name admin.service.itoken.funtl.com; location / &#123; root /usr/share/nginx/wwwroot/htmlservice; index index.html index.htm; &#125; &#125; server &#123; listen 80; server_name admin.web.itoken.funtl.com; location / &#123; root /usr/share/nginx/wwwroot/htmlweb; index index.html index.htm; &#125; &#125;&#125;]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 简介]]></title>
    <url>%2F2013%2F05%2F29%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay74%20Nginx%2FNginx%2F1.Nginx%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[什么是 Nginx概述Nginx 是一款高性能的 HTTP 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师 Igor Sysoev 所开发，官方测试 Nginx 能够支支撑 5 万并发链接，并且 CPU、内存等资源消耗却非常低，运行非常稳定。 Nginx 的应用场景 HTTP 服务器：Nginx 是一个 HTTP 服务可以独立提供 HTTP 服务。可以做网页静态服务器。 虚拟主机：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 Nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 Nginx 安装我们使用 Docker 来安装和运行 Nginx，docker-compose.yml 配置如下： 1234567891011version: '3.1'services: nginx: restart: always image: nginx container_name: nginx ports: - 81:80 volumes: - ./conf/nginx.conf:/etc/nginx/nginx.conf - ./wwwroot:/usr/share/nginx/wwwroot]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 管理后台]]></title>
    <url>%2F2013%2F05%2F28%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F136.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0-%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF-%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[管理后台-个人信息-查询温馨提示由于代码量较大，以下仅列出关键步骤，具体请参考 【https://github.com/funtl/MyShopPlus】 修改访问路径修改 frontend/.env.development 文件，将 VUE_APP_BASE_API 地址修改为你自己的网关地址，如：http://localhost:8888/api 修改请求头修改请求头信息，访问时可以直接带 Token 请求，免去每次都需要传递 Token 参数的麻烦；修改 frontend/src/utils/request.js 文件，将 config.headers[&#39;X-Token&#39;] = getToken() 修改为 config.headers[&#39;authorization&#39;] = &#39;Bearer &#39; + getToken() 创建接口创建一个名为 frontend/src/api/profile.js 的 API 接口，主要用于统一管理个人信息请求，代码如下; 123456789101112import request from '@/utils/request'/** * 获取个人信息 * @param username 用户名 */export function info(username) &#123; return request(&#123; url: '/profile/info/' + username, method: 'get' &#125;)&#125; 创建视图创建 frontend/src/views/profile/index.vue 个人信息视图文件，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;账号&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot;&gt; &lt;el-input v-model=&quot;form.email&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;昵称&quot;&gt; &lt;el-input v-model=&quot;form.nickName&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;备注&quot;&gt; &lt;el-input v-model=&quot;form.note&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;创建时间&quot;&gt; &lt;el-input v-model=&quot;form.createTime&quot; :disabled=&quot;true&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;最后登录&quot;&gt; &lt;el-input v-model=&quot;form.loginTime&quot; :disabled=&quot;true&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;是否启用&quot;&gt; &lt;el-radio-group v-model=&quot;form.status&quot;&gt; &lt;el-radio :label=&quot;0&quot;&gt;禁用&lt;/el-radio&gt; &lt;el-radio :label=&quot;1&quot;&gt;启用&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;保存&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; info &#125; from &apos;../../api/profile&apos;export default &#123; name: &apos;Profile&apos;, data() &#123; return &#123; form: &#123; username: &apos;&apos;, email: &apos;&apos;, nickName: &apos;&apos;, note: &apos;&apos;, createTime: &apos;&apos;, loginTime: &apos;&apos;, status: &apos;&apos; &#125; &#125; &#125;, created() &#123; this.fetchData() &#125;, methods: &#123; fetchData() &#123; info(this.$store.getters.name).then(response =&gt; &#123; this.form = response.data &#125;) &#125;, onSubmit() &#123; this.$message(&apos;submit!&apos;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 增加路由配置123456789101112131415&#123; path: '/user', component: Layout, redirect: '/user/profile', name: 'User', meta: &#123; title: '个人信息', icon: 'user' &#125;, children: [ &#123; path: 'profile', name: 'Profile', component: () =&gt; import('@/views/profile/index'), meta: &#123; title: '修改信息' &#125; &#125; ]&#125;]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 创建路由网关]]></title>
    <url>%2F2013%2F05%2F27%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F135.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[创建路由网关Spring Cloud GatewaySpring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式。Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控 / 埋点，和限流等。 功能特征 基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0 动态路由 Predicates 和 Filters 作用于特定路由 集成 Hystrix 断路器 集成 Spring Cloud DiscoveryClient 易于编写的 Predicates 和 Filters 限流 路径重写 工程流程 客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（pre）或之后（post）执行业务逻辑。 创建网关服务创建一个名为 gateway 的服务，专门提供路由网关功能 POM主要增加了 org.springframework.cloud:spring-cloud-starter-gateway 依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;gateway&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- Commons Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Commons Begin --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.myshop.plus.gateway.GatewayApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 注意： Spring Cloud Gateway 不使用 Web 作为服务器，而是 使用 WebFlux 作为服务器 ，Gateway 项目已经依赖了 starter-webflux，所以这里 千万不要依赖 starter-web 注意： 由于过滤器等功能依然需要 Servlet 支持，故这里还需要依赖 javax.servlet:javax.servlet-api Application123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.funtl.myshop.plus.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.gateway.discovery.DiscoveryClientRouteDefinitionLocator;import org.springframework.cloud.gateway.discovery.DiscoveryLocatorProperties;import org.springframework.cloud.gateway.route.RouteDefinitionLocator;import org.springframework.context.annotation.Bean;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpMethod;import org.springframework.http.HttpStatus;import org.springframework.http.codec.ServerCodecConfigurer;import org.springframework.http.codec.support.DefaultServerCodecConfigurer;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.http.server.reactive.ServerHttpResponse;import org.springframework.web.cors.reactive.CorsUtils;import org.springframework.web.server.ServerWebExchange;import org.springframework.web.server.WebFilter;import org.springframework.web.server.WebFilterChain;import reactor.core.publisher.Mono;/** * Spring Cloud Gateway * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-08-01 11:14:35 * @see com.funtl.myshop.plus.gateway */@SpringBootApplication@EnableDiscoveryClientpublic class GatewayApplication &#123; // ----------------------------- 解决跨域 Begin ----------------------------- private static final String ALL = "*"; private static final String MAX_AGE = "3600L"; @Bean public RouteDefinitionLocator discoveryClientRouteDefinitionLocator(DiscoveryClient discoveryClient, DiscoveryLocatorProperties properties) &#123; return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties); &#125; @Bean public ServerCodecConfigurer serverCodecConfigurer() &#123; return new DefaultServerCodecConfigurer(); &#125; @Bean public WebFilter corsFilter() &#123; return (ServerWebExchange ctx, WebFilterChain chain) -&gt; &#123; ServerHttpRequest request = ctx.getRequest(); if (!CorsUtils.isCorsRequest(request)) &#123; return chain.filter(ctx); &#125; HttpHeaders requestHeaders = request.getHeaders(); ServerHttpResponse response = ctx.getResponse(); HttpMethod requestMethod = requestHeaders.getAccessControlRequestMethod(); HttpHeaders headers = response.getHeaders(); headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, requestHeaders.getOrigin()); headers.addAll(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, requestHeaders.getAccessControlRequestHeaders()); if (requestMethod != null) &#123; headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, requestMethod.name()); &#125; headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true"); headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, ALL); headers.add(HttpHeaders.ACCESS_CONTROL_MAX_AGE, MAX_AGE); if (request.getMethod() == HttpMethod.OPTIONS) &#123; response.setStatusCode(HttpStatus.OK); return Mono.empty(); &#125; return chain.filter(ctx); &#125;; &#125; // ----------------------------- 解决跨域 End ----------------------------- public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; application.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051base: config: nacos: hostname: nacos.funtl.com port: 80spring: application: # 应用名称 name: gateway main: allow-bean-definition-overriding: true cloud: # 使用 Nacos 作为服务注册发现 nacos: discovery: server-addr: $&#123;base.config.nacos.hostname&#125;:$&#123;base.config.nacos.port&#125; # 路由网关配置 gateway: # 设置与服务注册发现组件结合，这样可以采用服务名的路由策略 discovery: locator: enabled: true # 配置路由规则 routes: # 采用自定义路由 ID（有固定用法，不同的 id 有不同的功能，详见：https://cloud.spring.io/spring-cloud-gateway/2.0.x/single/spring-cloud-gateway.html#gateway-route-filters） - id: BUSINESS-OAUTH2 # 采用 LoadBalanceClient 方式请求，以 lb:// 开头，后面的是注册在 Nacos 上的服务名 uri: lb://business-oauth2 # Predicate 翻译过来是“谓词”的意思，必须，主要作用是匹配用户的请求，有很多种用法 predicates: # 路径匹配，以 api 开头，直接配置是不生效的，看 filters 配置 - Path=/api/user/** filters: # 前缀过滤，默认配置下，我们的请求路径是 http://localhost:8888/business-oauth2/** 这时会路由到指定的服务 # 此处配置去掉 1 个路径前缀，再配置上面的 Path=/api/**，就能按照 http://localhost:8888/api/** 的方式访问了 - StripPrefix=1 - id: BUSINESS-PROFILE uri: lb://business-profile predicates: - Path=/api/profile/** filters: - StripPrefix=1server: port: 8888# 配置日志级别，方别调试logging: level: org.springframework.cloud.gateway: debug 此时网关请求登录接口路径如：http://localhost:8888/api/user/login 注意： 由于之前的 RestController 代码中使用了 @CrossOrigin(value = &quot;*&quot;, maxAge = 3600) 注解解决跨域问题，此时我们的网关已经一并处理了跨域请将之前的注解删除，否则会报 The &#39;Access-Control-Allow-Origin&#39; header contains multiple values &#39;*, *&#39;, but only one is allowed. 错误，表示配置了多个跨域]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 实现单点登录]]></title>
    <url>%2F2013%2F05%2F26%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F134.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[实现单点登录概述在上一篇 《完善登录和注销》 章节中我们已经实现了 单点登录 功能，核心思想是 万物皆资源 ，只要有访问令牌就允许访问任何已授权的资源（满足十二要素应用的无状态原则）。本节主要目的是对接数据库实现真实的认证功能并创建一个 资源服务器（个人信息服务） 利用 Feign 客户端体验携带访问令牌的请求效果 认证服务器对接提供者application.yml主要增加了包扫描配置 com.funtl.myshop.plus.business.service，因为需要在 UserDetailsServiceImpl 中注入 UmsAdminService 接口 1234567891011121314151617181920212223242526272829303132333435363738spring: application: name: business-oauth2 main: allow-bean-definition-overriding: true jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: nacos: discovery: server-addr: nacos.funtl.com:80dubbo: scan: base-packages: com.funtl.myshop.plus.business.controller, com.funtl.myshop.plus.business.service protocol: name: dubbo port: -1 serialization: kryo registry: address: nacos://nacos.funtl.com port: 80server: port: 9001management: endpoints: web: exposure: include: "*"business: oauth2: grant_type: password client_id: client client_secret: secret 修改自定义认证实现与用户服务提供者对接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.funtl.myshop.plus.business.service;import com.funtl.myshop.plus.provider.api.UmsAdminService;import com.funtl.myshop.plus.provider.domain.UmsAdmin;import com.google.common.collect.Lists;import org.apache.dubbo.config.annotation.Reference;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Component;import java.util.List;/** * 自定义认证 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-29 13:28:10 * @see com.funtl.myshop.plus.business.service * */@Componentpublic class UserDetailsServiceImpl implements UserDetailsService &#123; private static final String USERNAME = "admin"; private static final String PASSWORD = "$2a$10$YNUV/BtCel2orbhgrxyPJeljdKVty6yTAL.Cj4v3XhwHWXBkgyPYW"; @Reference(version = "1.0.0") private UmsAdminService umsAdminService; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; // 查询用户 UmsAdmin umsAdmin = umsAdminService.get(s); // 默认所有用户拥有 USER 权限 List&lt;GrantedAuthority&gt; grantedAuthorities = Lists.newArrayList(); GrantedAuthority grantedAuthority = new SimpleGrantedAuthority("USER"); grantedAuthorities.add(grantedAuthority); // 用户存在 if (umsAdmin != null) &#123; return new User(umsAdmin.getUsername(), umsAdmin.getPassword(), grantedAuthorities); &#125; // 用户不存在 else &#123; return null; &#125; &#125;&#125; 配置 Feign 拦截器项目中使用了 Spring Security oAuth2 作为权限框架，在请求资源的时候需要在请求头中增加类似于 authorization=[Bearer 92b5aa1e-4677-492e-bf1e-81869b9e9ec1] 这样的认证参数（携带令牌访问），在使用 Feign 调用时并不会将我们的请求头或是任何参数传递到目标资源服务器，此时我们就需要使用 Feign 提供的拦截器将请求参数封装后再一并发送给目标资源服务器 configuration创建一个名为 configuration 的模块专门用于存放各种通用配置类，POM 配置如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;configuration&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;modules&gt; &lt;module&gt;configuration-feign&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; configuration-feign创建一个名为 configuration-feign 的模块，该模块的主要作用是做 Feign 的拦截器配置 POM1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;configuration&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;configuration-feign&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建拦截器创建一个名为 FeignRequestInterceptor 类，实现 Feign 提供的 RequestInterceptor 接口，主要作用是将我们的请求分装进 Feign 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.funtl.myshop.plus.interceptor;import feign.Request;import feign.RequestInterceptor;import feign.RequestTemplate;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import java.nio.charset.Charset;import java.util.Enumeration;/** * Feign 拦截器 * &lt;p&gt; * Description: 用于设置请求头，传递 Token * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-31 00:17:20 * @see com.funtl.myshop.plus.interceptor */public class FeignRequestInterceptor implements RequestInterceptor &#123; @Override public void apply(RequestTemplate requestTemplate) &#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); assert attributes != null; HttpServletRequest request = attributes.getRequest(); // 设置请求头 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); if (headerNames != null) &#123; while (headerNames.hasMoreElements()) &#123; String name = headerNames.nextElement(); String value = request.getHeader(name); requestTemplate.header(name, value); &#125; &#125; // 设置请求体，这里主要是为了传递 access_token Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); StringBuilder body = new StringBuilder(); if (parameterNames != null) &#123; while (parameterNames.hasMoreElements()) &#123; String name = parameterNames.nextElement(); String value = request.getParameter(name); // 将 Token 加入请求头 if ("access_token".equals(name)) &#123; requestTemplate.header("authorization", "Bearer " + value); &#125; // 其它参数加入请求体 else &#123; body.append(name).append("=").append(value).append("&amp;"); &#125; &#125; &#125; // 设置请求体 if (body.length() &gt; 0) &#123; // 去掉最后一位 &amp; 符号 body.deleteCharAt(body.length() - 1); requestTemplate.body(Request.Body.bodyTemplate(body.toString(), Charset.defaultCharset())); &#125; &#125;&#125; 创建配置类创建一个名为 FeignRequestConfiguration 的 Java 配置类，注入接口实现 123456789101112131415161718192021222324252627package com.funtl.myshop.plus.configuration;import com.funtl.myshop.plus.interceptor.FeignRequestInterceptor;import feign.RequestInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Feign 全局配置 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-31 00:40:11 * @see com.funtl.myshop.plus.configuration */@Configurationpublic class FeignRequestConfiguration &#123; @Bean public RequestInterceptor requestInterceptor() &#123; return new FeignRequestInterceptor(); &#125;&#125; 创建个人信息服务创建一个名为 business-profile 模块，我们将 Feign 接口与 Spring Cloud 服务分开管理，方便重用 business-profilePOM 配置文件如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;business&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;business-profile&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;modules&gt; &lt;module&gt;business-profile-feign&lt;/module&gt; &lt;module&gt;business-profile-service&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; business-profile-feign创建一个名为 business-profile-feign 的模块，将 Feign 接口单独暴露出来方便以后重用 POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;business-profile&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;business-profile-feign&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;configuration-feign&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; FeignClient在 @FeignClient 注解中增加了上面创建的 FeignRequestConfiguration 拦截器配置类 12345678910111213141516171819202122232425package com.funtl.myshop.plus.business.feign;import com.funtl.myshop.plus.configuration.FeignRequestConfiguration;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * 个人信息管理 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-31 00:47:14 * @see com.funtl.myshop.plus.business.feign */@FeignClient(value = "business-profile", path = "profile", configuration = FeignRequestConfiguration.class)public interface ProfileFeign &#123; @GetMapping(value = "info/&#123;username&#125;") String info(@PathVariable String username);&#125; 注意： GET 方法传递参数不可以用 @ReqeustBody ，请使用路径参数以符合 RESTful 风格 business-profile-service创建一个名为 business-profile-service 的服务，用于提供 Spring Cloud 服务 POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;business-profile&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;business-profile-service&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- Apache Dubbo Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-serialization-kryo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-common&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- Apache Dubbo End --&gt; &lt;!-- Projects Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;commons-dto&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;business-profile-feign&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;ums-admin-provider-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Projects End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.myshop.plus.business.BusinessProfileApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml主要增加了 Spring Security oAuth2 资源服务器相关配置 123456789101112131415161718192021222324252627282930313233343536373839404142spring: application: name: business-profile main: allow-bean-definition-overriding: true jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: nacos: discovery: server-addr: nacos.funtl.com:80security: oauth2: client: client-id: client client-secret: secret access-token-uri: http://localhost:9001/oauth/token user-authorization-uri: http://localhost:9001/oauth/authorize resource: token-info-uri: http://localhost:9001/oauth/check_tokendubbo: scan: base-packages: com.funtl.myshop.plus.business.controller protocol: name: dubbo port: -1 serialization: kryo registry: address: nacos://nacos.funtl.com port: 80server: port: 9002management: endpoints: web: exposure: include: "*" Application需要开启 @EnableDiscoveryClient 服务发现功能 123456789101112131415package com.funtl.myshop.plus.business;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class BusinessProfileApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(BusinessProfileApplication.class, args); &#125;&#125; Controller1234567891011121314151617181920212223242526272829303132333435363738394041package com.funtl.myshop.plus.business.controller;import com.funtl.myshop.plus.commons.dto.ResponseResult;import com.funtl.myshop.plus.provider.api.UmsAdminService;import com.funtl.myshop.plus.provider.domain.UmsAdmin;import org.apache.dubbo.config.annotation.Reference;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * 个人信息管理 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-30 22:34:41 * @see com.funtl.myshop.plus.business.controller */@RestController@RequestMapping(value = "profile")public class ProfileController &#123; @Reference(version = "1.0.0") private UmsAdminService umsAdminService; /** * 获取个人信息 * * @param username 用户名 * @return &#123;@link ResponseResult&#125; */ @GetMapping(value = "info/&#123;username&#125;") public ResponseResult&lt;UmsAdmin&gt; info(@PathVariable String username) &#123; UmsAdmin umsAdmin = umsAdminService.get(username); return new ResponseResult&lt;UmsAdmin&gt;(ResponseResult.CodeStatus.OK, "获取个人信息", umsAdmin); &#125;&#125; 资源配置类由于在认证服务器配置了 resourceIds ，此处必须配置对应的资源 ID 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.funtl.myshop.plus.business.configure;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;/** * 资源服务器 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-30 22:39:54 * @see com.funtl.myshop.plus.business.configure */@Configuration@EnableResourceServer@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)public class ProfileResourceServerConfiguration extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http .exceptionHandling() .and() .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .antMatchers("/**").hasAuthority("USER"); &#125; @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123; // 配置资源 ID resources.resourceId("backend-resources"); &#125;&#125; 修改认证服务器认证服务器负责用户认证和授权，通过认证后我们需要将用户信息传递给前端，此时认证服务器是上面个人信息服务的服务消费者 POM主要增加了 io.github.openfeign:feign-okhttp:10.2.3 依赖，让 Feign 客户端通过 OKHttp3 访问，Feign 提供了 3 种方式分别为： URLConnection(default) OkHttp ApacheHttpClient 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;business&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;business-oauth2&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- Apache Dubbo Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-serialization-kryo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-common&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- Apache Dubbo End --&gt; &lt;!-- Commons Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Commons End --&gt; &lt;!-- Projects Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;commons-dto&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;commons-utils&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;configuration-feign&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;business-profile-feign&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;ums-admin-provider-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Projects End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.myshop.plus.business.BusinessOAuth2Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml主要增加了开启 Feign 的 OKHttp3 方式请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445spring: application: name: business-oauth2 main: allow-bean-definition-overriding: true jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: nacos: discovery: server-addr: nacos.funtl.com:80dubbo: scan: base-packages: com.funtl.myshop.plus.business.controller, com.funtl.myshop.plus.business.service protocol: name: dubbo port: -1 serialization: kryo registry: address: nacos://nacos.funtl.com port: 80# 开启 Feign 的 OKHttp 方式feign: okhttp: enabled: true httpclient: enabled: falseserver: port: 9001management: endpoints: web: exposure: include: "*"business: oauth2: grant_type: password client_id: client client_secret: secret Application需要开启 @EnableDiscoveryClient 服务发现和 @EnableFeignClients 1234567891011121314151617package com.funtl.myshop.plus.business;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class BusinessOAuth2Application &#123; public static void main(String[] args) &#123; SpringApplication.run(BusinessOAuth2Application.class, args); &#125;&#125; Controller主要增加了使用 Feign 请求个人信息服务的代码： 123// 获取个人信息String jsonString = profileFeign.info(authentication.getName());UmsAdmin umsAdmin = MapperUtils.json2pojoByTree(jsonString, "data", UmsAdmin.class); 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.funtl.myshop.plus.business.controller;import com.funtl.myshop.plus.business.dto.LoginInfo;import com.funtl.myshop.plus.business.dto.LoginParam;import com.funtl.myshop.plus.business.feign.ProfileFeign;import com.funtl.myshop.plus.commons.dto.ResponseResult;import com.funtl.myshop.plus.commons.utils.MapperUtils;import com.funtl.myshop.plus.commons.utils.OkHttpClientUtil;import com.funtl.myshop.plus.provider.domain.UmsAdmin;import com.google.common.collect.Maps;import okhttp3.Response;import org.springframework.beans.factory.annotation.Value;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.oauth2.common.OAuth2AccessToken;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import java.util.Map;import java.util.Objects;/** * 登录管理 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-29 11:14:58 * @see com.funtl.myshop.plus.business.controller */@CrossOrigin(origins = "*", maxAge = 3600)@RestControllerpublic class LoginController &#123; private static final String URL_OAUTH_TOKEN = "http://localhost:9001/oauth/token"; @Value("$&#123;business.oauth2.grant_type&#125;") public String oauth2GrantType; @Value("$&#123;business.oauth2.client_id&#125;") public String oauth2ClientId; @Value("$&#123;business.oauth2.client_secret&#125;") public String oauth2ClientSecret; @Resource(name = "userDetailsServiceBean") public UserDetailsService userDetailsService; @Resource public BCryptPasswordEncoder passwordEncoder; @Resource public TokenStore tokenStore; @Resource private ProfileFeign profileFeign; /** * 登录 * * @param loginParam 登录参数 * @return &#123;@link ResponseResult&#125; */ @PostMapping(value = "/user/login") public ResponseResult&lt;Map&lt;String, Object&gt;&gt; login(@RequestBody LoginParam loginParam) &#123; // 封装返回的结果集 Map&lt;String, Object&gt; result = Maps.newHashMap(); // 验证密码是否正确 UserDetails userDetails = userDetailsService.loadUserByUsername(loginParam.getUsername()); if (userDetails == null || !passwordEncoder.matches(loginParam.getPassword(), userDetails.getPassword())) &#123; return new ResponseResult&lt;Map&lt;String, Object&gt;&gt;(ResponseResult.CodeStatus.ILLEGAL_REQUEST, "账号或密码错误", null); &#125; // 通过 HTTP 客户端请求登录接口 Map&lt;String, String&gt; params = Maps.newHashMap(); params.put("username", loginParam.getUsername()); params.put("password", loginParam.getPassword()); params.put("grant_type", oauth2GrantType); params.put("client_id", oauth2ClientId); params.put("client_secret", oauth2ClientSecret); try &#123; // 解析响应结果封装并返回 Response response = OkHttpClientUtil.getInstance().postData(URL_OAUTH_TOKEN, params); String jsonString = Objects.requireNonNull(response.body()).string(); Map&lt;String, Object&gt; jsonMap = MapperUtils.json2map(jsonString); String token = String.valueOf(jsonMap.get("access_token")); result.put("token", token); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new ResponseResult&lt;Map&lt;String, Object&gt;&gt;(ResponseResult.CodeStatus.OK, "登录成功", result); &#125; /** * 获取用户信息 * * @return &#123;@link ResponseResult&#125; */ @GetMapping(value = "/user/info") public ResponseResult&lt;LoginInfo&gt; info() throws Exception &#123; // 获取认证信息 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // 获取个人信息 String jsonString = profileFeign.info(authentication.getName()); UmsAdmin umsAdmin = MapperUtils.json2pojoByTree(jsonString, "data", UmsAdmin.class); // 封装并返回结果 LoginInfo loginInfo = new LoginInfo(); loginInfo.setName(umsAdmin.getNickName()); loginInfo.setAvatar(umsAdmin.getIcon()); return new ResponseResult&lt;LoginInfo&gt;(ResponseResult.CodeStatus.OK, "获取用户信息", loginInfo); &#125; /** * 注销 * * @return &#123;@link ResponseResult&#125; */ @PostMapping(value = "/user/logout") public ResponseResult&lt;Void&gt; logout(HttpServletRequest request) &#123; // 获取 token String token = request.getParameter("access_token"); // 删除 token 以注销 OAuth2AccessToken oAuth2AccessToken = tokenStore.readAccessToken(token); tokenStore.removeAccessToken(oAuth2AccessToken); return new ResponseResult&lt;Void&gt;(ResponseResult.CodeStatus.OK, "用户已注销"); &#125;&#125; 其它说明MapperUtils增加两个通用方法，用于解析 JSON 指定节点的数据 123456789101112131415161718192021222324252627/** * 将指定节点的 JSON 数据转换为 JavaBean * * @param jsonString * @param clazz * @return * @throws Exception */public static &lt;T&gt; T json2pojoByTree(String jsonString, String treeNode, Class&lt;T&gt; clazz) throws Exception &#123; JsonNode jsonNode = objectMapper.readTree(jsonString); JsonNode data = jsonNode.findPath(treeNode); return json2pojo(data.toString(), clazz);&#125;/** * 将指定节点的 JSON 数组转换为集合 * * @param jsonStr JSON 字符串 * @param treeNode 查找 JSON 中的节点 * @return * @throws Exception */public static &lt;T&gt; List&lt;T&gt; json2listByTree(String jsonStr, String treeNode, Class&lt;T&gt; clazz) throws Exception &#123; JsonNode jsonNode = objectMapper.readTree(jsonStr); JsonNode data = jsonNode.findPath(treeNode); return json2list(data.toString(), clazz);&#125; 解决 JSON 日期转换问题问题的原因是日期的形式是字符串 yyyy-MM-dd HH:mm:ss，Jackson 无法将该字符串转成一个 Date 对象；只需要在领域模型的日期字段上增加 @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) 注解即可 123@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")@Column(name = "create_time")private Date createTime; 验证是否成功 登录获取 Token：http://localhost:9001/user/login 访问个人信息接口：http://localhost:9002/profile/info/admin 访问用户信息接口：http://localhost:9001/user/info 由以上结果可以看到，我们成功获取了用户昵称和头像，至此使用令牌访问的单点登录效果就实现了]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 完善登录和注册]]></title>
    <url>%2F2013%2F05%2F25%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F133.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-%E5%AE%8C%E5%96%84%E7%99%BB%E5%BD%95%E5%92%8C%E6%B3%A8%E9%94%80%2F</url>
    <content type="text"><![CDATA[完善登录和注销概述本章节依然使用内存模式处理登录请求并增加注销功能，由于代码量较大，仅列出关键代码 WebSecurity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.funtl.myshop.plus.business.configure;import com.funtl.myshop.plus.business.service.UserDetailsServiceImpl;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;@Configuration@EnableWebSecurity// 增加了资源服务器配置@EnableResourceServer@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Bean public BCryptPasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Bean @Override public UserDetailsService userDetailsServiceBean() throws Exception &#123; return new UserDetailsServiceImpl(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsServiceBean()); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring() .antMatchers("/user/login"); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.exceptionHandling() .and() .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 增加了授权访问配置 .antMatchers("/user/info").hasAuthority("USER") .antMatchers("/user/logout").hasAuthority("USER"); &#125;&#125; AuthorizationServer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.funtl.myshop.plus.business.configure;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter &#123; @Autowired private BCryptPasswordEncoder passwordEncoder; @Autowired private AuthenticationManager authenticationManager; // 增加 TokenStore 配置 @Bean public TokenStore tokenStore() &#123; return new InMemoryTokenStore(); &#125; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints .authenticationManager(authenticationManager) // 增加 TokenStore 配置 .tokenStore(tokenStore()); &#125; @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123; security .checkTokenAccess("isAuthenticated()") .allowFormAuthenticationForClients(); &#125; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients .inMemory() .withClient("client") .secret(passwordEncoder.encode("secret")) .authorizedGrantTypes("password", "refresh_token") .scopes("backend") .resourceIds("backend-resources") .accessTokenValiditySeconds(60 * 60 * 24) .refreshTokenValiditySeconds(60 * 60 * 24 * 30); &#125;&#125; UserDetailsService12345678910111213141516171819202122232425262728293031323334353637package com.funtl.myshop.plus.business.service;import com.google.common.collect.Lists;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Component;import java.util.List;// 优化了认证逻辑@Componentpublic class UserDetailsServiceImpl implements UserDetailsService &#123; private static final String USERNAME = "admin"; private static final String PASSWORD = "$2a$10$YNUV/BtCel2orbhgrxyPJeljdKVty6yTAL.Cj4v3XhwHWXBkgyPYW"; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; // 用户名匹配 if (s.equals(USERNAME)) &#123; List&lt;GrantedAuthority&gt; grantedAuthorities = Lists.newArrayList(); GrantedAuthority grantedAuthority = new SimpleGrantedAuthority("USER"); grantedAuthorities.add(grantedAuthority); return new User(USERNAME, PASSWORD, grantedAuthorities); &#125; // 用户名不匹配 else &#123; return null; &#125; &#125;&#125; LoginController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package com.funtl.myshop.plus.business.controller;import com.funtl.myshop.plus.business.dto.LoginInfo;import com.funtl.myshop.plus.business.dto.LoginParam;import com.funtl.myshop.plus.commons.dto.ResponseResult;import com.funtl.myshop.plus.commons.utils.MapperUtils;import com.funtl.myshop.plus.commons.utils.OkHttpClientUtil;import com.google.common.collect.Maps;import okhttp3.Response;import org.springframework.beans.factory.annotation.Value;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.oauth2.common.OAuth2AccessToken;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import java.util.Map;import java.util.Objects;/** * 登录管理 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-29 11:14:58 * @see com.funtl.myshop.plus.business.controller */@CrossOrigin(origins = "*", maxAge = 3600)@RestControllerpublic class LoginController &#123; private static final String URL_OAUTH_TOKEN = "http://localhost:9001/oauth/token"; @Value("$&#123;business.oauth2.grant_type&#125;") public String oauth2GrantType; @Value("$&#123;business.oauth2.client_id&#125;") public String oauth2ClientId; @Value("$&#123;business.oauth2.client_secret&#125;") public String oauth2ClientSecret; @Resource(name = "userDetailsServiceBean") public UserDetailsService userDetailsService; @Resource public BCryptPasswordEncoder passwordEncoder; @Resource public TokenStore tokenStore; /** * 登录 * * @param loginParam 登录参数 * @return &#123;@link ResponseResult&#125; */ @PostMapping(value = "/user/login") public ResponseResult&lt;Map&lt;String, Object&gt;&gt; login(@RequestBody LoginParam loginParam) &#123; // 封装返回的结果集 Map&lt;String, Object&gt; result = Maps.newHashMap(); // 验证密码是否正确 UserDetails userDetails = userDetailsService.loadUserByUsername(loginParam.getUsername()); if (userDetails == null || !passwordEncoder.matches(loginParam.getPassword(), userDetails.getPassword())) &#123; return new ResponseResult&lt;Map&lt;String, Object&gt;&gt;(ResponseResult.CodeStatus.ILLEGAL_REQUEST, "账号或密码错误", null); &#125; // 通过 HTTP 客户端请求登录接口 Map&lt;String, String&gt; params = Maps.newHashMap(); params.put("username", loginParam.getUsername()); params.put("password", loginParam.getPassword()); params.put("grant_type", oauth2GrantType); params.put("client_id", oauth2ClientId); params.put("client_secret", oauth2ClientSecret); try &#123; // 解析响应结果封装并返回 Response response = OkHttpClientUtil.getInstance().postData(URL_OAUTH_TOKEN, params); String jsonString = Objects.requireNonNull(response.body()).string(); Map&lt;String, Object&gt; jsonMap = MapperUtils.json2map(jsonString); String token = String.valueOf(jsonMap.get("access_token")); result.put("token", token); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new ResponseResult&lt;Map&lt;String, Object&gt;&gt;(ResponseResult.CodeStatus.OK, "登录成功", result); &#125; /** * 获取用户信息 * * @return &#123;@link ResponseResult&#125; */ @GetMapping(value = "/user/info") public ResponseResult&lt;LoginInfo&gt; info(HttpServletRequest request) &#123; // 获取 token String token = request.getParameter("access_token"); // 获取认证信息 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // 封装并返回结果 LoginInfo loginInfo = new LoginInfo(); loginInfo.setName(authentication.getName()); loginInfo.setAvatar(""); loginInfo.setToken(token); return new ResponseResult&lt;LoginInfo&gt;(ResponseResult.CodeStatus.OK, "获取用户信息", loginInfo); &#125; /** * 注销 * * @return &#123;@link ResponseResult&#125; */ @PostMapping(value = "/user/logout") public ResponseResult&lt;Void&gt; logout(HttpServletRequest request) &#123; // 获取 token String token = request.getParameter("access_token"); // 删除 token 以注销 OAuth2AccessToken oAuth2AccessToken = tokenStore.readAccessToken(token); tokenStore.removeAccessToken(oAuth2AccessToken); return new ResponseResult&lt;Void&gt;(ResponseResult.CodeStatus.OK, "用户已注销"); &#125;&#125;]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus OKHttp3]]></title>
    <url>%2F2013%2F05%2F24%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F132.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-OKHttp3%2F</url>
    <content type="text"><![CDATA[OKHttp3概述OKHttp 是一个当前主流的网络请求的开源框架，由 Square 公司开发，用于替代 HttpUrlConnection 和 Apache HttpClient 特性 支持 HTTP2，对一台机器的所有请求共享同一个 Socket 内置连接池，支持连接复用，减少延迟 支持透明的 gzip 压缩响应体 通过缓存避免重复的请求 请求失败时自动重试主机的其他 IP，自动重定向 功能 PUT，DELETE，POST，GET 等请求 文件的上传下载 加载图片 (内部会图片大小自动压缩) 支持请求回调，直接返回对象、对象集合 支持 Session 的保持 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; 测试请求GET测试 Get 请求 123456789101112131415@Testpublic void testGet() &#123; String url = "https://www.baidu.com"; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); Call call = client.newCall(request); try &#123; Response response = call.execute(); System.out.println(response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; POST测试 POST 请求 1234567891011121314151617181920212223@Testpublic void testPost() &#123; String url = "http://localhost:9001/oauth/token"; OkHttpClient client = new OkHttpClient(); RequestBody body = new FormBody.Builder() .add("username", "admin") .add("password", "123456") .add("grant_type", "password") .add("client_id", "client") .add("client_secret", "secret") .build(); Request request = new Request.Builder() .url(url) .post(body) .build(); Call call = client.newCall(request); try &#123; Response response = call.execute(); System.out.println(response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 工具类OKHttp为了简化我们的构建过程，可以封装如下工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255package com.funtl.myshop.plus.commons.utils;import okhttp3.Call;import okhttp3.Callback;import okhttp3.MediaType;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;import java.io.IOException;import java.util.Iterator;import java.util.Map;import java.util.concurrent.TimeUnit;/** * OKHttp3 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-29 14:05:08 * @see com.funtl.myshop.plus.commons.utils */public class OkHttpClientUtil &#123; private static final int READ_TIMEOUT = 100; private static final int CONNECT_TIMEOUT = 60; private static final int WRITE_TIMEOUT = 60; private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8"); private static final byte[] LOCKER = new byte[0]; private static OkHttpClientUtil mInstance; private OkHttpClient okHttpClient; private OkHttpClientUtil() &#123; okhttp3.OkHttpClient.Builder clientBuilder = new okhttp3.OkHttpClient.Builder(); // 读取超时 clientBuilder.readTimeout(READ_TIMEOUT, TimeUnit.SECONDS); // 连接超时 clientBuilder.connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS); //写入超时 clientBuilder.writeTimeout(WRITE_TIMEOUT, TimeUnit.SECONDS); okHttpClient = clientBuilder.build(); &#125; /** * 单例模式获取 NetUtils * * @return &#123;@link OkHttpClientUtil&#125; */ public static OkHttpClientUtil getInstance() &#123; if (mInstance == null) &#123; synchronized (LOCKER) &#123; if (mInstance == null) &#123; mInstance = new OkHttpClientUtil(); &#125; &#125; &#125; return mInstance; &#125; /** * GET，同步方式，获取网络数据 * * @param url 请求地址 * @return &#123;@link Response&#125; */ public Response getData(String url) &#123; // 构造 Request Request.Builder builder = new Request.Builder(); Request request = builder.get().url(url).build(); // 将 Request 封装为 Call Call call = okHttpClient.newCall(request); // 执行 Call，得到 Response Response response = null; try &#123; response = call.execute(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return response; &#125; /** * POST 请求，同步方式，提交数据 * * @param url 请求地址 * @param bodyParams 请求参数 * @return &#123;@link Response&#125; */ public Response postData(String url, Map&lt;String, String&gt; bodyParams) &#123; // 构造 RequestBody RequestBody body = setRequestBody(bodyParams); // 构造 Request Request.Builder requestBuilder = new Request.Builder(); Request request = requestBuilder.post(body).url(url).build(); // 将 Request 封装为 Call Call call = okHttpClient.newCall(request); // 执行 Call，得到 Response Response response = null; try &#123; response = call.execute(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return response; &#125; /** * GET 请求，异步方式，获取网络数据 * * @param url 请求地址 * @param myNetCall 回调函数 */ public void getDataAsync(String url, final MyNetCall myNetCall) &#123; // 构造 Request Request.Builder builder = new Request.Builder(); Request request = builder.get().url(url).build(); // 将 Request 封装为 Call Call call = okHttpClient.newCall(request); // 执行 Call call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; myNetCall.failed(call, e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; myNetCall.success(call, response); &#125; &#125;); &#125; /** * POST 请求，异步方式，提交数据 * * @param url 请求地址 * @param bodyParams 请求参数 * @param myNetCall 回调函数 */ public void postDataAsync(String url, Map&lt;String, String&gt; bodyParams, final MyNetCall myNetCall) &#123; // 构造 RequestBody RequestBody body = setRequestBody(bodyParams); // 构造 Request buildRequest(url, myNetCall, body); &#125; /** * 同步 POST 请求，使用 JSON 格式作为参数 * * @param url 请求地址 * @param json JSON 格式参数 * @return 响应结果 * @throws IOException 异常 */ public String postJson(String url, String json) throws IOException &#123; RequestBody body = RequestBody.create(json, JSON); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = okHttpClient.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException("Unexpected code " + response); &#125; &#125; /** * 异步 POST 请求，使用 JSON 格式作为参数 * * @param url 请求地址 * @param json JSON 格式参数 * @param myNetCall 回调函数 * @throws IOException 异常 */ public void postJsonAsync(String url, String json, final MyNetCall myNetCall) throws IOException &#123; RequestBody body = RequestBody.create(json, JSON); // 构造 Request buildRequest(url, myNetCall, body); &#125; /** * 构造 POST 请求参数 * * @param bodyParams 请求参数 * @return &#123;@link RequestBody&#125; */ private RequestBody setRequestBody(Map&lt;String, String&gt; bodyParams) &#123; RequestBody body = null; okhttp3.FormBody.Builder formEncodingBuilder = new okhttp3.FormBody.Builder(); if (bodyParams != null) &#123; Iterator&lt;String&gt; iterator = bodyParams.keySet().iterator(); String key = ""; while (iterator.hasNext()) &#123; key = iterator.next().toString(); formEncodingBuilder.add(key, bodyParams.get(key)); &#125; &#125; body = formEncodingBuilder.build(); return body; &#125; /** * 构造 Request 发起异步请求 * * @param url 请求地址 * @param myNetCall 回调函数 * @param body &#123;@link RequestBody&#125; */ private void buildRequest(String url, MyNetCall myNetCall, RequestBody body) &#123; Request.Builder requestBuilder = new Request.Builder(); Request request = requestBuilder.post(body).url(url).build(); // 将 Request 封装为 Call Call call = okHttpClient.newCall(request); // 执行 Call call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; myNetCall.failed(call, e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; myNetCall.success(call, response); &#125; &#125;); &#125; /** * 自定义网络回调接口 */ public interface MyNetCall &#123; /** * 请求成功的回调处理 * * @param call &#123;@link Call&#125; * @param response &#123;@link Response&#125; * @throws IOException 异常 */ void success(Call call, Response response) throws IOException; /** * 请求失败的回调处理 * * @param call &#123;@link Call&#125; * @param e 异常 */ void failed(Call call, IOException e); &#125;&#125; Jackson请求的响应结果通常是 JSON 数据格式，此时我们还可以封装一个 Jackson 工具类，简化我们的 JSON 解析过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257package com.funtl.myshop.plus.commons.utils;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Jackson 工具类 * &lt;p&gt;Title: MapperUtils&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * * @author Lusifer * @version 1.0.0 * @date 2018/3/4 21:50 */public class MapperUtils &#123; private final static ObjectMapper objectMapper = new ObjectMapper(); public static ObjectMapper getInstance() &#123; return objectMapper; &#125; /** * 转换为 JSON 字符串 * * @param obj * @return * @throws Exception */ public static String obj2json(Object obj) throws Exception &#123; return objectMapper.writeValueAsString(obj); &#125; /** * 转换为 JSON 字符串，忽略空值 * * @param obj * @return * @throws Exception */ public static String obj2jsonIgnoreNull(Object obj) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return mapper.writeValueAsString(obj); &#125; /** * 转换为 JavaBean * * @param jsonString * @param clazz * @return * @throws Exception */ public static &lt;T&gt; T json2pojo(String jsonString, Class&lt;T&gt; clazz) throws Exception &#123; objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true); return objectMapper.readValue(jsonString, clazz); &#125; /** * 字符串转换为 Map&lt;String, Object&gt; * * @param jsonString * @return * @throws Exception */ public static &lt;T&gt; Map&lt;String, Object&gt; json2map(String jsonString) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return mapper.readValue(jsonString, Map.class); &#125; /** * 字符串转换为 Map&lt;String, T&gt; */ public static &lt;T&gt; Map&lt;String, T&gt; json2map(String jsonString, Class&lt;T&gt; clazz) throws Exception &#123; Map&lt;String, Map&lt;String, Object&gt;&gt; map = objectMapper.readValue(jsonString, new TypeReference&lt;Map&lt;String, T&gt;&gt;() &#123; &#125;); Map&lt;String, T&gt; result = new HashMap&lt;String, T&gt;(); for (Map.Entry&lt;String, Map&lt;String, Object&gt;&gt; entry : map.entrySet()) &#123; result.put(entry.getKey(), map2pojo(entry.getValue(), clazz)); &#125; return result; &#125; /** * 深度转换 JSON 成 Map * * @param json * @return */ public static Map&lt;String, Object&gt; json2mapDeeply(String json) throws Exception &#123; return json2MapRecursion(json, objectMapper); &#125; /** * 把 JSON 解析成 List，如果 List 内部的元素存在 jsonString，继续解析 * * @param json * @param mapper 解析工具 * @return * @throws Exception */ private static List&lt;Object&gt; json2ListRecursion(String json, ObjectMapper mapper) throws Exception &#123; if (json == null) &#123; return null; &#125; List&lt;Object&gt; list = mapper.readValue(json, List.class); for (Object obj : list) &#123; if (obj != null &amp;&amp; obj instanceof String) &#123; String str = (String) obj; if (str.startsWith("[")) &#123; obj = json2ListRecursion(str, mapper); &#125; else if (obj.toString().startsWith("&#123;")) &#123; obj = json2MapRecursion(str, mapper); &#125; &#125; &#125; return list; &#125; /** * 把 JSON 解析成 Map，如果 Map 内部的 Value 存在 jsonString，继续解析 * * @param json * @param mapper * @return * @throws Exception */ private static Map&lt;String, Object&gt; json2MapRecursion(String json, ObjectMapper mapper) throws Exception &#123; if (json == null) &#123; return null; &#125; Map&lt;String, Object&gt; map = mapper.readValue(json, Map.class); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; Object obj = entry.getValue(); if (obj != null &amp;&amp; obj instanceof String) &#123; String str = ((String) obj); if (str.startsWith("[")) &#123; List&lt;?&gt; list = json2ListRecursion(str, mapper); map.put(entry.getKey(), list); &#125; else if (str.startsWith("&#123;")) &#123; Map&lt;String, Object&gt; mapRecursion = json2MapRecursion(str, mapper); map.put(entry.getKey(), mapRecursion); &#125; &#125; &#125; return map; &#125; /** * 将 JSON 数组转换为集合 * * @param jsonArrayStr * @param clazz * @return * @throws Exception */ public static &lt;T&gt; List&lt;T&gt; json2list(String jsonArrayStr, Class&lt;T&gt; clazz) throws Exception &#123; JavaType javaType = getCollectionType(ArrayList.class, clazz); List&lt;T&gt; list = (List&lt;T&gt;) objectMapper.readValue(jsonArrayStr, javaType); return list; &#125; /** * 获取泛型的 Collection Type * * @param collectionClass 泛型的Collection * @param elementClasses 元素类 * @return JavaType Java类型 * @since 1.0 */ public static JavaType getCollectionType(Class&lt;?&gt; collectionClass, Class&lt;?&gt;... elementClasses) &#123; return objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClasses); &#125; /** * 将 Map 转换为 JavaBean * * @param map * @param clazz * @return */ public static &lt;T&gt; T map2pojo(Map map, Class&lt;T&gt; clazz) &#123; return objectMapper.convertValue(map, clazz); &#125; /** * 将 Map 转换为 JSON * * @param map * @return */ public static String mapToJson(Map map) &#123; try &#123; return objectMapper.writeValueAsString(map); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ""; &#125; /** * 将 JSON 对象转换为 JavaBean * * @param obj * @param clazz * @return */ public static &lt;T&gt; T obj2pojo(Object obj, Class&lt;T&gt; clazz) &#123; return objectMapper.convertValue(obj, clazz); &#125; /** * 将指定节点的 JSON 数据转换为 JavaBean * * @param jsonString * @param clazz * @return * @throws Exception */ public static &lt;T&gt; T json2pojoByTree(String jsonString, String treeNode, Class&lt;T&gt; clazz) throws Exception &#123; JsonNode jsonNode = objectMapper.readTree(jsonString); JsonNode data = jsonNode.findPath(treeNode); return json2pojo(data.toString(), clazz); &#125; /** * 将指定节点的 JSON 数组转换为集合 * * @param jsonStr JSON 字符串 * @param treeNode 查找 JSON 中的节点 * @return * @throws Exception */ public static &lt;T&gt; List&lt;T&gt; json2listByTree(String jsonStr, String treeNode, Class&lt;T&gt; clazz) throws Exception &#123; JsonNode jsonNode = objectMapper.readTree(jsonStr); JsonNode data = jsonNode.findPath(treeNode); return json2list(data.toString(), clazz); &#125;&#125;]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 创建后台客户端]]></title>
    <url>%2F2013%2F05%2F23%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F131.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-%E5%88%9B%E5%BB%BA%E5%90%8E%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[创建后台客户端概述创建了微服务以后，我们就可以使用 Vue 开发的客户端来访问我们的服务了，这里采用 Vue Element Admin 作为我们的客户端模板，开发过程中我们使用 基础模板 创建项目并在实际开发中不断完善相关功能 构建步骤1234567891011# 克隆项目git clone https://github.com/PanJiaChen/vue-admin-template.git# 进入项目目录cd vue-admin-template# 安装依赖npm install --registry=https://registry.npm.taobao.org# 启动服务npm run dev 浏览器访问 http://localhost:9528 发布12345# 构建测试环境npm run build:stage# 构建生产环境npm run build:prod 其它1234567891011# 预览发布环境效果npm run preview# 预览发布环境效果 + 静态资源分析npm run preview -- --report# 代码格式检查npm run lint# 代码格式检查并自动修复npm run lint -- --fix]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 创建认证服务]]></title>
    <url>%2F2013%2F05%2F22%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F130.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[创建认证服务概述之前的课程中我们介绍过 Spring Security oAuth2 的四种授权模式（简单模式、密码模式、授权码模式、客户端模式），一般情况下相同产品线我们采用密码模式 注意： 当前案例采用内存模式以便快速演示效果 POM在 business 模块下创建一个名为 business-oauth2 的服务模块，POM 配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;business&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;business-oauth2&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- Apache Dubbo Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-serialization-kryo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-common&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- Apache Dubbo End --&gt; &lt;!-- Projects Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;commons-dto&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;ums-admin-provider-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Projects End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.myshop.plus.business.BusinessOAuth2Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml1234567891011121314151617181920212223242526272829303132spring: application: name: business-oauth2 main: allow-bean-definition-overriding: true jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: nacos: discovery: server-addr: nacos.funtl.com:80dubbo: scan: base-packages: com.funtl.myshop.plus.business.controller protocol: name: dubbo port: -1 serialization: kryo registry: address: nacos://nacos.funtl.com port: 80server: port: 9001management: endpoints: web: exposure: include: "*" Application12345678910111213package com.funtl.myshop.plus.business;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class BusinessOAuth2Application &#123; public static void main(String[] args) &#123; SpringApplication.run(BusinessOAuth2Application.class, args); &#125;&#125; 自定义认证授权123456789101112131415161718192021222324252627282930313233343536package com.funtl.myshop.plus.business.service;import com.google.common.collect.Lists;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.List;/** * 自定义认证授权 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-28 17:57:14 * @see com.funtl.myshop.plus.business.service * */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; private static final String USERNAME = "admin"; private static final String PASSWORD = "$2a$10$WhCuqmyCsYdqtJvM0/J4seCU.xZQHe2snNE5VFUuBGUZWPbtdl3GG"; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; List&lt;GrantedAuthority&gt; grantedAuthorities = Lists.newArrayList(); return new User(USERNAME, PASSWORD, grantedAuthorities); &#125;&#125; 服务器安全配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.funtl.myshop.plus.business.configure;import com.funtl.myshop.plus.business.service.UserDetailsServiceImpl;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;/** * 认证服务器安全配置 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-28 17:56:56 * @see com.funtl.myshop.plus.business.configure */@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Bean public BCryptPasswordEncoder passwordEncoder() &#123; // 配置默认的加密方式 return new BCryptPasswordEncoder(); &#125; @Bean @Override protected UserDetailsService userDetailsService() &#123; return new UserDetailsServiceImpl(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService()); &#125; /** * 用于支持 password 模式 * * @return * @throws Exception */ @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 认证服务器配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.funtl.myshop.plus.business.configure;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;/** * 配置认证服务器 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-28 17:55:49 * @see com.funtl.myshop.plus.business.configure * */@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter &#123; @Autowired private BCryptPasswordEncoder passwordEncoder; /** * 注入用于支持 password 模式 */ @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; // 用于支持密码模式 endpoints.authenticationManager(authenticationManager); &#125; @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123; security // 允许客户端访问 /oauth/check_token 检查 token .checkTokenAccess("isAuthenticated()") .allowFormAuthenticationForClients(); &#125; /** * 配置客户端 * @param clients * @throws Exception */ @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients // 使用内存设置 .inMemory() // client_id .withClient("client") // client_secret .secret(passwordEncoder.encode("secret")) // 授权类型，密码模式和刷新令牌 .authorizedGrantTypes("password", "refresh_token") // 授权范围 .scopes("backend") // 可以设置对哪些资源有访问权限，不设置则全部资源都可以访问 .resourceIds("backend-resources") // 设置访问令牌的有效期，这里是 1 天 .accessTokenValiditySeconds(60 * 60 * 24) // 设置刷新令牌的有效期，这里是 30 天 .refreshTokenValiditySeconds(60 * 60 * 24 * 30); &#125;&#125; 登录获取令牌 通过 CURL 或是 Postman 请求 1curl -i -X POST -d "username=admin&amp;password=123456&amp;grant_type=password&amp;client_id=client&amp;client_secret=secret" http://localhost:9001/oauth/token 得到响应结果如下 1234567&#123; "access_token": "54ef21a8-209b-46d1-b491-9e1cb60ddf2b", "token_type": "bearer", "refresh_token": "67822a82-68aa-4236-82c4-e51b8f580447", "expires_in": 86114, "scope": "backend"&#125;]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 用户注册服务]]></title>
    <url>%2F2013%2F05%2F21%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F129.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[用户注册服务概述服务本身既可以是提供者也可以是消费者，DUBBO 的服务提供者我们当成数据访问层，新创建的业务服务既是 DUBBO 的服务消费者又提供 RESTful 服务，此时可以理解成三层架构中的业务逻辑层 创建业务服务模块创建一个名为 business 的模块，POM 配置如下 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;business&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;modules&gt; &lt;module&gt;business-reg&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 修改用户服务提供者由于代码量较大，此处仅列出关键代码 创建资源配置类目前该类的主要作用是注入 BCryptPasswordEncoder 用户注册时的密码加密 1234567891011121314151617181920212223242526package com.funtl.myshop.plus.provider.configure;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;/** * 资源配置服务器 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-26 04:27:07 * @see com.funtl.myshop.plus.provider.configure */@Configurationpublic class UmsAdminResourceConfiguration &#123; @Bean public BCryptPasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 创建通用类模块创建一个名为 commons 的模块，POM 配置如下 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;commons&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;modules&gt; &lt;module&gt;commons-dto&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 创建通用传输对象模块POM1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;commons&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;commons-dto&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ResponseResult123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.funtl.myshop.plus.commons.dto;import lombok.Data;import java.io.Serializable;/** * 通用数据传输对象 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-26 04:43:54 * @see com.funtl.myshop.plus.commons.dto * */@Datapublic class ResponseResult&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 3468352004150968551L; /** * 状态码 */ private Integer state; /** * 消息 */ private String message; /** * 返回对象 */ private T data; public ResponseResult() &#123; super(); &#125; public ResponseResult(Integer state) &#123; super(); this.state = state; &#125; public ResponseResult(Integer state, String message) &#123; super(); this.state = state; this.message = message; &#125; public ResponseResult(Integer state, Throwable throwable) &#123; super(); this.state = state; this.message = throwable.getMessage(); &#125; public ResponseResult(Integer state, T data) &#123; super(); this.state = state; this.data = data; &#125; public ResponseResult(Integer state, String message, T data) &#123; super(); this.state = state; this.message = message; this.data = data; &#125; public Integer getState() &#123; return state; &#125; public void setState(Integer state) &#123; this.state = state; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((data == null) ? 0 : data.hashCode()); result = prime * result + ((message == null) ? 0 : message.hashCode()); result = prime * result + ((state == null) ? 0 : state.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) &#123; return true; &#125; if (obj == null) &#123; return false; &#125; if (getClass() != obj.getClass()) &#123; return false; &#125; ResponseResult&lt;?&gt; other = (ResponseResult&lt;?&gt;) obj; if (data == null) &#123; if (other.data != null) &#123; return false; &#125; &#125; else if (!data.equals(other.data)) &#123; return false; &#125; if (message == null) &#123; if (other.message != null) &#123; return false; &#125; &#125; else if (!message.equals(other.message)) &#123; return false; &#125; if (state == null) &#123; if (other.state != null) &#123; return false; &#125; &#125; else if (!state.equals(other.state)) &#123; return false; &#125; return true; &#125;&#125; 创建用户注册服务POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;business&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;business-reg&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- Apache Dubbo Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-serialization-kryo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-common&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- Apache Dubbo End --&gt; &lt;!-- Projects Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;commons-dto&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;ums-admin-provider-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Projects End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.myshop.plus.business.BusinessRegApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml123456789101112131415161718192021222324252627282930313233spring: application: name: business-reg main: allow-bean-definition-overriding: true jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: nacos: discovery: server-addr: nacos.funtl.com:80dubbo: scan: base-packages: com.funtl.myshop.plus.business.controller protocol: name: dubbo port: -1 serialization: kryo registry: address: nacos://nacos.funtl.com port: 80server: # $&#123;random.int[9000,9999]&#125; 随机端口 port: 9000management: endpoints: web: exposure: include: "*" Application12345678910111213package com.funtl.myshop.plus.business;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class BusinessRegApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(BusinessRegApplication.class, args); &#125;&#125; Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.funtl.myshop.plus.business.controller;import com.funtl.myshop.plus.commons.dto.ResponseResult;import com.funtl.myshop.plus.provider.api.UmsAdminService;import com.funtl.myshop.plus.provider.domain.UmsAdmin;import org.apache.dubbo.config.annotation.Reference;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * 用户注册 * &lt;p&gt; * Description: * &lt;/p&gt; * * @author Lusifer * @version v1.0.0 * @date 2019-07-26 04:38:50 * @see com.funtl.myshop.plus.business.controller */@CrossOrigin(origins = "*", maxAge = 3600)@RestController@RequestMapping(value = "reg")public class RegController &#123; @Reference(version = "1.0.0") private UmsAdminService umsAdminService; /** * 用户注册 * * @param umsAdmin &#123;@link UmsAdmin&#125; * @return 成功则返回新注册用户信息 */ @PostMapping(value = "") public ResponseResult&lt;UmsAdmin&gt; reg(@RequestBody UmsAdmin umsAdmin) &#123; String message = validateReg(umsAdmin); // 验证通过 if (message == null) &#123; int result = umsAdminService.insert(umsAdmin); // 注册成功 if (result &gt; 0) &#123; UmsAdmin admin = umsAdminService.get(umsAdmin.getUsername()); return new ResponseResult&lt;UmsAdmin&gt;(HttpStatus.OK.value(), "新用户注册成功", admin); &#125; &#125; return new ResponseResult&lt;UmsAdmin&gt;(HttpStatus.NOT_ACCEPTABLE.value(), message != null ? message : "新用户注册失败"); &#125; /** * 验证注册信息 * @param umsAdmin &#123;@link UmsAdmin&#125; * @return 错误信息 */ private String validateReg(UmsAdmin umsAdmin) &#123; UmsAdmin admin = umsAdminService.get(umsAdmin.getUsername()); if (admin != null) &#123; return "用户名已存在，请重新输入"; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 用户服务提供者]]></title>
    <url>%2F2013%2F05%2F20%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F128.MyShopPlus-%E7%94%A8%E6%88%B7%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%2F</url>
    <content type="text"><![CDATA[用户服务提供者概述通常，提供者服务是直接和数据库打交道的，可以理解成三层架构中的数据访问层 创建提供者模块创建一个名为 provider 的模块，POM 配置如下 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt;&lt;/project&gt; 创建用户服务接口由于本次是第一次在 k8s 中注册，所以先测试是否能够成功注册到 Naocs，成功后再进行后续编码工作 POM12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;ums-admin-provider-api&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt;&lt;/project&gt; 定义接口12345package com.funtl.myshop.plus.provider.api;public interface EchoService &#123; String echo(String string);&#125; 创建用户服务实现POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;ums-admin-provider-service&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- Apache Dubbo Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-serialization-kryo&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-common&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- Apache Dubbo End --&gt; &lt;!-- DataSource Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除 tomcat-jdbc 以使用 HikariCP --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- DataSource End --&gt; &lt;!-- Projects Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;ums-admin-provider-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Projects End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.myshop.plus.provider.UmsAdminProviderApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml1234567891011121314151617181920212223242526272829303132333435spring: application: name: ums-admin-provider main: allow-bean-definition-overriding: true datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.141.110:4000/mplus_ums_admin?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: hikari: minimum-idle: 5 idle-timeout: 600000 maximum-pool-size: 10 auto-commit: true pool-name: MyHikariCP max-lifetime: 1800000 connection-timeout: 30000 connection-test-query: SELECT 1dubbo: scan: base-packages: com.funtl.myshop.plus.provider.service protocol: name: dubbo port: -1 serialization: kryo registry: address: nacos://nacos.funtl.com port: 80mybatis: type-aliases-package: com.funtl.myshop.plus.provider.domain mapper-locations: classpath:mapper/*.xml Application123456789101112131415package com.funtl.myshop.plus.provider;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import tk.mybatis.spring.annotation.MapperScan;@SpringBootApplication@MapperScan(basePackages = "com.funtl.myshop.plus.provider.mapper")public class UmsAdminProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UmsAdminProviderApplication.class, args); &#125;&#125; Service123456789101112package com.funtl.myshop.plus.provider.service;import com.funtl.myshop.plus.provider.api.EchoService;import org.apache.dubbo.config.annotation.Service;@Service(version = "1.0.0")public class EchoServiceImpl implements EchoService &#123; @Override public String echo(String string) &#123; return "Echo Hello Dubbo " + string; &#125;&#125; 验证是否成功通过浏览器访问：http://nacos.funtl.com/nacos ，你会发现一个服务已经注册在服务中了，服务名为：providers:com.funtl.myshop.plus.provider.api.EchoService:1.0.0:]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 部署注册中心]]></title>
    <url>%2F2013%2F05%2F19%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F127.MyShopPlus-%E9%83%A8%E7%BD%B2%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[部署注册中心准备 NFS 注意： 以下步骤需要在 NFS 服务端操作 创建 Nacos 所需共享目录 123mkdir -p /data/nfs-sharemkdir -p /data/mysql-mastermkdir -p /data/mysql-slave 给目录增加读写权限 123chmod a+rw /data/nfs-sharechmod a+rw /data/mysql-masterchmod a+rw /data/mysql-slave 配置 NFS 服务目录 123456vi /etc/exports# 底部增加/data/nfs-share *(rw,sync,no_subtree_check,no_root_squash)/data/mysql-master *(rw,sync,no_subtree_check,no_root_squash)/data/mysql-slave *(rw,sync,no_subtree_check,no_root_squash) 重启服务，使配置生效 1/etc/init.d/nfs-kernel-server restart 克隆 Nacos1git clone https://github.com/nacos-group/nacos-k8s.git 部署 NFS 创建角色 1kubectl create -f deploy/nfs/rbac.yaml 创建 ServiceAccount 和部署 NFS-Client Provisioner 1234567891011121314151617181920212223242526272829303132333435363738394041424344vi deploy/nfs/deployment.yaml# 进行如下修改apiVersion: v1kind: ServiceAccountmetadata: name: nfs-client-provisioner---kind: DeploymentapiVersion: extensions/v1beta1metadata: name: nfs-client-provisionerspec: replicas: 1 strategy: type: Recreate template: metadata: labels: app: nfs-client-provisioner spec: serviceAccount: nfs-client-provisioner containers: - name: nfs-client-provisioner image: quay.io/external_storage/nfs-client-provisioner:latest volumeMounts: - name: nfs-client-root mountPath: /persistentvolumes env: - name: PROVISIONER_NAME value: fuseim.pri/ifs - name: NFS_SERVER # 修改为 NFS 服务端 IP value: 192.168.141.130 - name: NFS_PATH # 修改为 NFS 服务端共享目录 value: /data/nfs-share volumes: - name: nfs-client-root nfs: # 修改为 NFS 服务端 IP server: 192.168.141.130 # 修改为 NFS 服务端共享目录 path: /data/nfs-share 1kubectl create -f deploy/nfs/deployment.yaml 创建 NFS StorageClass 1kubectl create -f deploy/nfs/class.yaml 验证 NFS 部署成功 12345kubectl get pod -l app=nfs-client-provisioner# 输出如下NAME READY STATUS RESTARTS AGEnfs-client-provisioner-5f9f96c4dc-mrzr6 1/1 Running 0 177m 部署数据库 部署主库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859vi deploy/mysql/mysql-master-nfs.yaml# 进行如下修改apiVersion: v1kind: ReplicationControllermetadata: name: mysql-master labels: name: mysql-masterspec: replicas: 1 selector: name: mysql-master template: metadata: labels: name: mysql-master spec: containers: - name: master image: nacos/nacos-mysql-master:latest ports: - containerPort: 3306 volumeMounts: - name: mysql-master-data mountPath: /var/lib/mysql env: - name: MYSQL_ROOT_PASSWORD value: "root" - name: MYSQL_DATABASE value: "nacos_devtest" - name: MYSQL_USER value: "nacos" - name: MYSQL_PASSWORD value: "nacos" - name: MYSQL_REPLICATION_USER value: 'nacos_ru' - name: MYSQL_REPLICATION_PASSWORD value: 'nacos_ru' volumes: - name: mysql-master-data nfs: # 修改为 NFS 服务端 IP server: 192.168.141.130 # 修改为 NFS 服务端共享目录 path: /data/mysql-master---apiVersion: v1kind: Servicemetadata: name: mysql-master labels: name: mysql-masterspec: ports: - port: 3306 targetPort: 3306 selector: name: mysql-master 1kubectl create -f deploy/mysql/mysql-master-nfs.yaml 部署从库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253vi deploy/mysql/mysql-slave-nfs.yaml# 进行如下修改apiVersion: v1kind: ReplicationControllermetadata: name: mysql-slave labels: name: mysql-slavespec: replicas: 1 selector: name: mysql-slave template: metadata: labels: name: mysql-slave spec: containers: - name: slave image: nacos/nacos-mysql-slave:latest ports: - containerPort: 3306 volumeMounts: - name: mysql-slave-data mountPath: /var/lib/mysql env: - name: MYSQL_ROOT_PASSWORD value: "root" - name: MYSQL_REPLICATION_USER value: 'nacos_ru' - name: MYSQL_REPLICATION_PASSWORD value: 'nacos_ru' volumes: - name: mysql-slave-data nfs: # 修改为 NFS 服务端 IP server: 192.168.141.130 # 修改为 NFS 服务端共享目录 path: /data/mysql-slave---apiVersion: v1kind: Servicemetadata: name: mysql-slave labels: name: mysql-slavespec: ports: - port: 3306 targetPort: 3306 selector: name: mysql-slave 1kubectl create -f deploy/mysql/mysql-slave-nfs.yaml 验证数据库是否正常工作 123456kubectl get pod# 输出如下NAME READY STATUS RESTARTS AGEmysql-master-82tk4 1/1 Running 1 176mmysql-slave-2pbkk 1/1 Running 0 174m 部署 Nacos 创建 Nacos 1kubectl create -f deploy/nacos/nacos-pvc-nfs.yaml 验证 Nacos 节点启动成功 123456kubectl get pod -l app=nacos# 输出如下NAME READY STATUS RESTARTS AGEnacos-0 1/1 Running 0 174mnacos-1 1/1 Running 0 171m 路由 Nacos 创建一个名为 nacos.yml 的 Ingress 配置文件 123456789101112131415161718192021apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: nacos-web annotations: kubernetes.io/ingress.class: "nginx" nginx.ingress.kubernetes.io/use-regex: "true" nginx.ingress.kubernetes.io/proxy-connect-timeout: "600" nginx.ingress.kubernetes.io/proxy-send-timeout: "600" nginx.ingress.kubernetes.io/proxy-read-timeout: "600" nginx.ingress.kubernetes.io/proxy-body-size: "10m" nginx.ingress.kubernetes.io/rewrite-target: /spec: rules: - host: nacos.funtl.com http: paths: - path: backend: serviceName: nacos-headless servicePort: 8848 部署 Ingress 1kubectl apply -f nacos.yml 验证是否成功（别忘记修改 Hosts） 打开浏览器访问 http://nacos.funtl.com/nacos/#/login 扩容选举 Leader 注意： StatefulSet 控制器根据其序数索引为每个 Pod 提供唯一的主机名。 主机名采用 - 的形式。 因为 nacos StatefulSet 的副本字段设置为 2，所以当前集群文件中只有两个 Nacos 节点地址，故无法选举出 Leader，此时我们就需要手动扩容了 在扩容前，使用 kubectl exec 获取在 pod 中的 Nacos 集群配置文件信息 1for i in 0 1; do echo nacos-$i; kubectl exec nacos-$i cat conf/cluster.conf; done 使用 kubectl scale 对 Nacos 动态扩容 1kubectl scale sts nacos --replicas=3 在扩容后，使用 kubectl exec 获取在 pod 中的 Nacos 集群配置文件信息 1for i in 0 1 2; do echo nacos-$i; kubectl exec nacos-$i cat conf/cluster.conf; done 使用 kubectl exec 执行 Nacos API 在每台节点上获取当前 Leader 是否一致 1for i in 0 1 2; do echo nacos-$i; kubectl exec nacos-$i curl GET "http://localhost:8848/nacos/v1/ns/raft/state"; done 注意： 扩容后可能依然无法正确选举出 Leader，使用 kubectl delete pods nacos-$i 的形式手动删除 Pod ，让 k8s 自动恢复，再观察 naming-raft.log 日志 附：其它小记限制必须要使用持久卷，否则会出现数据丢失的情况 项目目录 目录 描述 plugin 帮助 Nacos 集群进行动态扩容的插件 Docker 镜像源码 deploy K8s 部署文件 配置属性 nacos-pvc-nfs.yaml or nacos-quick-start.yaml 名称 必要 描述 mysql.master.db.name Y 主库名称 mysql.master.port N 主库端口 mysql.slave.port N 从库端口 mysql.master.user Y 主库用户名 mysql.master.password Y 主库密码 NACOS_REPLICAS N 确定执行 Nacos 启动节点数量，如果不适用动态扩容插件，就必须配置这个属性，否则使用扩容插件后不会生效 NACOS_SERVER_PORT N Nacos 端口 PREFER_HOST_MODE Y 启动 Nacos 集群按域名解析 nfs deployment.yaml 名称 必要 描述 NFS_SERVER Y NFS 服务端地址 NFS_PATH Y NFS 共享目录 server Y NFS 服务端地址 path Y NFS 共享目录 mysql 名称 必要 描述 MYSQL_ROOT_PASSWORD N ROOT 密码 MYSQL_DATABASE Y 数据库名称 MYSQL_USER Y 数据库用户名 MYSQL_PASSWORD Y 数据库密码 MYSQL_REPLICATION_USER Y 数据库复制用户 MYSQL_REPLICATION_PASSWORD Y 数据库复制用户密码 Nfs:server N NFS 服务端地址，如果使用本地部署不需要配置 Nfs:path N NFS 共享目录，如果使用本地部署不需要配置]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus 创建项目工程]]></title>
    <url>%2F2013%2F05%2F18%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F126.MyShopPlus-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[创建项目工程工程 POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;modules&gt; &lt;module&gt;dependencies&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;default&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;spring-javaformat.version&gt;0.0.12&lt;/spring-javaformat.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;io.spring.javaformat&lt;/groupId&gt; &lt;artifactId&gt;spring-javaformat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-javaformat.version&#125;&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;**/*Tests.java&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/Abstract*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;systemPropertyVariables&gt; &lt;java.security.egd&gt;file:/dev/./urandom&lt;/java.security.egd&gt; &lt;java.awt.headless&gt;true&lt;/java.awt.headless&gt; &lt;/systemPropertyVariables&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;enforce-rules&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;enforce&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;rules&gt; &lt;bannedDependencies&gt; &lt;excludes&gt; &lt;exclude&gt;commons-logging:*:*&lt;/exclude&gt; &lt;/excludes&gt; &lt;searchTransitive&gt;true&lt;/searchTransitive&gt; &lt;/bannedDependencies&gt; &lt;/rules&gt; &lt;fail&gt;true&lt;/fail&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 依赖管理 POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.funtl.myshop.plus&lt;/groupId&gt; &lt;artifactId&gt;dependencies&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.7.2&lt;/dubbo.version&gt; &lt;dubbo-kryo.version&gt;2.7.2&lt;/dubbo-kryo.version&gt; &lt;dubbo-actuator.version&gt;2.7.1&lt;/dubbo-actuator.version&gt; &lt;spring-boot-mapper.version&gt;2.1.5&lt;/spring-boot-mapper.version&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;spring-cloud-alibaba.verion&gt;0.9.0.RELEASE&lt;/spring-cloud-alibaba.verion&gt; &lt;alibaba-spring-context-support.version&gt;1.0.2&lt;/alibaba-spring-context-support.version&gt; &lt;/properties&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Spring Cloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.verion&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Apache Dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-actuator&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo-actuator.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-serialization-kryo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo-kryo.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-common&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;alibaba-spring-context-support.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- DataSource --&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;$&#123;hikaricp.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除 tomcat-jdbc 以使用 HikariCP --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot-mapper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 初始化数据库略…]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TiDB Cluster]]></title>
    <url>%2F2013%2F05%2F17%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F125.MyShopPlus-TiDB%20Cluster%2F</url>
    <content type="text"><![CDATA[TiDB Cluster环境准备部署前，请确认软件、资源等满足如下需求： 资源需求 CPU 2+，Memory 4G+ Docker：&gt;= 17.03 Helm Client： 版本 &gt;= 2.9.0 并且 &lt; 3.0.0 Kubectl：至少 1.10，建议 1.13 或更高版本 对于 Linux 用户， 如果使用 5.x 或者更高版本内核，安装过程中 kubeadm 可能会打印警告信息。集群可能仍然能正常工作，但是为保证更好的兼容性，建议使用 3.10+ 或者 4.x 版本内核。 需要 root 权限操作 Docker 进程 部署 TiDB Operator 注意： ${chartVersion} 在后续文档中代表 chart 版本，例如 v1.0.0-rc.1 如果 K8s 集群启动并正常运行，可以通过 helm 添加 chart 仓库并安装 TiDB Operator。 添加 Helm chart 仓库 12345helm repo add pingcap http://charts.pingcap.org/ &amp;&amp; \helm repo list &amp;&amp; \helm repo update &amp;&amp; \helm search tidb-cluster -l &amp;&amp; \helm search tidb-operator -l 安装 TiDB Operator 1helm install charts/tidb-operator --name=tidb-operator --namespace=tidb-admin --set scheduler.kubeSchedulerImageName=registry.aliyuncs.com/google_containers/kube-scheduler --version=v1.0.0-rc.1 等待几分钟确保 TiDB Operator 正常运行 123456kubectl get pods --namespace tidb-admin -l app.kubernetes.io/instance=tidb-operator# 输出如下NAME READY STATUS RESTARTS AGEtidb-controller-manager-97dc98b6c-hmlp5 1/1 Running 0 118stidb-scheduler-648f7bc6c8-qdss5 2/2 Running 0 119s 部署本地卷 由于上一章节并没有真正部署 PV，我们先卸载 TiDB local-volume-provisioner.yaml 1kubectl delete -f manifests/local-dind/local-volume-provisioner.yaml 注意： 以下步骤需要在所有 Node 节点分别执行 为虚拟机添加新的磁盘 查看新磁盘 1234567fdisk -l# 可以看到磁盘路径为 /dev/sdbDisk /dev/sdb: 40 GiB, 42949672960 bytes, 83886080 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes 参考 operations guide in sig-storage-local-static-provisioner，tidb-operator 启动会为 pd 和 tikv 绑定 pv，需要在 discovery directory 下创建多个目录 格式化磁盘 1234567891011121314sudo mkfs.ext4 /dev/sdb# 输出如下mke2fs 1.44.1 (24-Mar-2018)Creating filesystem with 10485760 4k blocks and 2621440 inodesFilesystem UUID: 5ace0751-6870-4115-89d4-91e007d8b055Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000, 7962624Allocating group tables: done Writing inode tables: done Creating journal (65536 blocks): doneWriting superblocks and filesystem accounting information: done 挂载磁盘 123DISK_UUID=$(blkid -s UUID -o value /dev/sdb)sudo mkdir -p /mnt/$DISK_UUIDsudo mount -t ext4 /dev/sdb /mnt/$DISK_UUID /etc/fstab 持久化 mount 1234echo UUID=`sudo blkid -s UUID -o value /dev/sdb` /mnt/$DISK_UUID ext4 defaults 0 2 | sudo tee -a /etc/fstab# 输出如下UUID=58759186-ffab-42a3-96ce-f9d3c355d4d1 /mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1 ext4 defaults 0 2 创建多个目录并 mount 到 discovery directory 1234for i in $(seq 1 10); do sudo mkdir -p /mnt/$&#123;DISK_UUID&#125;/vol$&#123;i&#125; /mnt/disks/$&#123;DISK_UUID&#125;_vol$&#123;i&#125; sudo mount --bind /mnt/$&#123;DISK_UUID&#125;/vol$&#123;i&#125; /mnt/disks/$&#123;DISK_UUID&#125;_vol$&#123;i&#125;done /etc/fstab 自动挂载 123456789101112131415for i in $(seq 1 10); do echo /mnt/$&#123;DISK_UUID&#125;/vol$&#123;i&#125; /mnt/disks/$&#123;DISK_UUID&#125;_vol$&#123;i&#125; none bind 0 0 | sudo tee -a /etc/fstabdone# 输出如下/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol1 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol1 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol2 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol2 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol3 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol3 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol4 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol4 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol5 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol5 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol6 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol6 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol7 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol7 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol8 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol8 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol9 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol9 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol10 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol10 none bind 0 0 为 tidb-operator 创建 local-volume-provisioner 1234567891011121314151617181920212223242526272829303132333435kubectl apply -f manifests/local-dind/local-volume-provisioner.yamlkubectl get po -n kube-system -l app=local-volume-provisionerkubectl get pv --all-namespaces | grep local-storage# 输出如下local-pv-105327f3 39Gi RWO Delete Available local-storage 91slocal-pv-137dd513 39Gi RWO Delete Available local-storage 91slocal-pv-198df81a 39Gi RWO Delete Available local-storage 92slocal-pv-1ccfc7b8 39Gi RWO Delete Available local-storage 92slocal-pv-1eedfd0c 39Gi RWO Delete Available local-storage 92slocal-pv-21ebe8d3 39Gi RWO Delete Available local-storage 92slocal-pv-26700c8c 39Gi RWO Delete Available local-storage 91slocal-pv-2c866a2b 39Gi RWO Delete Bound tidb/tikv-tidb-cluster-tikv-1 local-storage 90slocal-pv-332165f7 39Gi RWO Delete Available local-storage 91slocal-pv-337dc036 39Gi RWO Delete Available local-storage 91slocal-pv-5160f51f 39Gi RWO Delete Available local-storage 92slocal-pv-67727d25 39Gi RWO Delete Available local-storage 91slocal-pv-68796375 39Gi RWO Delete Available local-storage 92slocal-pv-6a58a870 39Gi RWO Delete Available local-storage 91slocal-pv-6e6794e6 39Gi RWO Delete Available local-storage 92slocal-pv-794165b7 39Gi RWO Delete Available local-storage 91slocal-pv-7f623e89 39Gi RWO Delete Available local-storage 91slocal-pv-81dad462 39Gi RWO Delete Available local-storage 92slocal-pv-9af9c126 39Gi RWO Delete Available local-storage 91slocal-pv-a3786a90 39Gi RWO Retain Bound tidb/pd-tidb-cluster-pd-2 local-storage 92slocal-pv-b974816a 39Gi RWO Retain Bound tidb/tikv-tidb-cluster-tikv-0 local-storage 92slocal-pv-bc37b3dd 39Gi RWO Delete Available local-storage 91slocal-pv-c975c109 39Gi RWO Delete Available local-storage 91slocal-pv-db3102fc 39Gi RWO Delete Available local-storage 91slocal-pv-e1afde46 39Gi RWO Retain Bound tidb/pd-tidb-cluster-pd-1 local-storage 91slocal-pv-e2f4bb4d 39Gi RWO Delete Available local-storage 91slocal-pv-e59e55a8 39Gi RWO Retain Bound tidb/pd-tidb-cluster-pd-0 local-storage 91slocal-pv-ece22d2 39Gi RWO Delete Available local-storage 90slocal-pv-ecf4dd59 39Gi RWO Delete Available local-storage 91slocal-pv-f1c0babe 39Gi RWO Delete Available local-storage 92s 部署 TiDB Cluster 通过 helm 和 TiDB Operator，我们可以很轻松的部署一套 TiDB 集群 1helm install charts/tidb-cluster --name=tidb-cluster --namespace=tidb --version=v1.0.0-rc.1 等待几分钟，确保 TiDB 所有组件正常创建并进入 ready 状态，可以通过下面命令持续观察 12345678watch kubectl get pods --namespace tidb -l app.kubernetes.io/instance=tidb-cluster -o wide# 输出如下tidb-cluster-discovery-d7498f865-mmjnc 1/1 Running 0 39s 10.244.2.3 kubernetes-node-03 &lt;none&gt; &lt;none&gt;tidb-cluster-monitor-76f98d655d-rv8kf 2/2 Running 0 39s 10.244.140.69 kubernetes-node-02 &lt;none&gt; &lt;none&gt;tidb-cluster-pd-0 1/1 Running 0 36s 10.244.2.4 kubernetes-node-03 &lt;none&gt; &lt;none&gt;tidb-cluster-pd-1 1/1 Running 0 36s 10.244.140.70 kubernetes-node-02 &lt;none&gt; &lt;none&gt;tidb-cluster-pd-2 1/1 Running 0 36s 10.244.141.195 kubernetes-node-01 &lt;none&gt; &lt;none&gt; 获取集群信息 12345kubectl get tidbcluster -n tidb# 输出如下NAME PD STORAGE READY DESIRE TIKV STORAGE READY DESIRE TIDB READY DESIREtidb-cluster pingcap/pd:v3.0.1 1Gi 3 3 pingcap/tikv:v3.0.1 10Gi 3 3 pingcap/tidb:v3.0.1 2 2 1234567kubectl get statefulset -n tidb# 输出如下NAME READY AGEtidb-cluster-pd 3/3 15mtidb-cluster-tidb 2/2 11mtidb-cluster-tikv 3/3 14m 123456789101112kubectl get service -n tidb# 输出如下NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEtidb-cluster-discovery ClusterIP 10.98.237.230 &lt;none&gt; 10261/TCP 16mtidb-cluster-grafana NodePort 10.108.6.182 &lt;none&gt; 3000:31671/TCP 16mtidb-cluster-pd ClusterIP 10.106.96.125 &lt;none&gt; 2379/TCP 16mtidb-cluster-pd-peer ClusterIP None &lt;none&gt; 2380/TCP 16mtidb-cluster-prometheus NodePort 10.104.16.19 &lt;none&gt; 9090:31392/TCP 16mtidb-cluster-tidb NodePort 10.100.103.145 &lt;none&gt; 4000:31652/TCP,10080:30100/TCP 16mtidb-cluster-tidb-peer ClusterIP None &lt;none&gt; 10080/TCP 12mtidb-cluster-tikv-peer ClusterIP None &lt;none&gt; 20160/TCP 14m 123456789101112kubectl get configmap -n tidb# 输出如下NAME DATA AGEtidb-cluster-monitor 5 17mtidb-cluster-monitor-dashboard-extra-v3 2 17mtidb-cluster-monitor-dashboard-v2 5 17mtidb-cluster-monitor-dashboard-v3 5 17mtidb-cluster-pd-aa6df71f 2 17mtidb-cluster-tidb 2 17mtidb-cluster-tidb-a4c4bb14 2 17mtidb-cluster-tikv-e0d21970 2 17m 1234567891011121314kubectl get pod -n tidb# 输出如下NAME READY STATUS RESTARTS AGEtidb-cluster-discovery-d7498f865-zmqj8 1/1 Running 0 18mtidb-cluster-monitor-76f98d655d-x2drs 2/2 Running 0 18mtidb-cluster-pd-0 1/1 Running 0 18mtidb-cluster-pd-1 1/1 Running 0 17mtidb-cluster-pd-2 1/1 Running 1 17mtidb-cluster-tidb-0 2/2 Running 0 14mtidb-cluster-tidb-1 2/2 Running 0 14mtidb-cluster-tikv-0 1/1 Running 0 16mtidb-cluster-tikv-1 1/1 Running 0 16mtidb-cluster-tikv-2 1/1 Running 0 16m 访问数据库通过 kubectl port-forward 暴露服务到主机，可以访问 TiDB 集群。命令中的端口格式为：&lt;主机端口&gt;:&lt;k8s 服务端口&gt; 注意： 如果你不是在本地 PC 而是在远程主机上部署的 DinD 环境，可能无法通过 localhost 访问远程主机的服务。如果使用 kubectl 1.13 或者更高版本，可以在执行 kubectl port-forward 命令时添加 --address 0.0.0.0 选项，在 0.0.0.0 暴露端口而不是默认的 127.0.0.1 1kubectl port-forward svc/tidb-cluster-tidb 4000:4000 --namespace=tidb --address 0.0.0.0 版本：MySQL 5.7.25 账号：root 密码：空 注意： 目前 TiDB 只支持 MySQL5.7 版本客户端 8.0 会报 ERROR 1105 (HY000): Unknown charset id 255 查看监控面板使用 kubectl 暴露 Grafana 服务端口 1kubectl port-forward svc/tidb-cluster-grafana 3000:3000 --namespace=tidb --address 0.0.0.0 在浏览器中打开 http://192.168.141.110:3000 访问 Grafana 监控面板 账号：admin 密码：admin 销毁 TiDB Cluster测试结束后，使用如下命令销毁 TiDB 集群 1helm delete tidb-cluster --purge 注意： 上述命令只是删除运行的 Pod，数据仍然会保留。 如果你不再需要那些数据，可以通过下面命令清除数据（这将永久删除数据） 12kubectl get pv -l app.kubernetes.io/namespace=tidb -o name | xargs -I &#123;&#125; kubectl patch &#123;&#125; -p '&#123;"spec":&#123;"persistentVolumeReclaimPolicy":"Delete"&#125;&#125;' &amp;&amp; \kubectl delete pvc --namespace tidb --all 其它小记 1 node(s) had taints that the pod didn&#39;t tolerate：默认 k8s 不允许往 master 节点装东西，强行设置下允许（下面的 kubernetes-master 是主节点的名称） 1234# 允许 Master 节点部署 Podkubectl taint nodes --all node-role.kubernetes.io/master-# 禁止 Master 节点部署 Podkubectl taint nodes kubernetes-master node-role.kubernetes.io/master=true:NoSchedule 删除全部 PV 1kubectl delete pv --all 卸载挂载目录 1234567DISK_UUID=$(blkid -s UUID -o value /dev/sdb)for i in $(seq 1 10); do sudo umount /mnt/disks/$&#123;DISK_UUID&#125;_vol$&#123;i&#125;donerm -fr /mnt 删除 /etc/fstab 配置中挂载的目录 12345678910111213141516UUID=062815c7-b202-41ef-a5fb-77c783792737 / ext4 defaults 0 0UUID=e8717c59-6d9b-4709-9303-b2161a57912b /boot ext4 defaults 0 0#/swap.img none swap sw 0 0# 卸载挂载目录后需要删除如下内容UUID=58759186-ffab-42a3-96ce-f9d3c355d4d1 /mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1 ext4 defaults 0 2/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol1 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol1 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol2 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol2 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol3 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol3 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol4 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol4 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol5 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol5 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol6 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol6 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol7 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol7 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol8 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol8 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol9 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol9 none bind 0 0/mnt/58759186-ffab-42a3-96ce-f9d3c355d4d1/vol10 /mnt/disks/58759186-ffab-42a3-96ce-f9d3c355d4d1_vol10 none bind 0 0]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TiDB Operator]]></title>
    <url>%2F2013%2F05%2F16%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F124.MyShopPlus-TiDB%20Operator%2F</url>
    <content type="text"><![CDATA[TiDB Operator什么是 TiDB OperatorTiDB Operator 是 TiDB 在 Kubernetes 平台上的自动化部署运维工具。目前，TiDB Operator 已正式开源（pingcap/tidb-operator）。借助 TiDB Operator，TiDB 可以无缝运行在公有云厂商提供的 Kubernetes 平台上，让 TiDB 成为真正的 Cloud-Native 数据库 为什么 TiDB Operator运维成本高使用传统的自动化工具带来了很高的部署和运维成本。TiDB 的分层架构对于分布式系统是比较常见的，各个组件都可以根据业务需求独立水平伸缩，并且 TiKV 和 TiDB 都可以独立使用。比如，在 TiKV 之上可以构建兼容 Redis 协议的 KV 数据库，而 TiDB 也可以对接 LevelDB 这样的 KV 存储引擎。 但是，这种多组件的分布式系统增加了手工部署和运维的成本。一些传统的自动化部署和运维工具如 Puppet/Chef/SaltStack/Ansible，由于缺乏全局状态管理，不能及时对各种异常情况做自动故障转移，并且很难发挥分布式系统的弹性伸缩能力。其中有些还需要写大量的 DSL 甚至与 Shell 脚本一起混合使用，可移植性较差，维护成本比较高。 为云而生在云时代，容器成为应用分发部署的基本单位，而谷歌基于内部使用数十年的容器编排系统 Borg 经验推出的开源容器编排系统 Kubernetes 成为当前容器编排技术事实上的标准。如今各大云厂商都开始提供托管的 Kubernetes 集群，部署在 Kubernetes 平台的应用可以不用绑定在特定云平台，轻松实现在各种云平台之间的迁移，其容器化打包和发布方式也解决了对操作系统环境的依赖。 有状态的Kubernetes 项目最早期只支持无状态服务（Stateless Service）的管理。无状态服务通过 ReplicationController 定义多个副本，由 Kubernetes 调度器来决定在不同节点上启动多个 Pod，实现负载均衡和故障转移。对于无状态服务，多个副本对应的 Pod 是等价的，所以在节点出现故障时，在新节点上启动一个 Pod 与失效的 Pod 是等价的，不会涉及状态迁移问题，因而管理非常简单。 但是对于有状态服务（Stateful Service），由于需要将数据持久化到磁盘，使得不同 Pod 之间不能再认为成等价，也就不能再像无状态服务那样随意进行调度迁移。 Kubernetes v1.3 版本提出 PetSet 的概念，用来管理有状态服务并于 v1.5 将其更名为 StatefulSet。StatefulSet 明确定义一组 Pod 中每个的身份，启动和升级都按特定顺序来操作。另外使用持久化卷存储（PersistentVolume）来作为存储数据的载体，当节点失效 Pod 需要迁移时，对应的 PV 也会重新挂载，而 PV 的底层依托于分布式文件系统，所以 Pod 仍然能访问到之前的数据。同时 Pod 在发生迁移时，其网络身份例如 IP 地址是会发生变化的，很多分布式系统不能接受这种情况。所以 StatefulSet 在迁移 Pod 时可以通过绑定域名的方式来保证 Pod 在集群中网络身份不发生变化。 但是由于有状态服务的特殊性，当节点出现异常时，出于数据安全性考虑，Kubernetes 并不会像无状态服务那样自动做故障转移。尽管网络存储能挂载到不同的节点上供其上的 Pod 使用，但是如果出现节点故障时，简单粗暴地将网络 PV 挂载到其它节点上是比较危险的。 Kubernetes 判断节点故障是基于部署在每个节点上的 Kubelet 服务是否能正常上报节点状态，Kubelet 能否正常工作与用户应用并没有必然联系，在一些特殊情况下，Kubelet 服务进程可能无法正常启动，但是节点上的业务容器还在运行，将 PV 再挂载到其它节点可能会出现双写问题。 为了在 Kubernetes 上部署和管理 TiDB 这种有状态的服务，我们需要扩展 StatefulSet 的功能。TiDB Operator 正是基于 Kubernetes 内置的 StatefulSet 开发的 TiDB 集群管理和运维工具。 Kubernetes 直到 v1.7 才试验性引入本地 PV，在这之前只有网络 PV，TiKV 自身在存储数据时就是多副本的，网络 PV 的多副本会增加数据冗余，降低 TiDB 的性能。在这之前我们基于 Kubernetes 内置的 hostPath volume 实现了本地 PV 满足 TiKV 对磁盘 IO 的要求。官方本地 PV 方案直到最近的 Kubernetes v1.10 才相对稳定地支持调度功能，满足用户对本地 PV 的需求。为了降低用户的使用和管理成本并且拥抱 Kubernetes 开源社区，我们又重新基于官方的本地 PV 方案实现了对数据的管理。 原理解析Operator 本质上是 Kubernetes 的控制器（Controller），其核心思想是用户给定一个 Spec 描述文件，Controller 根据 Spec 的变化，在 Kubernetes 集群中创建对应资源，并且不断调整资源使其状态满足用户预期的 Spec。 上图是 TiDB Operator 工作流程原理图，其中 TidbCluster 是通过 CRD（Custom Resource Definition）扩展的内置资源类型： 用户通过 Helm 往 Kubernetes API Server 创建或更新 TidbCluster 对象 TiDB Operator 通过 watch API Server 中的 TidbCluster 对象创建更新或删除，维护 PD/TiKV/TiDB StatefulSet, Service 和 Deployment 对象更新 Kubernetes 根据 StatefulSet, Service 和 Deployment 对象创建更新或删除对应的容器和服务 在第 2 步中，TiDB Operator 在更新 StatefulSet 等对象时会参考 PD API 给出的集群状态来做出 TiDB 集群的运维处理。通过 TiDB Operator 和 Kubernetes 的动态调度处理，创建出符合用户预期的 TiDB 集群 安装 TiDB OperatorTiDB Operator 需要运行在 Kubernetes v1.10 及以上版本。TiDB Operator 和 TiDB 集群的部署和管理是通过 Kubernetes 平台上的包管理工具 Helm 实现的。运行 TiDB Operator 前请确保 Helm 已经正确安装在 Kubernetes 集群里 要求 Kubernetes v1.10 或更高版本 DNS 插件，如 Calico PersistentVolume 开启 RBAC (可选) Helm version &gt;= v2.8.2 and &lt; v3.0.0 注意： TiDB 可以使用网络卷存储 TiDB 数据，但存在冗余复制操作，导致性能降低。强烈建议设置本地卷获得更好的性能。注意： 网络卷做备份设置需要 Kubernetes v1.12 或更高版本 克隆项目到本地12git clone https://github.com/pingcap/tidb-operator.gitcd tidb-operator 部署本地卷123kubectl apply -f manifests/local-dind/local-volume-provisioner.yamlkubectl get po -n kube-system -l app=local-volume-provisionerkubectl get pv | grep local-storage 安装 安装 CRD 12kubectl apply -f manifests/crd.yamlkubectl get crd tidbclusters.pingcap.com 安装完 TidbCluster 后再在 Kubernetes 集群中安装 Operator， 12# 修改 tidb-operator/charts/tidb-operator/values.yaml 配置kubeSchedulerImageName: registry.aliyuncs.com/google_containers/kube-scheduler 12helm install charts/tidb-operator --name=tidb-operator --namespace=tidb-adminkubectl get po -n tidb-admin -l app.kubernetes.io/name=tidb-operator 卸载 查看 Helm 资源 12345helm ls -a# 输出如下NAME REVISION UPDATED STATUS CHART APP VERSION NAMESPACE tidb-operator 1 Tue Jul 23 07:22:22 2019 DEPLOYED tidb-operator-dev tidb-admin 卸载 Helm 资源 1234helm delete tidb-operator --purge# 输出如下release "tidb-operator" deleted]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TiDB 简介]]></title>
    <url>%2F2013%2F05%2F15%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F123.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-TiDB%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[TiDB 简介什么是 TiDBTiDB 是 PingCAP 公司受 Google Spanner / F1 论文启发而设计的开源分布式 HTAP (Hybrid Transactional and Analytical Processing) 数据库，结合了传统的 RDBMS 和 NoSQL 的最佳特性。TiDB 兼容 MySQL，支持无限的水平扩展，具备强一致性和高可用性。TiDB 的目标是为 OLTP (Online Transactional Processing) 和 OLAP (Online Analytical Processing) 场景提供一站式的解决方案 TiDB 官方网站 核心特点高度兼容 MySQL大多数情况下，无需修改代码即可从 MySQL 轻松迁移至 TiDB，分库分表后的 MySQL 集群亦可通过 TiDB 工具进行实时迁移 水平弹性扩展通过简单地增加新节点即可实现 TiDB 的水平扩展，按需扩展吞吐或存储，轻松应对高并发、海量数据场景 分布式事务TiDB 100% 支持标准的 ACID 事务 真正金融级高可用相比于传统主从 (M-S) 复制方案，基于 Raft 的多数派选举协议可以提供金融级的 100% 数据强一致性保证，且在不丢失大多数副本的前提下，可以实现故障的自动恢复 (auto-failover)，无需人工介入 一站式 HTAP 解决方案TiDB 作为典型的 OLTP 行存数据库，同时兼具强大的 OLAP 性能，配合 TiSpark，可提供一站式 HTAP 解决方案，一份存储同时处理 OLTP &amp; OLAP 无需传统繁琐的 ETL 过程 云原生 SQL 数据库TiDB 是为云而设计的数据库，同 Kubernetes 深度耦合，支持公有云、私有云和混合云，使部署、配置和维护变得十分简单。TiDB 的设计目标是 100% 的 OLTP 场景和 80% 的 OLAP 场景，更复杂的 OLAP 分析可以通过 TiSpark 项目来完成。 TiDB 对业务没有任何侵入性，能优雅的替换传统的数据库中间件、数据库分库分表等 Sharding 方案。同时它也让开发运维人员不用关注数据库 Scale 的细节问题，专注于业务开发，极大的提升研发的生产力 整体架构要深入了解 TiDB 的水平扩展和高可用特点，首先需要了解 TiDB 的整体架构。TiDB 集群主要包括三个核心组件：TiDB Server，PD Server 和 TiKV Server。此外，还有用于解决用户复杂 OLAP 需求的 TiSpark 组件。 TiDB ServerTiDB Server 负责接收 SQL 请求，处理 SQL 相关的逻辑，并通过 PD 找到存储计算所需数据的 TiKV 地址，与 TiKV 交互获取数据，最终返回结果。TiDB Server 是无状态的，其本身并不存储数据，只负责计算，可以无限水平扩展，可以通过负载均衡组件（如 LVS、HAProxy 或 F5）对外提供统一的接入地址。 PD ServerPlacement Driver (简称 PD) 是整个集群的管理模块，其主要工作有三个：一是存储集群的元信息（某个 Key 存储在哪个 TiKV 节点）；二是对 TiKV 集群进行调度和负载均衡（如数据的迁移、Raft group leader 的迁移等）；三是分配全局唯一且递增的事务 ID。 PD 通过 Raft 协议保证数据的安全性。Raft 的 leader server 负责处理所有操作，其余的 PD server 仅用于保证高可用。建议部署奇数个 PD 节点。 TiKV ServerTiKV Server 负责存储数据，从外部看 TiKV 是一个分布式的提供事务的 Key-Value 存储引擎。存储数据的基本单位是 Region，每个 Region 负责存储一个 Key Range（从 StartKey 到 EndKey 的左闭右开区间）的数据，每个 TiKV 节点会负责多个 Region。TiKV 使用 Raft 协议做复制，保持数据的一致性和容灾。副本以 Region 为单位进行管理，不同节点上的多个 Region 构成一个 Raft Group，互为副本。数据在多个 TiKV 之间的负载均衡由 PD 调度，这里也是以 Region 为单位进行调度。 TiSparkTiSpark 作为 TiDB 中解决用户复杂 OLAP 需求的主要组件，将 Spark SQL 直接运行在 TiDB 存储层上，同时融合 TiKV 分布式集群的优势，并融入大数据社区生态。至此，TiDB 可以通过一套系统，同时支持 OLTP 与 OLAP，免除用户数据同步的烦恼。 技术内幕 保存数据 计算-如何做 SQL 运算 调度-TiDB 集群管理 附：扩展阅读OLTP 基本含义： OLTP(Online Transactional Processing)，OLTP 是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，记录即时的增、删、改、查，比如在银行存取一笔款，就是一个事务交易 实时性： OLTP 实时性要求高，OLTP 数据库旨在使事务应用程序仅写入所需的数据，以便尽快处理单个事务 数据量： OLTP 数据量不是很大，一般只读 / 写数十条记录，处理简单的事务 用户和系统的面向性： OLTP 是面向顾客的，用于事务和查询处理 数据库设计： OLTP 采用实体 - 联系 ER 模型和面向应用的数据库设计 OLAP 基本含义： OLAP(Online Analytical Processing) 即联机分析处理，是数据仓库的核心部心，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。典型的应用就是复杂的动态报表系统 实时性： OLAP 的实时性要求不是很高，很多应用顶多是每天更新一下数据 数据量： OLAP 数据量大，因为 OLAP 支持的是动态查询，所以用户也许要通过将很多数据的统计后才能得到想要知道的信息，例如时间序列分析等等，所以处理的数据量很大 用户和系统的面向性： OLAP 是面向市场的，用于数据分析 数据库设计： OLAP 采用星型或雪花模型和面向主题的数据库设计 OLTP OLAP 用户 操作人员，低层管理人员 决策人员，高级管理人员 功能 日常操作处理 分析决策 DB 设计 面向应用 面向主题 数据 当前的，最新的细节，二维的，分立的 历史的，聚集的，多维集成的，统一的 存取 读/写数十条记录 读上百万条记录 工作单位 简单的事务 复杂的查询 用户数 上千个 上百个 DB 大小 100MB-GB 100GB-TB]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Helm 简介]]></title>
    <url>%2F2013%2F05%2F14%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F122.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus-Helm%2F</url>
    <content type="text"><![CDATA[Helm概述Helm 是 Kubernetes 生态系统中的一个软件包管理工具。 官方 GitHub Kubernetes 的应用部署Kubernetes 是一个提供了基于容器的应用集群管理解决方案，Kubernetes 为容器化应用提供了部署运行、资源调度、服务发现和动态伸缩等一系列完整功能。 Kubernetes 的核心设计理念是：用户定义要部署的应用程序的规则，而 Kubernetes 则负责按照定义的规则部署并运行应用程序。如果应用程序出现问题导致偏离了定义的规格，Kubernetes 负责对其进行自动修正。例如：定义的应用规则要求部署两个实例（Pod），其中一个实例异常终止了，Kubernetes 会检查到并重新启动一个新的实例。 用户通过使用 Kubernetes API 对象来描述应用程序规则，包括 Pod、Service、Volume、Namespace、ReplicaSet、Deployment、Job 等等。一般这些资源对象的定义需要写入一系列的 YAML 文件中，然后通过 Kubernetes 命令行工具 Kubectl 调 Kubernetes API 进行部署。 以一个典型的三层应用 Wordpress 为例，该应用程序就涉及到多个 Kubernetes API 对象，而要描述这些 Kubernetes API 对象就可能要同时维护多个 YAML 文件。 从上图可以看到，在进行 Kubernetes 软件部署时，我们面临下述几个问题（Helm 的出现就是为了很好地解决下面这些问题）： 如何管理、编辑和更新这些这些分散的 Kubernetes 应用配置文件。 如何把一套相关的配置文件作为一个应用进行管理。 如何分发和重用 Kubernetes 的应用配置。 什么是 HelmHelm 是 Deis 开发的一个用于 Kubernetes 应用的包管理工具，主要用来管理 Charts。有点类似于 Ubuntu 中的 APT 或 CentOS 中的 YUM。 Helm Chart 是用来封装 Kubernetes 原生应用程序的一系列 YAML 文件。可以在你部署应用的时候自定义应用程序的一些 Metadata，以便于应用程序的分发。 对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。 对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。 组件及相关术语 Helm： 是一个命令行下的客户端工具。主要用于 Kubernetes 应用程序 Chart 的创建、打包、发布以及创建和管理本地和远程的 Chart 仓库 Tiller： 是 Helm 的服务端，部署在 Kubernetes 集群中。Tiller 用于接收 Helm 的请求，并根据 Chart 生成 Kubernetes 的部署文件（ Helm 称为 Release ），然后提交给 Kubernetes 创建应用。Tiller 还提供了 Release 的升级、删除、回滚等一系列功能 Chart： Helm 的软件包，采用 TAR 格式。类似于 APT 的 DEB 包或者 YUM 的 RPM 包，其包含了一组定义 Kubernetes 资源相关的 YAML 文件 Repoistory： Helm 的软件仓库，Repository 本质上是一个 Web 服务器，该服务器保存了一系列的 Chart 软件包以供用户下载，并且提供了一个该 Repository 的 Chart 包的清单文件以供查询。Helm 可以同时管理多个不同的 Repository Release： 使用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release 注意： Helm 中提到的 Release 和我们通常概念中的版本有所不同，这里的 Release 可以理解为 Helm 使用 Chart 包部署的一个应用实例。 工作原理下图描述了 Helm 的几个关键组件 Helm（客户端）、Tiller（服务器）、Repository（Chart 软件仓库）、Chart（软件包）之间的关系。 Chart Install 安装过程 Helm 从指定的目录或者 TAR 文件中解析出 Chart 结构信息 Helm 将指定的 Chart 结构和 Values 信息通过 gRPC 传递给 Tiller Tiller 根据 Chart 和 Values 生成一个 Release Tiller 将 Release 发送给 Kubernetes 用于生成 Release Chart Update 更新过程 Helm 从指定的目录或者 TAR 文件中解析出 Chart 结构信息 Helm 将需要更新的 Release 的名称、Chart 结构和 Values 信息传递给 Tiller Tiller 生成 Release 并更新指定名称的 Release 的 History Tiller 将 Release 发送给 Kubernetes 用于更新 Release Chart Rollback 回滚过程 Helm 将要回滚的 Release 的名称传递给 Tiller Tiller 根据 Release 的名称查找 History Tiller 从 History 中获取上一个 Release Tiller 将上一个 Release 发送给 Kubernetes 用于替换当前 Release Chart 处理依赖Tiller 在处理 Chart 时，直接将 Chart 以及其依赖的所有 Charts 合并为一个 Release，同时传递给 Kubernetes。因此 Tiller 并不负责管理依赖之间的启动顺序。Chart 中的应用需要能够自行处理依赖关系。 安装 Helm安装客户端 HelmHelm 的安装方式很多，这里采用二进制的方式安装。更多安装方法可以参考 Helm 的 官方帮助文档 123456# 下载wget https://get.helm.sh/helm-v2.11.0-linux-amd64.tar.gz# 解压tar -zxvf helm-v2.11.0-linux-amd64.tar.gz# 复制客户端执行文件到 bin 目录下cp linux-amd64/helm /usr/local/bin/ 安装服务端 TillerTiller 是以 Deployment 方式部署在 Kubernetes 集群中的，只需使用以下指令便可简单的完成安装 1helm init --upgrade --tiller-image registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.11.0 --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts 给 Tiller 授权Helm 的服务端 Tiller 是一个部署在 Kubernetes 中 Kube-system Namespace 下的 Deployment，它会去连接 kube-api 在 Kubernetes 里创建和删除应用。 从 Kubernetes 1.6 版本开始，API Server 启用了 RBAC 授权。目前的 Tiller 部署时默认没有定义授权的 ServiceAccount，这会导致访问 API Server 时被拒绝。所以我们需要明确为 Tiller 部署添加授权 创建一个名为 tiller-adminuser.yaml 的配置文件，为 Tiller 创建服务帐号和绑定角色 123456789101112131415161718apiVersion: v1kind: ServiceAccountmetadata: name: tiller namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: tiller-cluster-ruleroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects:- kind: ServiceAccount name: tiller namespace: kube-system 1kubectl apply -f tiller-adminuser.yaml 为 Tiller 设置帐号 12345# 使用 kubectl patch 更新 API 对象kubectl patch deploy --namespace kube-system tiller-deploy -p '&#123;"spec":&#123;"template":&#123;"spec":&#123;"serviceAccount":"tiller"&#125;&#125;&#125;&#125;'# 输出如下deployment.extensions/tiller-deploy patched 查看是否授权成功 12345kubectl get deploy --namespace kube-system tiller-deploy --output yaml|grep serviceAccount# 输出如下serviceAccount: tillerserviceAccountName: tiller 验证安装是否成功1234kubectl -n kube-system get pods|grep tiller# 输出如下tiller-deploy-6d74cd8c9d-v6zg4 1/1 Running 0 10m 12345helm version# 输出如下Client: &amp;version.Version&#123;SemVer:"v2.11.0", GitCommit:"2e55dbe1fdb5fdb96b75ff144a339489417b146b", GitTreeState:"clean"&#125;Server: &amp;version.Version&#123;SemVer:"v2.11.0", GitCommit:"2e55dbe1fdb5fdb96b75ff144a339489417b146b", GitTreeState:"clean"&#125; 卸载 Tiller如果你需要在 Kubernetes 中卸载已部署的 Tiller，可使用以下命令完成卸载 1helm reset]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyShopPlus]]></title>
    <url>%2F2013%2F05%2F13%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FDay72%E3%80%8173%2F121.%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-MyShopPlus%2F</url>
    <content type="text"><![CDATA[MyShopPlus概述MyShopPlus 项目致力于推广并普及 微服务架构 思想，采用全新 服务网格 系统打造电商生态级产品。 GitHub 开发工具 工具 下载地址 Intellij IDEA https://www.jetbrains.com/idea/download SwitchHosts https://oldj.github.io/SwitchHosts/ FinalShell http://www.hostbuf.com/ Postman https://www.getpostman.com/downloads/ SQLyog https://sqlyog.en.softonic.com/ PicPick https://picpick.app/zh/download 亿图图示 https://www.edrawsoft.cn/edrawmax/ 亿图导图 https://www.edrawsoft.cn/mindmaster/ 后端技术 技术 说明 Spring Boot 新一代 JavaEE 开发标准 Spring Cloud Alibaba 阿里巴巴基于 Spring Cloud 编程模型的微服务生态 Spring Cloud Alibaba Dubbo 与 Spring Cloud Alibaba 生态相结合的高性能 Java RPC 框架 Spring Security oAuth2 安全认证和授权框架 Spring Social 第三方登录接入框架 TkMyBatis 基于 MyBatis 二次开发的轻量级框架，用于简化 MyBatis 操作 MyBatisGenerator Maven 插件，用于 MyBatis 相关代码生成 MybatisCodeHelper Intellij IDEA 插件，用于 MyBatis 相关代码生成 PageHelper MyBatis 分页插件 Swagger API 文档生成工具 HikariCP 数据库连接池 Docker 容器化引擎 Docker Compose 容器编排工具 Kubernetes 容器编排系统 前端技术 技术 说明 Vue 前端框架，MVVM 模式的实现者 Vue CLI Vue 脚手架，基于 NodeJS Vue Router Vue 路由框架 Vuex Vue 全局状态管理框架 Axios 前端 HTTP 框架 Element UI 饿了么 UI 框架 Vue Element Admin 基于 Element UI 的前端后台解决方案 框架集成 集成 完成 Spring Boot ✔ Spring Cloud Alibaba ✔ Spring Cloud Alibaba Dubbo ✔ Spring Security oAuth2 后台功能清单后台登录 功能 完成 用户注册 用户登录 获取 Token 刷新 Token 权限管理 角色 菜单 超级管理员 所有菜单权限 运营人员 首页、用户、促销、运营、内容 功能 说明 完成 权限管理 添加权限、删除权限、修改权限、以树形结构返回权限 角色管理 添加角色、删除角色、更新角色、角色列表、获取角色权限、修改角色权限 成员管理 CRUD、为成员分配角色、获取成员角色、权限分配、获取权限列表 前台功能清单规划中… 基础设施规划Docker 服务 主机名 IP/端口 CPU/MEM 说明 GitLab docker-gitlab 192.168.141.200:80 2 核 2G 代码管理 Nexus docker-nexus 192.168.141.201:80 2 核 2G 依赖管理 Harbor docker-harbor 192.168.141.202:80 2 核 2G 镜像管理 ZenTao docker-zentao 192.168.141.203:80 2 核 2G 项目管理 Kubernetes 主机名 IP 角色 CPU/MEM 磁盘 kubernetes-master 192.168.141.110 Master 2 核 2G 20G kubernetes-node-01 192.168.141.120 Node 2 核 4G 20G kubernetes-node-02 192.168.141.121 Node 2 核 4G 20G kubernetes-node-03 192.168.141.122 Node 2 核 4G 20G kubernetes-volumes 192.168.141.130 NFS 2 核 2G 按需扩容 容器部署配置GItLab123456789101112131415161718192021version: '3'services: web: image: 'twang2218/gitlab-ce-zh' restart: always hostname: '192.168.141.200' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://192.168.141.200' gitlab_rails['gitlab_shell_ssh_port'] = 2222 unicorn['port'] = 8888 nginx['listen_port'] = 80 ports: - '80:80' - '443:443' - '2222:22' volumes: - ./config:/etc/gitlab - ./data:/var/opt/gitlab - ./logs:/var/log/gitlab Nexus 账号： admin 密码： cat /var/lib/docker/volumes/nexus_data/_data/admin.password 12345678910111213version: '3.1'services: nexus: restart: always image: sonatype/nexus3 container_name: nexus ports: - 80:8081 volumes: - data:/nexus-datavolumes: data: Harbor官方 GitHub 上下载最新离线安装版（我已经下载并放置在群分享的 Linux 目录下）并上传至服务器 账号： admin 密码： Harbor12345 12345678910# 解压tar -zxvf harbor-offline-installer-v1.8.0.tgz# 修改cd harborvi harbor.ymlhostname: 192.168.141.202# 安装./install.sh 禅道 禅道开源版：http://dl.cnezsoft.com/zentao/docker/docker_zentao.zip 下载并解压后将目录名修改为 build，再通过 Compose 构建 12345678910111213version: '3.1'services: zendao: build: build restart: always container_name: zendao environment: MYSQL_ROOT_PASSWORD: 123456 ports: - 80:80 volumes: - ./app:/app/zentaopms - ./data:/var/lib/mysql]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Netflix 简介2]]></title>
    <url>%2F2013%2F05%2F12%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FSpring-Cloud%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Spring-Cloud一. Zuul路由网关​ zuul包含了对请求的路由和过滤最主要的两个功能。路由负责将外部的请求转发到具体的微服务实例上，是实现外部访问统一入口的基础；过滤功能负责对请求的处理工程进行干预，是实现请求校验、服务聚合等功能的基础. zuul和Eureka进行整合，将zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。综上所述，Zuul服务最终还是会注册进Eureka. ​ 对于上面的图例你是否看出了什么问题呢？正常情况下为了保证对外服务的安全性,我们在服务接口上都会做一些权限校验,或者签名校验机制等，而我们的微服务理念把应用拆成了很多的服务,而这些服务都是需要做接口权限校验，那就意味着我们需要花很大的力气在每个服务接口上都去写一条权限校验的代码,这种方式肯定是不合理的。再者说如果我们服务过多的情况下，对于服务接口调用规则，服务列表等维护工作也会变得复杂，基于这些问题，API 网关(路由网关)的概念应运而生。 ​ API网关就像整个系统的门面一样,所有的外部访问都经过它实现调度,过滤,请求路由,负载均衡,校验等等，在SpringCloud为我们提供了基于Netflix Zuul实现的API网关组件——Spring Cloud Netflix Zuul，加入网关API后的服务架构如图： 1.1 依赖配置123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 application.yml配置12345678910111213server: port: 8086spring: application: name: shop-zuuleureka: instance: prefer-ip-address: true client: service-url: default-zone: http://localhost:8761/eureka/ 1.3 启动类配置1234567@SpringBootApplication@EnableZuulProxypublic class ZuulApplication &#123; public static void main( String[] args ) &#123; SpringApplication.run(ZuulApplication.class, args); &#125;&#125; 1.4 测试​ 在浏览器地址栏输入服务提供方(shop-provider)的地址：http://localhost:6001/ticket/23，看到如下结果： ​ 或者输入地址：http://localhost:8086/shop-provider/ticket/23，观察如下结果: ​ 从上面的结果我们可看出zuul基本配置成功，但是同时会有一个问题，就是服务名暴露出来了。 1.5 统一网关设置12345678910zuul: routes: shop-provider: #这个名字可以随便命名，通常定义为每个微服务中的spring.application.name的值 serviceId: shop-provider #该值必须为spring.application.name的值 path: /tk/** #可以通过该路径访问服务 shop-consumer: serviceId: shop-consumer path: /us/** prefix: /v1 #前缀 ignored-services: &quot;*&quot; #通过该服务名访问不了 如上图所示，访问shop-provider服务只能通过一下两种方式访问： A. http://localhost:6001/ticket/23 B. http://localhost:8086/v1/tk/ticket/23 1.6 网关的过滤​ 网关除了路由还有过滤功能，如何实现过滤功能呢？需要实现ZuulFilter接口，接口中有五个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Componentpublic class MyZuulFilter extends ZuulFilter &#123; private Logger logger = LoggerFactory.getLogger(MyZuulFilter.class); /** * pre 要用在路由映射的阶段是寻找路由映射表的 * post routing，error运行完后才会调用该过滤器，是在最后阶段的 * error 一旦前面的过滤器出错了，会调用error过滤器。 * route 具体的请求转发的时候会调用 */ @Override public String filterType() &#123; return &quot;pre&quot;; &#125; //自定义过滤器执行的顺序，数值越大越靠后执行，越小就越先执行 @Override public int filterOrder() &#123; return 0; &#125; // 是否执行过滤，返回true,否则没有意义 @Override public boolean shouldFilter() &#123; return true; &#125; // 具体的逻辑 @Override public Object run() throws ZuulException &#123; RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletRequest request = requestContext.getRequest(); String access_token = request.getParameter(&quot;access_token&quot;); if(StringUtils.isBlank(access_token) || !&quot;test&quot;.equals(access_token))&#123; // zuul过滤该请求 requestContext.setSendZuulResponse(false); requestContext.setResponseStatusCode(401); requestContext.setResponseBody(&quot;token is invalid&quot;); logger.info(&quot;the request &#123;&#125; is fail, the token is invalid&quot;, request.getRequestURL().toString()); &#125; else &#123; logger.info(&quot;the request &#123;&#125; is ok&quot;, request.getRequestURL().toString()); &#125; return null; &#125;&#125; requestContext.setSendZuulResponse(false);表示不继续转发该请求。 requestContext.setResponseStatusCode(401);返回的状态码，这里为401 requestContext.setResponseBody(“token is invalid”);返回的内容，可以指定为一串json 二. spring cloud配置中心​ 就目前来说，业界对于微服务并没有一个统一的、标准的定义。微服务之是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行在自己独立的进程中，服务之间互相协调，为用户提供最终价值。服务间采用轻量级的通信机制互相沟通(通常是http的restful api)。每个服务围绕着具体的业务进行构建，并且可以独立的部署到生产环境。另外，应当尽量避免统一、集中式的服务管理机制，而对于具体的一个服务而言，应根据业务，使用非常轻量级的集中式管理来协调这些服务。 ​ 微服务以为着将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的，spring cloud提供了configServer来解决这个问题。 2.1 spring cloud config是什么​ spring cloud config 为微服务架构中的各个服务提供了集中化的外部配置，配置服务器为各个不同的微服务环境提供了一个中心化的配置。 2.2 创建配置的服务端A 在github创建一个远程库 B. 拷贝仓库地址 C. 在本地新建git仓库并克隆 D. 创建名为application.yml的文件并推送的github，文件内容如下： 1234567891011121314spring: profiles: active: - dev------spring: profiles: dev application: name: shop-config-devspring: profiles: test application: name: shop-config-test 推送到github的命令依次为： git add . #将所有的文件纳入到暂存区 git commit -m ‘add a new file’ . #将所有的文件提交到本地库 git push origin master #将master分支推送到github 如下图所示，在github的仓库中可以看到application.yml文件： E. 创建本地工程 pom依赖： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; application.yml文件配置 12345678910111213141516171819server: port: 8989spring: cloud: config: server: git: uri: https://github.com/pretty-cat/spring-cloud-config-center.git application: name: cloud-configeureka: client: register-with-eureka: true fetch-registry: false service-url: default-zone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 启动类配置： 12345678@SpringBootApplication@EnableConfigServer@EnableEurekaClientpublic class CloudConfigApplication &#123; public static void main( String[] args ) &#123; SpringApplication.run(CloudConfigApplication.class, args); &#125;&#125; 在浏览器输入：http://localhost:8989/application-dev.yml 其中application为github中配置文件的文件名，dev为配置文件中application.profiles的值，结果如下图所示： 在浏览器中输入：http://localhost:8989/application/dev，其中application为文件名，dev为application.profiles的值，结果如下图所示： 2.3 创建配置客户端pom文件配置 123456789101112dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在github上放三个文件，application.yml, application-dev.yml和application-test.yml，如下图所示： ​ 在resources资源文件下新建文件叫做bootstrap.yml文件，该文件比application.yml文件会先加载，该改文件中加入如下代码： 123456spring: cloud: config: name: application #文件名 profile: dev #加载哪个文件 uri: http://localhost:8989 #config服务器的地址 当profile的值为dev的时候，运行结果如下： 当profile的值为test的时候，运行的结果如下：]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Netflix 简介]]></title>
    <url>%2F2013%2F05%2F11%2FSpring-Cloud%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Spring Cloud一. Eureka简介​ Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。 ​ Eureka包含两个组件：Eureka Server和Eureka Client。 ​ Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。 ​ Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也就别一个内置的、使用轮询(round-robin)负载算法的负载均衡。 1.1 Eureka Server的搭建1.1.1 依赖配置123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;!-- 在写版本的时候，不能像官网那样写 Greenwich SR2， --&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1.1.2 application.yml配置12345678eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:$&#123;server.port&#125;/eureka/ 1.1.3 代码1234567@SpringBootApplication@EnableEurekaServer //启用Eureka的服务public class EurekaServerApplication &#123; public static void main( String[] args ) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 1.2 服务提供方1.2.1 依赖配置1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 1.2.2 application.yml配置12345678eureka: instance: prefer-ip-address: true client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka/ 1.2.3 代码编写1234567@SpringBootApplication@EnableEurekaClient //启动Eureka客户端public class ShopProviderApplication &#123; public static void main( String[] args)&#123; SpringApplication.run(ShopProviderApplication.class, args); &#125;&#125; 1.3 服务消费方1.3.1 application.yml配置12345spring: application: name: shop-consumerserver: port: 8080 1.3.2 代码的编写启动类代码： 123456@SpringBootApplicationpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 调用类代码： 12345678910111213141516171819@RestController@RequestMapping(value=&quot;/user&quot;)public class UserController &#123; @Resource private RestTemplate restTemplate; @RequestMapping(value = &quot;/ticket/&#123;id&#125;&quot;, method = RequestMethod.GET) public Object getTicket(@PathVariable(value = &quot;id&quot;) Integer id) &#123; Person person = new Person(); person.setId(23); person.setName(&quot;张三三&quot;); List&lt;Ticket&gt; ticketList = restTemplate.postForEntity(&quot;http://localhost:666/ticket&quot;, person, List.class).getBody(); return ticketList; &#125;&#125; RestTemplate的注入： 123456789@Configurationpublic class BeanConfig &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 二. Ribbon​ Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。其主要功能是提供客户端的负载均衡算法，并提供了完善的配置项如连接超时，重试等。简单的说，就是配置文件中列出Load Balancer后面所有的机器，Ribbon会自动的基于某种规则(如简单轮询，随机连接等)去连接这些机器，当然我们也可以使用Ribbon自定义负载均衡算法。Ribbon的实现需要使用的Eureka，消费方需要在Eureka注册中心找到要调用的服务的相关信息。 2.1 配置依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 实现负载均衡​ Ribbon只是一个客户端的负载均衡器工具，实现起来非常的简单，我们只需要在注入RestTemplate的bean上加上@LoadBalanced就可以了。如下： 123456789@Configurationpublic class BeanConfig &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 2.3 启动类配置1234567@SpringBootApplication@EnableEurekaClientpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 2.4 服务的调用​ 在服务的消费方，不再采用主机名+端口的形式进行调用，而是直接采用服务名的方式进行调用。 123456789101112131415161718@RestController@RequestMapping(value=&quot;/user&quot;)public class UserController &#123; @Resource private RestTemplate restTemplate; @RequestMapping(value = &quot;/ticket/&#123;id&#125;&quot;, method = RequestMethod.GET) public Object getTicket(@PathVariable(value = &quot;id&quot;) Integer id) &#123; Person person = new Person(); person.setId(23); person.setName(&quot;张三三&quot;); // shop-provider 是服务名，不需要使用ip:端口的形式进行调用 List&lt;Ticket&gt; ticketList = restTemplate.getForObject(&quot;http://shop-provier/ticket&quot;, List.class, person); return ticketList; &#125;&#125; 2.5 负载均衡策略​ Ribbon提供了一个很重要的接口叫做IRule，其中定义了很多的负载均衡策略，默认的是轮询的方式，以下是Ribbon的负载均衡策略： 类名 描述 RoundRobinRule 轮询 RandomRule 随机挑选 RetryRule 按照轮询的方式去调用服务，如果其中某个服务不可用，但是还是会尝试几次，如果尝试过几次都没有成功，那么就不在调用该服务，会轮询调用其他的可用服务。 AvailabilityFilteringRule 会先过滤掉因为多次访问不可达和并发超过阈值的服务，然后轮询调用其他的服务 WeightedResponseTimeRule 根据平均响应时间计算权重，响应越快权重越大，越容易被选中。服务刚重启的时候，还未统计出权重会按照轮询的方式；当统计信息足够的时候，就会按照权重信息访问 ZoneAvoidanceRule 判断server所在的区域性能和可用性选择服务器 BestAvailableRule 会过滤掉多次访问都不可达的服务，然后选择并发量最小的服务进行调用，默认方式 ​ 改变Ribbon的负责均衡策略： 1234@Beanpublic IRule getRule() &#123; return new RandomRule();&#125; 2.6 自定义负载均衡策略​ 我们自定义的负载均衡策略需要继承AbstractLoadBalancerRule这个类，然后重写choose方法，然后将其注入到容器中，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Customize_Rule extends AbstractLoadBalancerRule &#123; private static Logger logger = LoggerFactory.getLogger(Customize_Rule.class); private int currentIndex = 0; //当前调用的索引 private int num = 1; //次数 private int limit = 5; /** * 初始化工作 * @param iClientConfig */ @Override public void initWithNiwsConfig(IClientConfig iClientConfig) &#123; &#125; @Override public Server choose(Object key) &#123; ILoadBalancer balancer = getLoadBalancer(); return choose(balancer, key); &#125; private Server choose(ILoadBalancer balancer, Object key) &#123; Server server = null; while(null == server) &#123; //获取所有可用的服务 List&lt;Server&gt; reachableServers = balancer.getReachableServers(); if (0 == reachableServers.size()) &#123; logger.error(&quot;没有可用的服务&quot;); return null; //退出while循环 &#125; int total = reachableServers.size(); //可用服务的数量 synchronized (this) &#123; /** * 有种极端情况，当我们在使用最后一个服务的时候，其他的服务都不可用，可能导致索引越界异常 */ if (currentIndex + 1 &gt; total) &#123; currentIndex = 0; server = reachableServers.get(currentIndex); //获取第一个服务 num = 0; num++; &#125; else &#123; if(limit == num) &#123; currentIndex++; num = 0; if(currentIndex == total) &#123; currentIndex=0; server = reachableServers.get(currentIndex); //获取第一个服务 num++; &#125;else&#123; server = reachableServers.get(currentIndex); num++; &#125; &#125;else &#123; server = reachableServers.get(currentIndex); num++; &#125; &#125; &#125; &#125; return server; &#125;&#125; ​ 将其注入到容器中，如下所示： 1234@Beanpublic IRule getRule() &#123; return new Customize_Rule();&#125; 三. Feign负载均衡​ feign是基于Ribbon的另外一个负载均衡的客户端框架，只需要在接口上定义要调用的服务名即可，使用起来非常的简单。 3.1 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 3.2 启动类的配置 ​ 需要在启动类上加上@EnableFeignClients注解即可开启feign，如下所示： 12345678@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 3.3 服务接口配置与调用方式 1234567@Service@FeignClient(name = &quot;shop-provier&quot;)public interface TicketService &#123; @RequestMapping(value = &quot;ticket&quot;, method = RequestMethod.GET) public List&lt;Ticket&gt; getAllTicket(Person person);&#125; 四. Hystrix断路器​ 分布式系统中一个微服务需要依赖于很多的其他的服务，那么服务就会不可避免的失败。例如A服务依赖于B、C、D等很多的服务，当B服务不可用的时候，会一直阻塞或者异常，更不会去调用C服务和D服务。同时假设有其他的服务也依赖于B服务，也会碰到同样的问题，这就及有可能导致雪崩效应。 ​ 如下案例：一个用户通过通过web容器访问应用，他要先后调用A、H、I、P四个模块，一切看着都很美好。 ​ 由于某些原因，导致I服务不可用，与此同时我们没有快速处理，会导致该用户一直处于阻塞状态。 ​ 当其他用户做同样的请求，也会面临着同样的问题，tomcat支持的最大并发数是有限的，资源都是有限的，将整个服务器拖垮都是有可能的。 ​ Hystrix是一个用于分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖会不可避免的调用失败，例如超时，异常等，Hystrix能保证在一个依赖出现问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。 ​ 断路器本身是一种开关装置，当某个服务单元发生故障后，通过断路器的故障监控（类似于保险丝），向调用者返回符合预期的，可处理的备选响应，而不是长时间的等待或者抛出无法处理的异常，这样就保证了服务调用的线程不会被长时间，不必要的占用，从而避免故障在分布式系统中的蔓延，乃至雪崩。 ​ Hystrix在网络依赖服务出现高延迟或者失败时，为系统提供保护和控制;可以进行快速失败，缩短延迟等待时间；提供失败回退（Fallback）和相对优雅的服务降级机制；提供有效的服务容错监控、报警和运维控制手段。 4.1 配置依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 4.2 application.yml配置123feign: hystrix: enabled: true #开启feign的熔断机制 4.3 启动类配置​ 只需要在启动类上加上@EnableCircuitBreaker注解即可，如下所示： 123456789@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableCircuitBreakerpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 4.4 接口的编写​ 在接口的@FeignClient注解中加入fallback参数，该参数为Class类型的对象，我们将该接口实现，作为服务降级后的快速响应，然后提供给fallback作为参数的值，如下所示： 1234567@Service@FeignClient(name = &quot;shop-provier&quot;, fallback = TicketServiceFallback.class)public interface TicketService &#123; @RequestMapping(value = &quot;ticket&quot;, method = RequestMethod.GET) public List&lt;Ticket&gt; getAllTicket(Person person);&#125; TicketServiceFallback是对TicketService这个接口的实现，用于在服务降级后的一个快速响应，代码如下： 12345678@Componentpublic class TicketServiceFallback implements TicketService &#123; @Override public List&lt;Ticket&gt; getAllTicket(Person person) &#123; return Arrays.asList(new Ticket()); &#125;&#125; 4.5 Hystrix监控4.5.1 配置依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 4.5.2 启动类配置​ 在启动类上加上@EnableHystrixDashboard注解，如下图所示： 12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableCircuitBreaker@EnableHystrixDashboardpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 4.5.3 编写servlet入口12345678910@Beanpublic ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean;&#125; 4.5.4 访问Hystrix Dashboard​ 在输入框中输入：http://locahost:8080/actuator/hystrix.stream]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Netflix 简介]]></title>
    <url>%2F2013%2F05%2F11%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FSpring-Cloud%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Spring Cloud一. Eureka简介​ Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。 ​ Eureka包含两个组件：Eureka Server和Eureka Client。 ​ Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。 ​ Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也就别一个内置的、使用轮询(round-robin)负载算法的负载均衡。 1.1 Eureka Server的搭建1.1.1 依赖配置123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;!-- 在写版本的时候，不能像官网那样写 Greenwich SR2， --&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1.1.2 application.yml配置12345678eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:$&#123;server.port&#125;/eureka/ 1.1.3 代码1234567@SpringBootApplication@EnableEurekaServer //启用Eureka的服务public class EurekaServerApplication &#123; public static void main( String[] args ) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 1.2 服务提供方1.2.1 依赖配置1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 1.2.2 application.yml配置12345678eureka: instance: prefer-ip-address: true client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka/ 1.2.3 代码编写1234567@SpringBootApplication@EnableEurekaClient //启动Eureka客户端public class ShopProviderApplication &#123; public static void main( String[] args)&#123; SpringApplication.run(ShopProviderApplication.class, args); &#125;&#125; 1.3 服务消费方1.3.1 application.yml配置12345spring: application: name: shop-consumerserver: port: 8080 1.3.2 代码的编写启动类代码： 123456@SpringBootApplicationpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 调用类代码： 12345678910111213141516171819@RestController@RequestMapping(value=&quot;/user&quot;)public class UserController &#123; @Resource private RestTemplate restTemplate; @RequestMapping(value = &quot;/ticket/&#123;id&#125;&quot;, method = RequestMethod.GET) public Object getTicket(@PathVariable(value = &quot;id&quot;) Integer id) &#123; Person person = new Person(); person.setId(23); person.setName(&quot;张三三&quot;); List&lt;Ticket&gt; ticketList = restTemplate.postForEntity(&quot;http://localhost:666/ticket&quot;, person, List.class).getBody(); return ticketList; &#125;&#125; RestTemplate的注入： 123456789@Configurationpublic class BeanConfig &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 二. Ribbon​ Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。其主要功能是提供客户端的负载均衡算法，并提供了完善的配置项如连接超时，重试等。简单的说，就是配置文件中列出Load Balancer后面所有的机器，Ribbon会自动的基于某种规则(如简单轮询，随机连接等)去连接这些机器，当然我们也可以使用Ribbon自定义负载均衡算法。Ribbon的实现需要使用的Eureka，消费方需要在Eureka注册中心找到要调用的服务的相关信息。 2.1 配置依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 实现负载均衡​ Ribbon只是一个客户端的负载均衡器工具，实现起来非常的简单，我们只需要在注入RestTemplate的bean上加上@LoadBalanced就可以了。如下： 123456789@Configurationpublic class BeanConfig &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 2.3 启动类配置1234567@SpringBootApplication@EnableEurekaClientpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 2.4 服务的调用​ 在服务的消费方，不再采用主机名+端口的形式进行调用，而是直接采用服务名的方式进行调用。 123456789101112131415161718@RestController@RequestMapping(value=&quot;/user&quot;)public class UserController &#123; @Resource private RestTemplate restTemplate; @RequestMapping(value = &quot;/ticket/&#123;id&#125;&quot;, method = RequestMethod.GET) public Object getTicket(@PathVariable(value = &quot;id&quot;) Integer id) &#123; Person person = new Person(); person.setId(23); person.setName(&quot;张三三&quot;); // shop-provider 是服务名，不需要使用ip:端口的形式进行调用 List&lt;Ticket&gt; ticketList = restTemplate.getForObject(&quot;http://shop-provier/ticket&quot;, List.class, person); return ticketList; &#125;&#125; 2.5 负载均衡策略​ Ribbon提供了一个很重要的接口叫做IRule，其中定义了很多的负载均衡策略，默认的是轮询的方式，以下是Ribbon的负载均衡策略： 类名 描述 RoundRobinRule 轮询 RandomRule 随机挑选 RetryRule 按照轮询的方式去调用服务，如果其中某个服务不可用，但是还是会尝试几次，如果尝试过几次都没有成功，那么就不在调用该服务，会轮询调用其他的可用服务。 AvailabilityFilteringRule 会先过滤掉因为多次访问不可达和并发超过阈值的服务，然后轮询调用其他的服务 WeightedResponseTimeRule 根据平均响应时间计算权重，响应越快权重越大，越容易被选中。服务刚重启的时候，还未统计出权重会按照轮询的方式；当统计信息足够的时候，就会按照权重信息访问 ZoneAvoidanceRule 判断server所在的区域性能和可用性选择服务器 BestAvailableRule 会过滤掉多次访问都不可达的服务，然后选择并发量最小的服务进行调用，默认方式 ​ 改变Ribbon的负责均衡策略： 1234@Beanpublic IRule getRule() &#123; return new RandomRule();&#125; 2.6 自定义负载均衡策略​ 我们自定义的负载均衡策略需要继承AbstractLoadBalancerRule这个类，然后重写choose方法，然后将其注入到容器中，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Customize_Rule extends AbstractLoadBalancerRule &#123; private static Logger logger = LoggerFactory.getLogger(Customize_Rule.class); private int currentIndex = 0; //当前调用的索引 private int num = 1; //次数 private int limit = 5; /** * 初始化工作 * @param iClientConfig */ @Override public void initWithNiwsConfig(IClientConfig iClientConfig) &#123; &#125; @Override public Server choose(Object key) &#123; ILoadBalancer balancer = getLoadBalancer(); return choose(balancer, key); &#125; private Server choose(ILoadBalancer balancer, Object key) &#123; Server server = null; while(null == server) &#123; //获取所有可用的服务 List&lt;Server&gt; reachableServers = balancer.getReachableServers(); if (0 == reachableServers.size()) &#123; logger.error(&quot;没有可用的服务&quot;); return null; //退出while循环 &#125; int total = reachableServers.size(); //可用服务的数量 synchronized (this) &#123; /** * 有种极端情况，当我们在使用最后一个服务的时候，其他的服务都不可用，可能导致索引越界异常 */ if (currentIndex + 1 &gt; total) &#123; currentIndex = 0; server = reachableServers.get(currentIndex); //获取第一个服务 num = 0; num++; &#125; else &#123; if(limit == num) &#123; currentIndex++; num = 0; if(currentIndex == total) &#123; currentIndex=0; server = reachableServers.get(currentIndex); //获取第一个服务 num++; &#125;else&#123; server = reachableServers.get(currentIndex); num++; &#125; &#125;else &#123; server = reachableServers.get(currentIndex); num++; &#125; &#125; &#125; &#125; return server; &#125;&#125; ​ 将其注入到容器中，如下所示： 1234@Beanpublic IRule getRule() &#123; return new Customize_Rule();&#125; 三. Feign负载均衡​ feign是基于Ribbon的另外一个负载均衡的客户端框架，只需要在接口上定义要调用的服务名即可，使用起来非常的简单。 3.1 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 3.2 启动类的配置 ​ 需要在启动类上加上@EnableFeignClients注解即可开启feign，如下所示： 12345678@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 3.3 服务接口配置与调用方式 1234567@Service@FeignClient(name = &quot;shop-provier&quot;)public interface TicketService &#123; @RequestMapping(value = &quot;ticket&quot;, method = RequestMethod.GET) public List&lt;Ticket&gt; getAllTicket(Person person);&#125; 四. Hystrix断路器​ 分布式系统中一个微服务需要依赖于很多的其他的服务，那么服务就会不可避免的失败。例如A服务依赖于B、C、D等很多的服务，当B服务不可用的时候，会一直阻塞或者异常，更不会去调用C服务和D服务。同时假设有其他的服务也依赖于B服务，也会碰到同样的问题，这就及有可能导致雪崩效应。 ​ 如下案例：一个用户通过通过web容器访问应用，他要先后调用A、H、I、P四个模块，一切看着都很美好。 ​ 由于某些原因，导致I服务不可用，与此同时我们没有快速处理，会导致该用户一直处于阻塞状态。 ​ 当其他用户做同样的请求，也会面临着同样的问题，tomcat支持的最大并发数是有限的，资源都是有限的，将整个服务器拖垮都是有可能的。 ​ Hystrix是一个用于分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖会不可避免的调用失败，例如超时，异常等，Hystrix能保证在一个依赖出现问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。 ​ 断路器本身是一种开关装置，当某个服务单元发生故障后，通过断路器的故障监控（类似于保险丝），向调用者返回符合预期的，可处理的备选响应，而不是长时间的等待或者抛出无法处理的异常，这样就保证了服务调用的线程不会被长时间，不必要的占用，从而避免故障在分布式系统中的蔓延，乃至雪崩。 ​ Hystrix在网络依赖服务出现高延迟或者失败时，为系统提供保护和控制;可以进行快速失败，缩短延迟等待时间；提供失败回退（Fallback）和相对优雅的服务降级机制；提供有效的服务容错监控、报警和运维控制手段。 4.1 配置依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 4.2 application.yml配置123feign: hystrix: enabled: true #开启feign的熔断机制 4.3 启动类配置​ 只需要在启动类上加上@EnableCircuitBreaker注解即可，如下所示： 123456789@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableCircuitBreakerpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 4.4 接口的编写​ 在接口的@FeignClient注解中加入fallback参数，该参数为Class类型的对象，我们将该接口实现，作为服务降级后的快速响应，然后提供给fallback作为参数的值，如下所示： 1234567@Service@FeignClient(name = &quot;shop-provier&quot;, fallback = TicketServiceFallback.class)public interface TicketService &#123; @RequestMapping(value = &quot;ticket&quot;, method = RequestMethod.GET) public List&lt;Ticket&gt; getAllTicket(Person person);&#125; TicketServiceFallback是对TicketService这个接口的实现，用于在服务降级后的一个快速响应，代码如下： 12345678@Componentpublic class TicketServiceFallback implements TicketService &#123; @Override public List&lt;Ticket&gt; getAllTicket(Person person) &#123; return Arrays.asList(new Ticket()); &#125;&#125; 4.5 Hystrix监控4.5.1 配置依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 4.5.2 启动类配置​ 在启动类上加上@EnableHystrixDashboard注解，如下图所示： 12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableCircuitBreaker@EnableHystrixDashboardpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 4.5.3 编写servlet入口12345678910@Beanpublic ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean;&#125; 4.5.4 访问Hystrix Dashboard​ 在输入框中输入：http://locahost:8080/actuator/hystrix.stream]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 创建资源服务器]]></title>
    <url>%2F2013%2F05%2F10%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F096.Spring%20Security%20oAuth2-%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[创建资源服务器概述在 为什么需要 oAuth2 和 RBAC 基于角色的权限控制 章节，我们介绍过资源的概念，简单点说就是需要被访问的业务数据或是静态资源文件都可以被称作资源。 为了让大家更好的理解资源服务器的概念，我们单独创建一个名为 hello-spring-security-oauth2-resource 资源服务器的项目，该项目的主要目的就是对数据表的 CRUD 操作，而这些操作就是对资源的操作了。 操作流程 初始化资源服务器数据库 POM 所需依赖同认证服务器 配置资源服务器 配置资源(Controller) 初始化资源服务器数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849CREATE TABLE `tb_content` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `category_id` bigint(20) NOT NULL COMMENT '内容类目ID', `title` varchar(200) DEFAULT NULL COMMENT '内容标题', `sub_title` varchar(100) DEFAULT NULL COMMENT '子标题', `title_desc` varchar(500) DEFAULT NULL COMMENT '标题描述', `url` varchar(500) DEFAULT NULL COMMENT '链接', `pic` varchar(300) DEFAULT NULL COMMENT '图片绝对路径', `pic2` varchar(300) DEFAULT NULL COMMENT '图片2', `content` text COMMENT '内容', `created` datetime DEFAULT NULL, `updated` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `category_id` (`category_id`), KEY `updated` (`updated`)) ENGINE=InnoDB AUTO_INCREMENT=42 DEFAULT CHARSET=utf8;insert into `tb_content`(`id`,`category_id`,`title`,`sub_title`,`title_desc`,`url`,`pic`,`pic2`,`content`,`created`,`updated`) values (28,89,'标题','子标题','标题说明','http://www.jd.com',NULL,NULL,NULL,'2019-04-07 00:56:09','2019-04-07 00:56:11'),(29,89,'ad2','ad2','ad2','http://www.baidu.com',NULL,NULL,NULL,'2019-04-07 00:56:13','2019-04-07 00:56:15'),(30,89,'ad3','ad3','ad3','http://www.sina.com.cn',NULL,NULL,NULL,'2019-04-07 00:56:17','2019-04-07 00:56:19'),(31,89,'ad4','ad4','ad4','http://www.funtl.com',NULL,NULL,NULL,'2019-04-07 00:56:22','2019-04-07 00:56:25');CREATE TABLE `tb_content_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '类目ID', `parent_id` bigint(20) DEFAULT NULL COMMENT '父类目ID=0时，代表的是一级的类目', `name` varchar(50) DEFAULT NULL COMMENT '分类名称', `status` int(1) DEFAULT '1' COMMENT '状态。可选值:1(正常),2(删除)', `sort_order` int(4) DEFAULT NULL COMMENT '排列序号，表示同级类目的展现次序，如数值相等则按名称次序排列。取值范围:大于零的整数', `is_parent` tinyint(1) DEFAULT '1' COMMENT '该类目是否为父类目，1为true，0为false', `created` datetime DEFAULT NULL COMMENT '创建时间', `updated` datetime DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`id`), KEY `parent_id` (`parent_id`,`status`) USING BTREE, KEY `sort_order` (`sort_order`)) ENGINE=InnoDB AUTO_INCREMENT=98 DEFAULT CHARSET=utf8 COMMENT='内容分类';insert into `tb_content_category`(`id`,`parent_id`,`name`,`status`,`sort_order`,`is_parent`,`created`,`updated`) values (30,0,'LeeShop',1,1,1,'2015-04-03 16:51:38','2015-04-03 16:51:40'),(86,30,'首页',1,1,1,'2015-06-07 15:36:07','2015-06-07 15:36:07'),(87,30,'列表页面',1,1,1,'2015-06-07 15:36:16','2015-06-07 15:36:16'),(88,30,'详细页面',1,1,1,'2015-06-07 15:36:27','2015-06-07 15:36:27'),(89,86,'大广告',1,1,0,'2015-06-07 15:36:38','2015-06-07 15:36:38'),(90,86,'小广告',1,1,0,'2015-06-07 15:36:45','2015-06-07 15:36:45'),(91,86,'商城快报',1,1,0,'2015-06-07 15:36:55','2015-06-07 15:36:55'),(92,87,'边栏广告',1,1,0,'2015-06-07 15:37:07','2015-06-07 15:37:07'),(93,87,'页头广告',1,1,0,'2015-06-07 15:37:17','2015-06-07 15:37:17'),(94,87,'页脚广告',1,1,0,'2015-06-07 15:37:31','2015-06-07 15:37:31'),(95,88,'边栏广告',1,1,0,'2015-06-07 15:37:56','2015-06-07 15:37:56'),(96,86,'中广告',1,1,1,'2015-07-25 18:58:52','2015-07-25 18:58:52'),(97,96,'中广告1',1,1,0,'2015-07-25 18:59:43','2015-07-25 18:59:43'); POM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-security-oauth2-resource&lt;/artifactId&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- CP --&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;$&#123;hikaricp.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除 tomcat-jdbc 以使用 HikariCP --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.spring.security.oauth2.resource.OAuth2ResourceApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344spring: application: name: oauth2-resource datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.141.130:3306/oauth2_resource?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 hikari: minimum-idle: 5 idle-timeout: 600000 maximum-pool-size: 10 auto-commit: true pool-name: MyHikariCP max-lifetime: 1800000 connection-timeout: 30000 connection-test-query: SELECT 1security: oauth2: client: client-id: client client-secret: secret access-token-uri: http://localhost:8080/oauth/token user-authorization-uri: http://localhost:8080/oauth/authorize resource: token-info-uri: http://localhost:8080/oauth/check_tokenserver: port: 8081 servlet: context-path: /contentsmybatis: type-aliases-package: com.funtl.spring.security.oauth2.resource.domain mapper-locations: classpath:mapper/*.xmllogging: level: root: INFO org.springframework.web: INFO org.springframework.security: INFO org.springframework.security.oauth2: INFO Application12345678910111213package com.funtl.spring.security.oauth2.resource;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import tk.mybatis.spring.annotation.MapperScan;@SpringBootApplication@MapperScan(basePackages = "com.funtl.spring.security.oauth2.resource.mapper")public class OAuth2ResourceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OAuth2ResourceApplication.class, args); &#125;&#125; 关键步骤由于代码较多，可以参考我 GitHub 上的源码，下面仅列出关键步骤及代码 配置资源服务器创建一个类继承 ResourceServerConfigurerAdapter 并添加相关注解： @Configuration @EnableResourceServer：资源服务器 @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)：全局方法拦截 12345678910111213141516171819202122232425262728293031323334package com.funtl.spring.security.oauth2.resource.configure;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;@Configuration@EnableResourceServer@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http .exceptionHandling() .and() // Session 创建策略 // ALWAYS 总是创建 HttpSession // IF_REQUIRED Spring Security 只会在需要时创建一个 HttpSession // NEVER Spring Security 不会创建 HttpSession，但如果它已经存在，将可以使用 HttpSession // STATELESS Spring Security 永远不会创建 HttpSession，它不会使用 HttpSession 来获取 SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 以下为配置所需保护的资源路径及权限，需要与认证服务器配置的授权部分对应 .antMatchers("/").hasAuthority("SystemContent") .antMatchers("/view/**").hasAuthority("SystemContentView") .antMatchers("/insert/**").hasAuthority("SystemContentInsert") .antMatchers("/update/**").hasAuthority("SystemContentUpdate") .antMatchers("/delete/**").hasAuthority("SystemContentDelete"); &#125;&#125; 数据传输对象创建一个名为 ResponseResult 的通用数据传输对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package com.funtl.spring.security.oauth2.resource.dto;import lombok.Data;import java.io.Serializable;/** * 通用的返回对象 * * @param &lt;T&gt; */@Datapublic class ResponseResult&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 3468352004150968551L; /** * 状态码 */ private Integer state; /** * 消息 */ private String message; /** * 返回对象 */ private T data; public ResponseResult() &#123; super(); &#125; public ResponseResult(Integer state) &#123; super(); this.state = state; &#125; public ResponseResult(Integer state, String message) &#123; super(); this.state = state; this.message = message; &#125; public ResponseResult(Integer state, Throwable throwable) &#123; super(); this.state = state; this.message = throwable.getMessage(); &#125; public ResponseResult(Integer state, T data) &#123; super(); this.state = state; this.data = data; &#125; public ResponseResult(Integer state, String message, T data) &#123; super(); this.state = state; this.message = message; this.data = data; &#125; public Integer getState() &#123; return state; &#125; public void setState(Integer state) &#123; this.state = state; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((data == null) ? 0 : data.hashCode()); result = prime * result + ((message == null) ? 0 : message.hashCode()); result = prime * result + ((state == null) ? 0 : state.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) &#123; return true; &#125; if (obj == null) &#123; return false; &#125; if (getClass() != obj.getClass()) &#123; return false; &#125; ResponseResult&lt;?&gt; other = (ResponseResult&lt;?&gt;) obj; if (data == null) &#123; if (other.data != null) &#123; return false; &#125; &#125; else if (!data.equals(other.data)) &#123; return false; &#125; if (message == null) &#123; if (other.message != null) &#123; return false; &#125; &#125; else if (!message.equals(other.message)) &#123; return false; &#125; if (state == null) &#123; if (other.state != null) &#123; return false; &#125; &#125; else if (!state.equals(other.state)) &#123; return false; &#125; return true; &#125;&#125; Controller123456789101112131415161718192021222324package com.funtl.spring.security.oauth2.resource.controller;import com.funtl.spring.security.oauth2.resource.domain.TbContent;import com.funtl.spring.security.oauth2.resource.dto.ResponseResult;import com.funtl.spring.security.oauth2.resource.service.TbContentService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class TbContentController &#123; @Autowired private TbContentService tbContentService; @GetMapping(value = "/") public ResponseResult&lt;List&lt;TbContent&gt;&gt; list() &#123; List&lt;TbContent&gt; tbContents = tbContentService.selectAll(); return new ResponseResult&lt;List&lt;TbContent&gt;&gt;(HttpStatus.OK.value(), HttpStatus.OK.toString(), tbContents); &#125;&#125; 访问资源访问获取授权码 通过浏览器访问 1http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code 第一次访问会跳转到登录页面 验证成功后会询问用户是否授权客户端 选择授权后会跳转到百度，浏览器地址上还会包含一个授权码（code=1JuO6V），浏览器地址栏会显示如下地址： 1https://www.baidu.com/?code=1JuO6V 向服务器申请令牌 通过 CURL 或是 Postman 请求 1curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -d 'grant_type=authorization_code&amp;code=1JuO6V' "http://client:secret@localhost:8080/oauth/token" 得到响应结果如下 123456&#123; "access_token": "016d8d4a-dd6e-4493-b590-5f072923c413", "token_type": "bearer", "expires_in": 43199, "scope": "app"&#125; 携带令牌访问资源服务器此处以获取全部资源为例，其它请求方式一样，可以参考我源码中的单元测试代码。可以使用以下方式请求： 使用 Headers 方式：需要在请求头增加 Authorization: Bearer yourAccessToken 直接请求带参数方式：http://localhost:8081/contents?access_token=yourAccessToken 使用 Headers 方式，通过 CURL 或是 Postman 请求 1curl --location --request GET "http://localhost:8081/contents" --header "Content-Type: application/json" --header "Authorization: Bearer yourAccessToken"]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 基于 RBAC 的自定义认证]]></title>
    <url>%2F2013%2F05%2F09%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F095.Spring%20Security%20oAuth2-%E5%9F%BA%E4%BA%8E%20RBAC%20%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[基于 RBAC 的自定义认证概述在实际开发中，我们的用户信息都是存在数据库里的，本章节基于 RBAC 模型 将用户的认证信息与数据库对接，实现真正的用户认证与授权 操作流程 继续 基于 JDBC 存储令牌 章节的代码开发 初始化 RBAC 相关表 在数据库中配置“用户”、“角色”、“权限”相关信息 数据库操作使用 tk.mybatis 框架，故需要增加相关依赖 配置 Web 安全 配置使用自定义认证与授权 通过 GET 请求访问认证服务器获取授权码 端点：/oauth/authorize 通过 POST 请求利用授权码访问认证服务器获取令牌 端点：/oauth/token 默认的端点 URL /oauth/authorize：授权端点 /oauth/token：令牌端点 /oauth/confirm_access：用户确认授权提交端点 /oauth/error：授权服务错误信息端点 /oauth/check_token：用于资源服务访问的令牌解析端点 /oauth/token_key：提供公有密匙的端点，如果你使用 JWT 令牌的话 初始化 RBAC 相关表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970CREATE TABLE `tb_permission` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `parent_id` bigint(20) DEFAULT NULL COMMENT '父权限', `name` varchar(64) NOT NULL COMMENT '权限名称', `enname` varchar(64) NOT NULL COMMENT '权限英文名称', `url` varchar(255) NOT NULL COMMENT '授权路径', `description` varchar(200) DEFAULT NULL COMMENT '备注', `created` datetime NOT NULL, `updated` datetime NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=44 DEFAULT CHARSET=utf8 COMMENT='权限表';insert into `tb_permission`(`id`,`parent_id`,`name`,`enname`,`url`,`description`,`created`,`updated`) values (37,0,'系统管理','System','/',NULL,'2019-04-04 23:22:54','2019-04-04 23:22:56'),(38,37,'用户管理','SystemUser','/users/',NULL,'2019-04-04 23:25:31','2019-04-04 23:25:33'),(39,38,'查看用户','SystemUserView','',NULL,'2019-04-04 15:30:30','2019-04-04 15:30:43'),(40,38,'新增用户','SystemUserInsert','',NULL,'2019-04-04 15:30:31','2019-04-04 15:30:44'),(41,38,'编辑用户','SystemUserUpdate','',NULL,'2019-04-04 15:30:32','2019-04-04 15:30:45'),(42,38,'删除用户','SystemUserDelete','',NULL,'2019-04-04 15:30:48','2019-04-04 15:30:45');CREATE TABLE `tb_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `parent_id` bigint(20) DEFAULT NULL COMMENT '父角色', `name` varchar(64) NOT NULL COMMENT '角色名称', `enname` varchar(64) NOT NULL COMMENT '角色英文名称', `description` varchar(200) DEFAULT NULL COMMENT '备注', `created` datetime NOT NULL, `updated` datetime NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8 COMMENT='角色表';insert into `tb_role`(`id`,`parent_id`,`name`,`enname`,`description`,`created`,`updated`) values (37,0,'超级管理员','admin',NULL,'2019-04-04 23:22:03','2019-04-04 23:22:05');CREATE TABLE `tb_role_permission` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `role_id` bigint(20) NOT NULL COMMENT '角色 ID', `permission_id` bigint(20) NOT NULL COMMENT '权限 ID', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=43 DEFAULT CHARSET=utf8 COMMENT='角色权限表';insert into `tb_role_permission`(`id`,`role_id`,`permission_id`) values (37,37,37),(38,37,38),(39,37,39),(40,37,40),(41,37,41),(42,37,42);CREATE TABLE `tb_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(50) NOT NULL COMMENT '用户名', `password` varchar(64) NOT NULL COMMENT '密码，加密存储', `phone` varchar(20) DEFAULT NULL COMMENT '注册手机号', `email` varchar(50) DEFAULT NULL COMMENT '注册邮箱', `created` datetime NOT NULL, `updated` datetime NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`) USING BTREE, UNIQUE KEY `phone` (`phone`) USING BTREE, UNIQUE KEY `email` (`email`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8 COMMENT='用户表';insert into `tb_user`(`id`,`username`,`password`,`phone`,`email`,`created`,`updated`) values (37,'admin','$2a$10$9ZhDOBp.sRKat4l14ygu/.LscxrMUcDAfeVOEPiYwbcRkoB09gCmi','15888888888','lee.lusifer@gmail.com','2019-04-04 23:21:27','2019-04-04 23:21:29');CREATE TABLE `tb_user_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` bigint(20) NOT NULL COMMENT '用户 ID', `role_id` bigint(20) NOT NULL COMMENT '角色 ID', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8 COMMENT='用户角色表';insert into `tb_user_role`(`id`,`user_id`,`role_id`) values (37,37,37); 由于使用了 BCryptPasswordEncoder 的加密方式，故用户密码需要加密，代码如下： 1System.out.println(new BCryptPasswordEncoder().encode("123456")); POM数据库操作采用 tk.mybatis:mapper-spring-boot-starter:2.1.5 框架，需增加相关依赖，完整 POM 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-security-oauth2-server&lt;/artifactId&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- CP --&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;$&#123;hikaricp.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除 tomcat-jdbc 以使用 HikariCP --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.spring.security.oauth2.server.OAuth2ServerApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml12345678910111213141516171819202122232425spring: application: name: oauth2-server datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver jdbc-url: jdbc:mysql://192.168.141.130:3306/oauth2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 hikari: minimum-idle: 5 idle-timeout: 600000 maximum-pool-size: 10 auto-commit: true pool-name: MyHikariCP max-lifetime: 1800000 connection-timeout: 30000 connection-test-query: SELECT 1server: port: 8080mybatis: type-aliases-package: com.funtl.spring.security.oauth2.server.domain mapper-locations: classpath:mapper/*.xml Application增加了 Mapper 的包扫描配置 12345678910111213package com.funtl.spring.security.oauth2.server;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import tk.mybatis.spring.annotation.MapperScan;@SpringBootApplication@MapperScan(basePackages = "com.funtl.spring.security.oauth2.server.mapper")public class OAuth2ServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OAuth2ServerApplication.class, args); &#125;&#125; 关键步骤由于本次增加了 MyBatis 相关操作，代码增加较多，可以参考我 GitHub 上的源码，下面仅列出关键步骤及代码 获取用户信息目的是为了实现自定义认证授权时可以通过数据库查询用户信息，Spring Security oAuth2 要求使用 username 的方式查询，提供相关用户信息后，认证工作由框架自行完成 1234567891011121314151617181920212223package com.funtl.spring.security.oauth2.server.service.impl;import com.funtl.spring.security.oauth2.server.domain.TbUser;import com.funtl.spring.security.oauth2.server.mapper.TbUserMapper;import com.funtl.spring.security.oauth2.server.service.TbUserService;import org.springframework.stereotype.Service;import tk.mybatis.mapper.entity.Example;import javax.annotation.Resource;@Servicepublic class TbUserServiceImpl implements TbUserService &#123; @Resource private TbUserMapper tbUserMapper; @Override public TbUser getByUsername(String username) &#123; Example example = new Example(TbUser.class); example.createCriteria().andEqualTo("username", username); return tbUserMapper.selectOneByExample(example); &#125;&#125; 获取用户权限信息认证成功后需要给用户授权，具体的权限已经存储在数据库里了 12345678910111213package com.funtl.spring.security.oauth2.server.mapper;import com.funtl.spring.security.oauth2.server.domain.TbPermission;import org.apache.ibatis.annotations.Param;import tk.mybatis.mapper.MyMapper;import java.util.List;public interface TbPermissionMapper extends MyMapper&lt;TbPermission&gt; &#123; List&lt;TbPermission&gt; selectByUserId(@Param("id") Long id);&#125; 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.funtl.spring.security.oauth2.server.mapper.TbPermissionMapper"&gt; &lt;resultMap id="BaseResultMap" type="com.funtl.spring.security.oauth2.server.domain.TbPermission"&gt; &lt;!--@mbg.generated generated on Tue Jul 16 00:41:48 CST 2019.--&gt; &lt;id column="id" jdbcType="BIGINT" property="id" /&gt; &lt;result column="parent_id" jdbcType="BIGINT" property="parentId" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt; &lt;result column="enname" jdbcType="VARCHAR" property="enname" /&gt; &lt;result column="url" jdbcType="VARCHAR" property="url" /&gt; &lt;result column="description" jdbcType="VARCHAR" property="description" /&gt; &lt;result column="created" jdbcType="TIMESTAMP" property="created" /&gt; &lt;result column="updated" jdbcType="TIMESTAMP" property="updated" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List"&gt; &lt;!--@mbg.generated generated on Tue Jul 16 00:41:48 CST 2019.--&gt; id, parent_id, `name`, enname, url, description, created, updated &lt;/sql&gt; &lt;select id="selectByUserId" resultMap="BaseResultMap"&gt; SELECT p.* FROM tb_user AS u LEFT JOIN tb_user_role AS ur ON u.id = ur.user_id LEFT JOIN tb_role AS r ON r.id = ur.role_id LEFT JOIN tb_role_permission AS rp ON r.id = rp.role_id LEFT JOIN tb_permission AS p ON p.id = rp.permission_id WHERE u.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 自定义认证授权实现类创建一个类，实现 UserDetailsService 接口，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.funtl.spring.security.oauth2.server.configure;import com.funtl.spring.security.oauth2.server.domain.TbPermission;import com.funtl.spring.security.oauth2.server.domain.TbUser;import com.funtl.spring.security.oauth2.server.service.TbPermissionService;import com.funtl.spring.security.oauth2.server.service.TbUserService;import org.assertj.core.util.Lists;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private TbUserService tbUserService; @Autowired private TbPermissionService tbPermissionService; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; TbUser tbUser = tbUserService.getByUsername(s); List&lt;GrantedAuthority&gt; grantedAuthorities = Lists.newArrayList(); if (tbUser != null) &#123; // 声明用户授权 List&lt;TbPermission&gt; tbPermissions = tbPermissionService.selectByUserId(tbUser.getId()); tbPermissions.forEach(tbPermission -&gt; &#123; GrantedAuthority grantedAuthority = new SimpleGrantedAuthority(tbPermission.getEnname()); grantedAuthorities.add(grantedAuthority); &#125;); // 由框架完成认证工作 return new User(tbUser.getUsername(), tbUser.getPassword(), grantedAuthorities); &#125; return null; &#125;&#125; 服务器安全配置创建一个类继承 WebSecurityConfigurerAdapter 并添加相关注解： @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)：全局方法拦截 1234567891011121314151617181920212223242526272829303132333435363738394041package com.funtl.spring.security.oauth2.server.configure;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Bean public BCryptPasswordEncoder passwordEncoder() &#123; // 配置默认的加密方式 return new BCryptPasswordEncoder(); &#125; @Bean @Override protected UserDetailsService userDetailsService() &#123; return new UserDetailsServiceImpl(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; // 使用自定义认证与授权 auth.userDetailsService(userDetailsService()); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; // 将 check_token 暴露出去，否则资源服务器访问时报 403 错误 web.ignoring().antMatchers("/oauth/check_token"); &#125;&#125; 访问获取授权码 通过浏览器访问 1http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code 第一次访问会跳转到登录页面 验证成功后会询问用户是否授权客户端 选择授权后会跳转到百度，浏览器地址上还会包含一个授权码（code=1JuO6V），浏览器地址栏会显示如下地址： 1https://www.baidu.com/?code=1JuO6V 向服务器申请令牌 通过 CURL 或是 Postman 请求 1curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -d 'grant_type=authorization_code&amp;code=1JuO6V' "http://client:secret@localhost:8080/oauth/token" 得到响应结果如下 123456&#123; "access_token": "016d8d4a-dd6e-4493-b590-5f072923c413", "token_type": "bearer", "expires_in": 43199, "scope": "app"&#125; 操作成功后数据库 oauth_access_token 表中会增加一笔记录，效果图如下：]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 RBAC 基于角色的访问控制]]></title>
    <url>%2F2013%2F05%2F08%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F094.Spring%20Security%20oAuth2-RBAC%20%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[RBAC 基于角色的访问控制概述RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般是多对多的关系。（如下图） 目的在我们的 oAuth2 系统中，我们需要对系统的所有资源进行权限控制，系统中的资源包括： 静态资源（对象资源）：功能操作、数据列 动态资源（数据资源）：数据 系统的目的就是对应用系统的所有对象资源和数据资源进行权限控制，比如：功能菜单、界面按钮、数据显示的列、各种行级数据进行权限的操控 对象关系权限系统的所有权限信息。权限具有上下级关系，是一个树状的结构。如： 系统管理 用户管理 查看用户 新增用户 修改用户 删除用户 用户系统的具体操作者，可以归属于一个或多个角色，它与角色的关系是多对多的关系 角色为了对许多拥有相似权限的用户进行分类管理，定义了角色的概念，例如系统管理员、管理员、用户、访客等角色。角色具有上下级关系，可以形成树状视图，父级角色的权限是自身及它的所有子角色的权限的综合。父级角色的用户、父级角色的组同理可推。 关系图 模块图 表结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950CREATE TABLE `tb_permission` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `parent_id` bigint(20) DEFAULT NULL COMMENT '父权限', `name` varchar(64) NOT NULL COMMENT '权限名称', `enname` varchar(64) NOT NULL COMMENT '权限英文名称', `url` varchar(255) NOT NULL COMMENT '授权路径', `description` varchar(200) DEFAULT NULL COMMENT '备注', `created` datetime NOT NULL, `updated` datetime NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COMMENT='权限表';CREATE TABLE `tb_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `parent_id` bigint(20) DEFAULT NULL COMMENT '父角色', `name` varchar(64) NOT NULL COMMENT '角色名称', `enname` varchar(64) NOT NULL COMMENT '角色英文名称', `description` varchar(200) DEFAULT NULL COMMENT '备注', `created` datetime NOT NULL, `updated` datetime NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COMMENT='角色表';CREATE TABLE `tb_role_permission` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `role_id` bigint(20) NOT NULL COMMENT '角色 ID', `permission_id` bigint(20) NOT NULL COMMENT '权限 ID', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COMMENT='角色权限表';CREATE TABLE `tb_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(50) NOT NULL COMMENT '用户名', `password` varchar(64) NOT NULL COMMENT '密码，加密存储', `phone` varchar(20) DEFAULT NULL COMMENT '注册手机号', `email` varchar(50) DEFAULT NULL COMMENT '注册邮箱', `created` datetime NOT NULL, `updated` datetime NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`) USING BTREE, UNIQUE KEY `phone` (`phone`) USING BTREE, UNIQUE KEY `email` (`email`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COMMENT='用户表';CREATE TABLE `tb_user_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` bigint(20) NOT NULL COMMENT '用户 ID', `role_id` bigint(20) NOT NULL COMMENT '角色 ID', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COMMENT='用户角色表';]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 基于 JDBC 存储令牌]]></title>
    <url>%2F2013%2F05%2F07%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F093.Spring%20Security%20oAuth2-%E5%9F%BA%E4%BA%8E%20JDBC%20%E5%AD%98%E5%82%A8%E4%BB%A4%E7%89%8C%2F</url>
    <content type="text"><![CDATA[基于 JDBC 存储令牌概述本章节 基于 JDBC 存储令牌 的模式用于演示最基本的操作，帮助大家快速理解 oAuth2 认证服务器中 “认证”、”授权”、”访问令牌” 的基本概念 操作流程 初始化 oAuth2 相关表 在数据库中配置客户端 配置认证服务器 配置数据源：DataSource 配置令牌存储方式：TokenStore -&gt; JdbcTokenStore 配置客户端读取方式：ClientDetailsService -&gt; JdbcClientDetailsService 配置服务端点信息：AuthorizationServerEndpointsConfigurer tokenStore：设置令牌存储方式 配置客户端信息：ClientDetailsServiceConfigurer withClientDetails：设置客户端配置读取方式 配置 Web 安全 配置密码加密方式：BCryptPasswordEncoder 配置认证信息：AuthenticationManagerBuilder 通过 GET 请求访问认证服务器获取授权码 端点：/oauth/authorize 通过 POST 请求利用授权码访问认证服务器获取令牌 端点：/oauth/token 默认的端点 URL /oauth/authorize：授权端点 /oauth/token：令牌端点 /oauth/confirm_access：用户确认授权提交端点 /oauth/error：授权服务错误信息端点 /oauth/check_token：用于资源服务访问的令牌解析端点 /oauth/token_key：提供公有密匙的端点，如果你使用 JWT 令牌的话 初始化 oAuth2 相关表使用官方提供的建表脚本初始化 oAuth2 相关表，地址如下： 1https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql 由于我们使用的是 MySQL 数据库，默认建表语句中主键为 VARCHAR(256)，这超过了最大的主键长度，请手动修改为 128，并用 BLOB 替换语句中的 LONGVARBINARY 类型，修改后的建表脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869CREATE TABLE `clientdetails` ( `appId` varchar(128) NOT NULL, `resourceIds` varchar(256) DEFAULT NULL, `appSecret` varchar(256) DEFAULT NULL, `scope` varchar(256) DEFAULT NULL, `grantTypes` varchar(256) DEFAULT NULL, `redirectUrl` varchar(256) DEFAULT NULL, `authorities` varchar(256) DEFAULT NULL, `access_token_validity` int(11) DEFAULT NULL, `refresh_token_validity` int(11) DEFAULT NULL, `additionalInformation` varchar(4096) DEFAULT NULL, `autoApproveScopes` varchar(256) DEFAULT NULL, PRIMARY KEY (`appId`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_access_token` ( `token_id` varchar(256) DEFAULT NULL, `token` blob, `authentication_id` varchar(128) NOT NULL, `user_name` varchar(256) DEFAULT NULL, `client_id` varchar(256) DEFAULT NULL, `authentication` blob, `refresh_token` varchar(256) DEFAULT NULL, PRIMARY KEY (`authentication_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_approvals` ( `userId` varchar(256) DEFAULT NULL, `clientId` varchar(256) DEFAULT NULL, `scope` varchar(256) DEFAULT NULL, `status` varchar(10) DEFAULT NULL, `expiresAt` timestamp NULL DEFAULT NULL, `lastModifiedAt` timestamp NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_client_details` ( `client_id` varchar(128) NOT NULL, `resource_ids` varchar(256) DEFAULT NULL, `client_secret` varchar(256) DEFAULT NULL, `scope` varchar(256) DEFAULT NULL, `authorized_grant_types` varchar(256) DEFAULT NULL, `web_server_redirect_uri` varchar(256) DEFAULT NULL, `authorities` varchar(256) DEFAULT NULL, `access_token_validity` int(11) DEFAULT NULL, `refresh_token_validity` int(11) DEFAULT NULL, `additional_information` varchar(4096) DEFAULT NULL, `autoapprove` varchar(256) DEFAULT NULL, PRIMARY KEY (`client_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_client_token` ( `token_id` varchar(256) DEFAULT NULL, `token` blob, `authentication_id` varchar(128) NOT NULL, `user_name` varchar(256) DEFAULT NULL, `client_id` varchar(256) DEFAULT NULL, PRIMARY KEY (`authentication_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_code` ( `code` varchar(256) DEFAULT NULL, `authentication` blob) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_refresh_token` ( `token_id` varchar(256) DEFAULT NULL, `token` blob, `authentication` blob) ENGINE=InnoDB DEFAULT CHARSET=utf8; 在数据库中配置客户端在表 oauth_client_details 中增加一条客户端配置记录，需要设置的字段如下： client_id：客户端标识 client_secret：客户端安全码，此处不能是明文，需要加密 scope：客户端授权范围 authorized_grant_types：客户端授权类型 web_server_redirect_uri：服务器回调地址 使用 BCryptPasswordEncoder 为客户端安全码加密，代码如下： 1234567891011121314151617package com.funtl.spring.security.oauth2.server;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.test.context.junit4.SpringRunner;@SpringBootTest@RunWith(SpringRunner.class)public class OAuth2ServerApplicationTests &#123; @Test public void testBCryptPasswordEncoder() &#123; System.out.println(new BCryptPasswordEncoder().encode("secret")); &#125;&#125; 数据库配置客户端效果图如下，授权类型填入 authorization_code POM由于使用了 JDBC 存储，我们需要增加相关依赖，数据库连接池使用 HikariCP 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;$&#123;hikaricp.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除 tomcat-jdbc 以使用 HikariCP --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;&lt;/dependency&gt; application.yml123456789101112131415161718192021spring: application: name: oauth2-server datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver jdbc-url: jdbc:mysql://192.168.141.130:3306/oauth2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 hikari: minimum-idle: 5 idle-timeout: 600000 maximum-pool-size: 10 auto-commit: true pool-name: MyHikariCP max-lifetime: 1800000 connection-timeout: 30000 connection-test-query: SELECT 1server: port: 8080 Application1234567891011package com.funtl.spring.security.oauth2.server;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class OAuth2ServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OAuth2ServerApplication.class, args); &#125;&#125; 配置认证服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.funtl.spring.security.oauth2.server.configure;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.provider.ClientDetailsService;import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;import javax.sql.DataSource;@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter &#123; @Autowired private BCryptPasswordEncoder passwordEncoder; @Bean @Primary @ConfigurationProperties(prefix = "spring.datasource") public DataSource dataSource() &#123; // 配置数据源（注意，我使用的是 HikariCP 连接池），以上注解是指定数据源，否则会有冲突 return DataSourceBuilder.create().build(); &#125; @Bean public TokenStore tokenStore() &#123; // 基于 JDBC 实现，令牌保存到数据库 return new JdbcTokenStore(dataSource()); &#125; @Bean public ClientDetailsService jdbcClientDetailsService() &#123; // 基于 JDBC 实现，需要事先在数据库配置客户端信息 return new JdbcClientDetailsService(dataSource()); &#125; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; // 设置令牌存储模式 endpoints.tokenStore(tokenStore()); &#125; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; // 客户端配置 clients.withClientDetails(jdbcClientDetailsService()); &#125;&#125; 访问获取授权码 通过浏览器访问 1http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code 第一次访问会跳转到登录页面 验证成功后会询问用户是否授权客户端 选择授权后会跳转到百度，浏览器地址上还会包含一个授权码（code=1JuO6V），浏览器地址栏会显示如下地址： 1https://www.baidu.com/?code=1JuO6V 向服务器申请令牌 通过 CURL 或是 Postman 请求 1curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -d 'grant_type=authorization_code&amp;code=1JuO6V' "http://client:secret@localhost:8080/oauth/token" 得到响应结果如下 123456&#123; "access_token": "016d8d4a-dd6e-4493-b590-5f072923c413", "token_type": "bearer", "expires_in": 43199, "scope": "app"&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 基于内存存储令牌]]></title>
    <url>%2F2013%2F05%2F06%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F092.Spring%20Security%20oAuth2-%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E4%BB%A4%E7%89%8C%2F</url>
    <content type="text"><![CDATA[基于内存存储令牌概述本章节基于 内存存储令牌 的模式用于演示最基本的操作，帮助大家快速理解 oAuth2 认证服务器中 “认证”、”授权”、”访问令牌” 的基本概念 操作流程 配置认证服务器 配置客户端信息：ClientDetailsServiceConfigurer inMemory：内存配置 withClient：客户端标识 secret：客户端安全码 authorizedGrantTypes：客户端授权类型 scopes：客户端授权范围 redirectUris：注册回调地址 配置 Web 安全 通过 GET 请求访问认证服务器获取授权码 端点：/oauth/authorize 通过 POST 请求利用授权码访问认证服务器获取令牌 端点：/oauth/token 默认的端点 URL /oauth/authorize：授权端点 /oauth/token：令牌端点 /oauth/confirm_access：用户确认授权提交端点 /oauth/error：授权服务错误信息端点 /oauth/check_token：用于资源服务访问的令牌解析端点 /oauth/token_key：提供公有密匙的端点，如果你使用 JWT 令牌的话 服务器安全配置创建一个类继承 WebSecurityConfigurerAdapter 并添加相关注解： @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)：全局方法拦截 123456789101112131415161718192021222324252627282930package com.funtl.spring.security.oauth2.server.configure;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Bean public BCryptPasswordEncoder passwordEncoder() &#123; // 配置默认的加密方式 return new BCryptPasswordEncoder(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; // 在内存中创建用户 auth.inMemoryAuthentication() .withUser("user").password(passwordEncoder().encode("123456")).roles("USER") .and() .withUser("admin").password(passwordEncoder().encode("admin888")).roles("ADMIN"); &#125;&#125; 配置认证服务器创建一个类继承 AuthorizationServerConfigurerAdapter 并添加相关注解： @Configuration @EnableAuthorizationServer 12345678910111213141516171819202122232425262728293031323334package com.funtl.spring.security.oauth2.server.configure;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter &#123; @Autowired private BCryptPasswordEncoder passwordEncoder; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; // 配置客户端 clients // 使用内存设置 .inMemory() // client_id .withClient("client") // client_secret .secret(passwordEncoder.encode("secret")) // 授权类型 .authorizedGrantTypes("authorization_code") // 授权范围 .scopes("app") // 注册回调地址 .redirectUris("https://www.baidu.com"); &#125;&#125; application.yml123456spring: application: name: oauth2-serverserver: port: 8080 访问获取授权码 通过浏览器访问 1http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code 第一次访问会跳转到登录页面 验证成功后会询问用户是否授权客户端 选择授权后会跳转到百度，浏览器地址上还会包含一个授权码（code=1JuO6V），浏览器地址栏会显示如下地址： 1https://www.baidu.com/?code=1JuO6V 向服务器申请令牌 通过 CURL 或是 Postman 请求 1curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -d 'grant_type=authorization_code&amp;code=1JuO6V' "http://client:secret@localhost:8080/oauth/token" 得到响应结果如下 123456&#123; "access_token": "016d8d4a-dd6e-4493-b590-5f072923c413", "token_type": "bearer", "expires_in": 43199, "scope": "app"&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 创建认证服务器]]></title>
    <url>%2F2013%2F05%2F05%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F091.Spring%20Security%20oAuth2-%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[创建认证服务器POM创建一个名为 hello-spring-security-oauth2-server 项目，POM 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-security-oauth2-server&lt;/artifactId&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.spring.security.oauth2.server.OAuth2ServerApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Application1234567891011package com.funtl.spring.security.oauth2.server;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class OAuth2ServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OAuth2ServerApplication.class, args); &#125;&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 创建项目工程]]></title>
    <url>%2F2013%2F05%2F04%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F090.Spring%20Security%20oAuth2-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Spring Security oAuth2 创建项目工程工程创建一个名为 hello-spring-security-oauth2 工程项目，POM 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;modules&gt; &lt;module&gt;hello-spring-security-oauth2-dependencies&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-security-oauth2-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;default&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;spring-javaformat.version&gt;0.0.12&lt;/spring-javaformat.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;io.spring.javaformat&lt;/groupId&gt; &lt;artifactId&gt;spring-javaformat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-javaformat.version&#125;&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;**/*Tests.java&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/Abstract*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;systemPropertyVariables&gt; &lt;java.security.egd&gt;file:/dev/./urandom&lt;/java.security.egd&gt; &lt;java.awt.headless&gt;true&lt;/java.awt.headless&gt; &lt;/systemPropertyVariables&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;enforce-rules&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;enforce&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;rules&gt; &lt;bannedDependencies&gt; &lt;excludes&gt; &lt;exclude&gt;commons-logging:*:*&lt;/exclude&gt; &lt;/excludes&gt; &lt;searchTransitive&gt;true&lt;/searchTransitive&gt; &lt;/bannedDependencies&gt; &lt;/rules&gt; &lt;fail&gt;true&lt;/fail&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 依赖管理项目创建一个名为 hello-spring-security-oauth2-dependencies 项目，POM 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-security-oauth2-dependencies&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 客户端授权模式]]></title>
    <url>%2F2013%2F05%2F03%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F089.Spring%20Security%20oAuth2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Spring Security oAuth2 客户端授权模式概述客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。oAuth 2.0 定义了四种授权方式。 implicit：简化模式，不推荐使用 authorization code：授权码模式 resource owner password credentials：密码模式 client credentials：客户端模式 简化模式简化模式适用于纯静态页面应用。所谓纯静态页面应用，也就是应用没有在服务器上执行代码的权限（通常是把代码托管在别人的服务器上），只有前端 JS 代码的控制权。 这种场景下，应用是没有持久化存储的能力的。因此，按照 oAuth2.0 的规定，这种应用是拿不到 Refresh Token 的。其整个授权流程如下： 该模式下，access_token 容易泄露且不可刷新 授权码模式授权码模式适用于有自己的服务器的应用，它是一个一次性的临时凭证，用来换取 access_token 和 refresh_token。认证服务器提供了一个类似这样的接口： 1https://www.funtl.com/exchange?code=&amp;client_id=&amp;client_secret= 需要传入 code、client_id 以及 client_secret。验证通过后，返回 access_token 和 refresh_token。一旦换取成功，code 立即作废，不能再使用第二次。流程图如下： 这个 code 的作用是保护 token 的安全性。上一节说到，简单模式下，token 是不安全的。这是因为在第 4 步当中直接把 token 返回给应用。而这一步容易被拦截、窃听。引入了 code 之后，即使攻击者能够窃取到 code，但是由于他无法获得应用保存在服务器的 client_secret，因此也无法通过 code 换取 token。而第 5 步，为什么不容易被拦截、窃听呢？这是因为，首先，这是一个从服务器到服务器的访问，黑客比较难捕捉到；其次，这个请求通常要求是 https 的实现。即使能窃听到数据包也无法解析出内容。 有了这个 code，token 的安全性大大提高。因此，oAuth2.0 鼓励使用这种方式进行授权，而简单模式则是在不得已情况下才会使用。 密码模式密码模式中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向 “服务商提供商” 索要授权。在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分。 一个典型的例子是同一个企业内部的不同产品要使用本企业的 oAuth2.0 体系。在有些情况下，产品希望能够定制化授权页面。由于是同个企业，不需要向用户展示“xxx将获取以下权限”等字样并询问用户的授权意向，而只需进行用户的身份认证即可。这个时候，由具体的产品团队开发定制化的授权界面，接收用户输入账号密码，并直接传递给鉴权服务器进行授权即可。 有一点需要特别注意的是，在第 2 步中，认证服务器需要对客户端的身份进行验证，确保是受信任的客户端。 客户端模式如果信任关系再进一步，或者调用者是一个后端的模块，没有用户界面的时候，可以使用客户端模式。鉴权服务器直接对客户端进行身份验证，验证通过后，返回 token。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 令牌的访问与刷新]]></title>
    <url>%2F2013%2F05%2F02%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F088.Spring%20Security%20oAuth2-%E4%BB%A4%E7%89%8C%E7%9A%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[Spring Security oAuth2 令牌的访问与刷新Access TokenAccess Token 是客户端访问资源服务器的令牌。拥有这个令牌代表着得到用户的授权。然而，这个授权应该是 临时 的，有一定有效期。这是因为，Access Token 在使用的过程中 可能会泄露。给 Access Token 限定一个 较短的有效期 可以降低因 Access Token 泄露而带来的风险。 然而引入了有效期之后，客户端使用起来就不那么方便了。每当 Access Token 过期，客户端就必须重新向用户索要授权。这样用户可能每隔几天，甚至每天都需要进行授权操作。这是一件非常影响用户体验的事情。希望有一种方法，可以避免这种情况。 于是 oAuth2.0 引入了 Refresh Token 机制 Refresh TokenRefresh Token 的作用是用来刷新 Access Token。认证服务器提供一个刷新接口，例如： 1http://www.funtl.com/refresh?refresh_token=&amp;client_id= 传入 refresh_token 和 client_id，认证服务器验证通过后，返回一个新的 Access Token。为了安全，oAuth2.0 引入了两个措施： oAuth2.0 要求，Refresh Token 一定是保存在客户端的服务器上 ，而绝不能存放在狭义的客户端（例如 App、PC 端软件）上。调用 refresh 接口的时候，一定是从服务器到服务器的访问。 oAuth2.0 引入了 client_secret 机制。即每一个 client_id 都对应一个 client_secret。这个 client_secret 会在客户端申请 client_id 时，随 client_id 一起分配给客户端。客户端必须把 client_secret 妥善保管在服务器上，决不能泄露。刷新 Access Token 时，需要验证这个 client_secret。 实际上的刷新接口类似于： 1http://www.funtl.com/refresh?refresh_token=&amp;client_id=&amp;client_secret= 以上就是 Refresh Token 机制。Refresh Token 的有效期非常长，会在用户授权时，随 Access Token 一起重定向到回调 URL，传递给客户端。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 开放平台]]></title>
    <url>%2F2013%2F05%2F01%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F087.Spring%20Security%20oAuth2-%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[Spring Security oAuth2 开放平台交互模型交互模型涉及三方： 资源拥有者：用户 客户端：APP 服务提供方：包含两个角色 认证服务器 资源服务器 认证服务器认证服务器负责对用户进行认证，并授权给客户端权限。认证很容易实现（验证账号密码即可），问题在于如何授权。比如我们使用第三方登录 “有道云笔记”，你可以看到如使用 QQ 登录的授权页面上有 “有道云笔记将获得以下权限” 的字样以及权限信息 认证服务器需要知道请求授权的客户端的身份以及该客户端请求的权限。我们可以为每一个客户端预先分配一个 id，并给每个 id 对应一个名称以及权限信息。这些信息可以写在认证服务器上的配置文件里。然后，客户端每次打开授权页面的时候，把属于自己的 id 传过来，如： 1http://www.funtl.com/login?client_id=yourClientId 随着时间的推移和业务的增长，会发现，修改配置的工作消耗了太多的人力。有没有办法把这个过程自动化起来，把人工从这些繁琐的操作中解放出来？当开始考虑这一步，开放平台的成型也就是水到渠成的事情了。 oAuth2 开放平台开放平台是由 oAuth2.0 协议衍生出来的一个产品。它的作用是让客户端自己去这上面进行注册、申请，通过之后系统自动分配 client_id ，并完成配置的自动更新（通常是写进数据库）。 客户端要完成申请，通常需要填写客户端程序的类型（Web、App 等）、企业介绍、执照、想要获取的权限等等信息。这些信息在得到服务提供方的人工审核通过后，开发平台就会自动分配一个 client_id 给客户端了。 到这里，已经实现了登录认证、授权页的信息展示。那么接下来，当用户成功进行授权之后，认证服务器需要把产生的 access_token 发送给客户端，方案如下： 让客户端在开放平台申请的时候，填写一个 URL，例如：http://www.funtl.com 每次当有用户授权成功之后，认证服务器将页面重定向到这个 URL（回调），并带上 access_token，例如：http://www.funtl.com?access_token=123456789 客户端接收到了这个 access_token，而且认证服务器的授权动作已经完成，刚好可以把程序的控制权转交回客户端，由客户端决定接下来向用户展示什么内容]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security oAuth2 简介]]></title>
    <url>%2F2013%2F04%2F30%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay67_Spring%20Security%20oAuth2%2F086.Spring%20Security%20oAuth2-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Spring Security oAuth2 简介概述本章节的目的是帮助大家快速上手使用 Spring 提供的 Spring Security oAuth2 搭建一套验证授权及资源访问服务，帮助大家在实现企业微服务架构时能够有效的控制多个服务的统一登录、授权及资源保护工作 什么是 oAuthoAuth 协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是 oAuth 的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此 oAuth 是安全的。 什么是 Spring SecuritySpring Security 是一个安全框架，前身是 Acegi Security，能够为 Spring 企业应用系统提供声明式的安全访问控制。Spring Security 基于 Servlet 过滤器、IoC 和 AOP，为 Web 请求和方法调用提供身份确认和授权处理，避免了代码耦合，减少了大量重复代码工作。 为什么需要 oAuth2应用场景我们假设你有一个“云笔记”产品，并提供了“云笔记服务”和“云相册服务”，此时用户需要在不同的设备（PC、Android、iPhone、TV、Watch）上去访问这些“资源”（笔记，图片） 那么用户如何才能访问属于自己的那部分资源呢？此时传统的做法就是提供自己的账号和密码给我们的“云笔记”，登录成功后就可以获取资源了。但这样的做法会有以下几个问题： “云笔记服务”和“云相册服务”会分别部署，难道我们要分别登录吗？ 如果有第三方应用程序想要接入我们的“云笔记”，难道需要用户提供账号和密码给第三方应用程序，让他记录后再访问我们的资源吗？ 用户如何限制第三方应用程序在我们“云笔记”的授权范围和使用期限？难道把所有资料都永久暴露给它吗？ 如果用户修改了密码收回了权限，那么所有第三方应用程序会全部失效。 只要有一个接入的第三方应用程序遭到破解，那么用户的密码就会泄露，后果不堪设想。 为了解决如上问题，oAuth 应用而生。 名词解释 第三方应用程序（Third-party application）： 又称之为客户端（client），比如上节中提到的设备（PC、Android、iPhone、TV、Watch），我们会在这些设备中安装我们自己研发的 APP。又比如我们的产品想要使用 QQ、微信等第三方登录。对我们的产品来说，QQ、微信登录是第三方登录系统。我们又需要第三方登录系统的资源（头像、昵称等）。对于 QQ、微信等系统我们又是第三方应用程序。 HTTP 服务提供商（HTTP service）： 我们的云笔记产品以及 QQ、微信等都可以称之为“服务提供商”。 资源所有者（Resource Owner）： 又称之为用户（user）。 用户代理（User Agent）： 比如浏览器，代替用户去访问这些资源。 认证服务器（Authorization server）： 即服务提供商专门用来处理认证的服务器，简单点说就是登录功能（验证用户的账号密码是否正确以及分配相应的权限） 资源服务器（Resource server）： 即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。简单点说就是资源的访问入口，比如上节中提到的“云笔记服务”和“云相册服务”都可以称之为资源服务器。 交互过程oAuth 在 “客户端” 与 “服务提供商” 之间，设置了一个授权层（authorization layer）。”客户端” 不能直接登录 “服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端” 登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。”客户端” 登录授权层以后，”服务提供商” 根据令牌的权限范围和有效期，向 “客户端” 开放用户储存的资料。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Dubbo 外部化配置]]></title>
    <url>%2F2013%2F04%2F29%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay63_Spring%20Cloud%20Alibaba%20Dubbo%2F064.Spring%20Cloud%20Alibaba-Dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Dubbo 外部化配置概述由于我们已经使用了 Nacos Server 作为我们的注册中心，所以此处依然使用 Nacos Config 实现 Dubbo 的外部化配置 接入配置中心POM我们以 dubbo-consumer 项目为例，修改 pom.xml ，引入 Nacos Config Starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; Controller完成上述两步后，应用会从 Nacos Config 中获取相应的配置，并添加在 Spring Environment 的 PropertySources 中。这里我们使用 @Value 注解来将对应的配置注入到 EchoController 的 username字段，并添加 @RefreshScope 打开动态刷新功能 12345678910111213141516171819202122232425package com.funtl.apache.dubbo.consumer.controller;import com.funtl.apache.dubbo.provider.api.EchoService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RefreshScope@RestControllerpublic class EchoController &#123; @Reference(version = "1.0.0") private EchoService echoService; @Value("$&#123;user.name&#125;") private String username; @GetMapping(value = "/echo/&#123;string&#125;") public String echo(@PathVariable String string) &#123; return echoService.echo(string) + " " + username; &#125;&#125; 使用控制台发布配置 注意： Data ID 的默认扩展名为 .properties ，希望使用 YAML 配置，此处必须指明是 .yaml 12345678910111213141516171819202122232425262728293031323334spring: application: name: dubbo-consumer main: allow-bean-definition-overriding: truedubbo: scan: base-packages: com.funtl.apache.dubbo.consumer.controller protocol: name: dubbo port: -1 serialization: kryo registry: address: nacos://192.168.141.132:8848server: port: 8080endpoints: dubbo: enabled: truemanagement: health: dubbo: status: defaults: memory extras: threadpool endpoints: web: exposure: include: "*"user: name: "唯我成幸" 修改客户端配置创建名为 bootstrap.properties 的配置文件并删除之前创建的 application.yml 配置文件 123spring.application.name=dubbo-consumer-configspring.cloud.nacos.config.server-addr=192.168.141.132:8848spring.cloud.nacos.config.file-extension=yaml 通过浏览器访问 http://localhost:8080/echo/hi ，浏览器输出如下 1Echo Hello Dubbo hi i am from port: -1 唯我成幸 动态刷新配置在 Nacos Server 控制台修改配置文件，将 user.name 属性修改为 桐须真冬，此时观察控制台日志，你会发现我们已经成功刷新了配置 验证是否成功通过浏览器访问 http://localhost:8080/echo/hi ，浏览器输出如下 1Echo Hello Dubbo hi i am from port: -1 桐须真冬 提示： 你可以使用 spring.cloud.nacos.config.refresh.enabled=false 来关闭动态刷新]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Dubbo 负载均衡]]></title>
    <url>%2F2013%2F04%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay63_Spring%20Cloud%20Alibaba%20Dubbo%2F063.Spring%20Cloud%20Alibaba-Dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[Dubbo 负载均衡概述在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。 负载均衡策略随机Random LoadBalance： 按权重设置随机概率，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 轮循RoundRobin LoadBalance： 按公约后的权重设置轮询比率，存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 最少活跃调用数LeastActive LoadBalance： 相同活跃数的随机，活跃数指调用前后计数差，使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。 一致性 HashConsistentHash LoadBalance： 相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 算法参见：http://en.wikipedia.org/wiki/Consistent_hashing ，缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;，缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt; 配置负载均衡 修改 dubbo-provider 项目的负载均衡策略，默认的负载均衡策略是 随机，我们修改为 轮循，可配置的值分别是：random，roundrobin，leastactive，consistenthash 123dubbo: provider: loadbalance: roundrobin 修改 dubbo-provider 的协议端口为 20880 和 20881，并启动多个实例，IDEA 中依次点击 Run -&gt; Edit Configurations 并勾选 Allow parallel run 以允许 IDEA 多实例运行项目 Nacos Server 控制台可以看到 dubbo-provider 有 2 个实例 修改 dubbo-provider 项目的 EchoServiceImpl 中的测试方法 1234567891011121314151617package com.funtl.apache.dubbo.provider.service;import com.funtl.apache.dubbo.provider.api.EchoService;import org.apache.dubbo.config.annotation.Service;import org.springframework.beans.factory.annotation.Value;@Service(version = "1.0.0")public class EchoServiceImpl implements EchoService &#123; @Value("$&#123;dubbo.protocol.port&#125;") private String port; @Override public String echo(String string) &#123; return "Echo Hello Dubbo " + string + " i am from port: " + port; &#125;&#125; 重启服务，通过浏览器访问 http://localhost:8080/echo/hi ，反复刷新浏览器，浏览器交替显示 12Echo Hello Dubbo hi i am from port: 20880Echo Hello Dubbo hi i am from port: 20881]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Dubbo 实现高速序列化]]></title>
    <url>%2F2013%2F04%2F27%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay63_Spring%20Cloud%20Alibaba%20Dubbo%2F062.Spring%20Cloud%20Alibaba-Dubbo-%E5%AE%9E%E7%8E%B0%E9%AB%98%E9%80%9F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Dubbo 实现高速序列化Dubbo 中的序列化Dubbo RPC 是 Dubbo 体系中最核心的一种高性能、高吞吐量的远程调用方式，可以称之为多路复用的 TCP 长连接调用： 长连接： 避免了每次调用新建 TCP 连接，提高了调用的响应速度 多路复用： 单个 TCP 连接可交替传输多个请求和响应的消息，降低了连接的等待闲置时间，从而减少了同样并发数下的网络连接数，提高了系统吞吐量 Dubbo RPC 主要用于两个 Dubbo 系统之间的远程调用，特别适合高并发、小数据的互联网场景。而序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等同样也起着至关重要的作用，是我们提升分布式系统性能的最关键因素之一。 Dubbo 中支持的序列化方式： dubbo 序列化： 阿里尚未开发成熟的高效 Java 序列化实现，阿里不建议在生产环境使用它 hessian2 序列化： hessian 是一种跨语言的高效二进制序列化方式。但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式 json 序列化： 目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自己实现的简单 json 库，但其实现都不是特别成熟，而且 json 这种文本序列化性能一般不如上面两种二进制序列化。 java 序列化： 主要是采用 JDK 自带的 Java 序列化实现，性能很不理想。 在通常情况下，这四种主要序列化方式的性能从上到下依次递减。对于 dubbo RPC 这种追求高性能的远程调用方式来说，实际上只有 1、2 两种高效序列化方式比较般配，而第 1 个 dubbo 序列化由于还不成熟，所以实际只剩下 2 可用，所以 dubbo RPC 默认采用 hessian2 序列化。 但 hessian 是一个比较老的序列化实现了，而且它是跨语言的，所以不是单独针对 Java 进行优化的。而 dubbo RPC 实际上完全是一种 Java to Java 的远程调用，其实没有必要采用跨语言的序列化方式（当然肯定也不排斥跨语言的序列化）。 最近几年，各种新的高效序列化方式层出不穷，不断刷新序列化性能的上限，最典型的包括： 专门针对 Java 语言的：Kryo，FST 等等 跨语言的：Protostuff，ProtoBuf，Thrift，Avro，MsgPack 等等 这些序列化方式的性能多数都显著优于 hessian2（甚至包括尚未成熟的 dubbo 序列化），有鉴于此，我们为 dubbo 引入 Kryo 和 FST 这两种高效 Java 序列化实现，来逐步取代 hessian2。 其中，Kryo 是一种非常成熟的序列化实现，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。而 FST 是一种较新的序列化实现，目前还缺乏足够多的成熟使用案例。 注意： 在面向生产环境的应用中，目前更优先选择 Kryo 启用 Kryo在 Provider 和 Consumer 项目启用 Kryo 高速序列化功能，两个项目的配置方式相同 POM增加 org.apache.dubbo:dubbo-serialization-kryo 依赖 123456789&lt;properties&gt; &lt;dubbo-kryo.version&gt;2.7.2&lt;/dubbo-kryo.version&gt;&lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-serialization-kryo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo-kryo.version&#125;&lt;/version&gt;&lt;/dependency&gt; application.yml增加 dubbo.protocol.serialization=kryo 配置 123dubbo: protocol: serialization: kryo 序列化类说明 注意： 想要使用 Kryo 序列化只需要 DTO/Domain/Entity 这类传输对象实现序列化接口即可，无需额外再做配置，如：public class User implements Serializable{} 在对一个类做序列化的时候，可能还级联引用到很多类，比如 Java 集合类。针对这种情况，Dubbo 已经自动将 JDK 中的常用类进行了注册，包括： 123456789101112131415161718192021222324252627282930GregorianCalendarInvocationHandlerBigDecimalBigIntegerPatternBitSetURIUUIDHashMapArrayListLinkedListHashSetTreeSetHashtableDateCalendarConcurrentHashMapSimpleDateFormatVectorBitSetStringBufferStringBuilderObjectObject[]String[]byte[]char[]int[]float[]double[] 由于注册被序列化的类仅仅是出于性能优化的目的，所以即使你忘记注册某些类也没有关系。事实上，即使不注册任何类，Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。 附：扩展阅读序列化性能分析与测试测试环境 两台独立服务器 4 核 Intel(R) Xeon(R) CPU E5-2603 0 @ 1.80GHz 8G 内存 虚拟机之间网络通过百兆交换机 CentOS 5 JDK 7 Tomcat 7 JVM 参数 -server -Xms1g -Xmx1g -XX:PermSize=64M -XX:+UseConcMarkSweepGC 注意： 当然这个测试环境较有局限，故当前测试结果未必有非常权威的代表性 测试脚本和 dubbo 自身的基准测试保持接近，10 个并发客户端持续不断发出请求： 传入嵌套复杂对象（但单个数据量很小），不做任何处理，原样返回 传入 50K 字符串，不做任何处理，原样返回（TODO：结果尚未列出） 进行 5 分钟性能测试。（引用 dubbo 自身测试的考虑：“主要考察序列化和网络 IO 的性能，因此服务端无任何业务逻辑。取 10 并发是考虑到 HTTP 协议在高并发下对 CPU 的使用率较高可能会先达到瓶颈。”） Dubbo RPC 中不同序列化生成字节大小比较序列化生成字节码的大小是一个比较有确定性的指标，它决定了远程调用的网络传输时间和带宽占用。针对复杂对象的结果如下（数值越小越好）： Dubbo RPC 中不同序列化响应时间和吞吐量对比 结论就目前结果而言，我们可以看到不管从生成字节的大小，还是平均响应时间和平均 TPS，Kryo 和 FST 相比 Dubbo RPC 中原有的序列化方式都有非常显著的改进。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Dubbo 服务注册与发现]]></title>
    <url>%2F2013%2F04%2F26%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay63_Spring%20Cloud%20Alibaba%20Dubbo%2F061.Spring%20Cloud%20Alibaba-Dubbo-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Dubbo 服务注册与发现概述由于我们已经有了 Nacos 注册中心，Sentinel 熔断限流控制中心，所以我们不再使用 Zookeeper 和 Dubbo Admin 来管理我们的 Dubbo 应用程序，Dubbo 仅当作我们微服务中的 RPC 通信框架，真正实现对内 RPC，对外 REST 创建服务提供者POM创建一个名为 hello-apache-dubbo-provider 的服务提供者项目，pom.xml 配置如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-apache-dubbo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-apache-dubbo-provider&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;modules&gt; &lt;module&gt;hello-apache-dubbo-provider-api&lt;/module&gt; &lt;module&gt;hello-apache-dubbo-provider-service&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 创建服务提供者接口模块POM创建一个名为 hello-apache-dubbo-provider-api 的模块（该模块只负责定义接口），pom.xml 配置如下： 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-apache-dubbo-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-apache-dubbo-provider-api&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt;&lt;/project&gt; 定义接口12345package com.funtl.apache.dubbo.provider.api;public interface EchoService &#123; String echo(String string);&#125; 创建服务提供者接口实现POM创建一个名为 hello-apache-dubbo-provider-service 的模块，pom.xml 配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-apache-dubbo-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-apache-dubbo-provider-service&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Apache Dubbo Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Apache Dubbo End --&gt; &lt;!-- Projects Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-apache-dubbo-provider-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Projects End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.apache.dubbo.provider.ProviderApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml主要增加了 Dubbo 包扫描路径和 Nacos Server 配置 1234567891011121314spring: application: name: dubbo-provider main: allow-bean-definition-overriding: truedubbo: scan: base-packages: com.funtl.apache.dubbo.provider.service protocol: name: dubbo port: -1 registry: address: nacos://192.168.141.132:8848 Application1234567891011package com.funtl.apache.dubbo.provider;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApplication.class, args); &#125;&#125; Service通过 org.apache.dubbo 包下的 @Service 注解将服务暴露出去 123456789101112package com.funtl.apache.dubbo.provider.service;import com.funtl.apache.dubbo.provider.api.EchoService;import org.apache.dubbo.config.annotation.Service;@Service(version = "1.0.0")public class EchoServiceImpl implements EchoService &#123; @Override public String echo(String string) &#123; return "Echo Hello Dubbo " + string; &#125;&#125; 验证是否成功通过浏览器访问 http://192.168.141.132:8848/nacos Nacos Server 网址 你会发现一个服务已经注册在服务中了，服务名为 providers:com.funtl.apache.dubbo.provider.api.EchoService:1.0.0: 创建服务消费者POM创建一个名为 hello-apache-dubbo-consumer 的服务消费者项目，pom.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-apache-dubbo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-apache-dubbo-consumer&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Apache Dubbo Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo-registry-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Apache Dubbo End --&gt; &lt;!-- Projects Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-apache-dubbo-provider-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Projects End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.apache.dubbo.consumer.ConsumerApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml主要增加了 Dubbo 包扫描路径、健康检查以及 Nacos Server 配置 12345678910111213141516171819202122232425262728293031spring: application: name: dubbo-consumer main: allow-bean-definition-overriding: truedubbo: scan: base-packages: com.funtl.apache.dubbo.consumer.controller protocol: name: dubbo port: -1 registry: address: nacos://192.168.141.132:8848server: port: 8080endpoints: dubbo: enabled: truemanagement: health: dubbo: status: defaults: memory extras: threadpool endpoints: web: exposure: include: "*" Application1234567891011package com.funtl.apache.dubbo.consumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; Controller通过 org.apache.dubbo 包下的 @Reference 注解像调用本地服务一样调用远程服务，轻松实现透明的远程过程调用 12345678910111213141516171819package com.funtl.apache.dubbo.consumer.controller;import com.funtl.apache.dubbo.provider.api.EchoService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class EchoController &#123; @Reference(version = "1.0.0") private EchoService echoService; @GetMapping(value = "/echo/&#123;string&#125;") public String echo(@PathVariable String string) &#123; return echoService.echo(string); &#125;&#125; 验证是否成功通过浏览器访问 http://192.168.141.132:8848/nacos Nacos Server 网址 你会发现一个服务已经注册在服务中了，服务名为 consumers:com.funtl.apache.dubbo.provider.api.EchoService:1.0.0:，通过浏览器访问 http://localhost:8080/echo/hi 1Echo Hello Dubbo hi 服务端点检查通过浏览器访问 http://localhost:8080/actuator/health 123&#123; "status": "UP"&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Dubbo 创建统一的依赖管理]]></title>
    <url>%2F2013%2F04%2F25%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay63_Spring%20Cloud%20Alibaba%20Dubbo%2F060.Spring%20Cloud%20Alibaba-Dubbo-%E5%88%9B%E5%BB%BA%E7%BB%9F%E4%B8%80%E7%9A%84%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[创建统一的依赖管理POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-apache-dubbo-dependencies&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.7.2&lt;/dubbo.version&gt; &lt;dubbo-actuator.version&gt;2.7.1&lt;/dubbo-actuator.version&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;spring-cloud-alibaba.verion&gt;0.9.0.RELEASE&lt;/spring-cloud-alibaba.verion&gt; &lt;alibaba-spring-context-support.version&gt;1.0.2&lt;/alibaba-spring-context-support.version&gt; &lt;/properties&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.verion&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-actuator&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo-actuator.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;alibaba-spring-context-support.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Dubbo 创建项目工程]]></title>
    <url>%2F2013%2F04%2F24%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay63_Spring%20Cloud%20Alibaba%20Dubbo%2F059.Spring%20Cloud%20Alibaba-Dubbo-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[创建项目工程POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-apache-dubbo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;modules&gt; &lt;module&gt;hello-apache-dubbo-dependencies&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-apache-dubbo-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;default&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;spring-javaformat.version&gt;0.0.12&lt;/spring-javaformat.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;io.spring.javaformat&lt;/groupId&gt; &lt;artifactId&gt;spring-javaformat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-javaformat.version&#125;&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;**/*Tests.java&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/Abstract*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;systemPropertyVariables&gt; &lt;java.security.egd&gt;file:/dev/./urandom&lt;/java.security.egd&gt; &lt;java.awt.headless&gt;true&lt;/java.awt.headless&gt; &lt;/systemPropertyVariables&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;enforce-rules&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;enforce&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;rules&gt; &lt;bannedDependencies&gt; &lt;excludes&gt; &lt;exclude&gt;commons-logging:*:*&lt;/exclude&gt; &lt;/excludes&gt; &lt;searchTransitive&gt;true&lt;/searchTransitive&gt; &lt;/bannedDependencies&gt; &lt;/rules&gt; &lt;fail&gt;true&lt;/fail&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo 简介]]></title>
    <url>%2F2013%2F04%2F23%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay63_Spring%20Cloud%20Alibaba%20Dubbo%2F058.Spring%20Cloud%20Alibaba-Dubbo-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Dubbo 简介什么是 DubboApache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源 Java RPC 分布式服务框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。她最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。 备注： 2019 年 5 月 21 日 Apache 软件基金会发表博文，宣布 Dubbo 在 2019 年 5 月 20 日 这天正式毕业，成为 Apache 的顶级项目。 官方网站 官方 GitHub Dubbo 架构 节点角色说明 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动，加载，运行服务提供者 服务提供者在启动时，向注册中心注册自己提供的服务 服务消费者在启动时，向注册中心订阅自己所需的服务 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 Dubbo 功能特点 面向接口代理的高性能 RPC 调用： 提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节 智能负载均衡： 内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量 服务自动注册与发现： 支持多种注册中心服务，服务实例上下线实时感知 高度可扩展能力： 遵循微内核 + 插件的设计原则，所有核心能力如 Protocol、Transport、Serialization 被设计为扩展点，平等对待内置实现和第三方实现 运行期流量调度： 内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能 可视化的服务治理与运维： 提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数 附：扩展阅读什么是 RPC分布式是促使 RPC 诞生的领域，RPC 是一种编程模型，并没有规定你具体要怎样实现，无论使用 HTTP 或是 RMI 都是可以的。 假设你有一个计算器接口，Calculator，以及它的实现类 CalculatorImpl，那么在系统还是 单体应用 时，你要调用 Calculator 的 add 方法来执行一个加运算，直接 new 一个 CalculatorImpl，然后调用 add 方法就行了，这其实就是非常普通的 本地函数调用，因为在 同一个地址空间，或者说在同一块内存，所以通过方法栈和参数栈就可以实现。 现在，基于高性能和高可靠等因素的考虑，你决定将系统改造为分布式应用，将很多可以共享的功能都单独拎出来，比如上面说到的计算器，你单独把它放到一个服务里头，让别的服务去调用它。 这下问题来了，服务 A 里头并没有 CalculatorImpl 这个类，那它要怎样调用服务 B 的 CalculatorImpl 的 add 方法呢？ RPC 要解决的两个问题 解决分布式系统中，服务之间的调用问题 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑 如何实现一个 RPC实际情况下，RPC 很少用到 HTTP 协议来进行数据传输，毕竟我只是想传输一下数据而已，何必动用到一个文本传输的应用层协议呢，我为什么不直接使用二进制传输？比如直接用 Java 的 Socket 协议进行传输？ 不管你用何种协议进行数据传输，一个完整的 RPC 过程，都可以用下面这张图来描述 以左边的 Client 端为例，Application 就是 RPC 的调用方，Client Stub 就是我们上面说到的代理对象，也就是那个看起来像是 Calculator 的实现类，其实内部是通过 RPC 方式来进行远程调用的代理对象，至于 Client Run-time Library，则是实现远程调用的工具包，比如 JDK 的 Socket，最后通过底层网络实现实现数据的传输。 这个过程中最重要的就是 序列化 和 反序列化 了，因为数据传输的数据包必须是二进制的，你直接丢一个 Java 对象过去，人家可不认识，你必须把 Java 对象序列化为二进制格式，传给 Server 端，Server 端接收到之后，再反序列化为 Java 对象。 RPC vs RestfulRPC 是面向过程，Restful 是面向资源，并且使用了 HTTP 动词。从这个维度上看，Restful 风格的 URL 在表述的精简性、可读性上都要更好。 阿里为何放弃 ZookeeperCAP 有个思考，从 CAP 角度考虑，服务注册中心是 CP 系统还是 AP 系统呢？ 服务注册中心是为了服务间调用服务的，那么绝对不允许因为服务注册中心出现了问题而导致服务间的调用出问题 假如有 node1，node2，node3 集群节点。保存着可用服务列表 ip1，ip2，ip3，试想如果此时不一致，比如 node1 只保存了ip1，ip2，此时服务读取 node1 的节点，那么会造成什么影响？ 调用 node1 的服务，顶多就是负载均衡时不会有流量打到 ip3，然后等 node1 同步回 ip3 后，又一致了，这对服务其实没什么太大影响。所以，推测出服务注册中心应该是个 AP 系统。 Zookeeper 是个 CP 系统，强一致性 场景1，当 master 挂了，此时 Zookeeper 集群需要重新选举，而此时服务需要来读取可用服务，是不可用的。影响到了服务的可用性当然你可以说服务本地有缓存可用列表。然而下面这种方式就更无法处理了。 场景2，分区可用。试想，有 3 个机房，如果其中机房 3 和机房 1，2 网络断了，那么机房 3 的注册中心就不能注册新的机器了，这显然也不合理从健康检查角度来看 Zookeeper 是通过 TCP 的心跳判断服务是否可用，但 TCP 的活性并不代表服务是可用的，如：连接池已满，DB 挂了等 理想的注册中心 服务自动注册发现。最好有新的服务注册上去时还能推送到调用端 能对注册上来的机器方便的进行管理，能手动删除（发送信号让服务优雅下线）、恢复机器 服务的健康检查，能真正的检测到服务是否可用 可以看到是否有其他调用服务正在订阅注册上来的服务 能够带上些除了 IP 外的其它信息]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sentinel 客户端接入]]></title>
    <url>%2F2013%2F04%2F22%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F057.Spring%20Cloud%20Alibaba-Sentinel-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Sentinel 客户端接入POM如果要在您的项目中引入 Sentinel，需要增加 org.springframework.cloud:spring-cloud-starter-alibaba-sentinel Starter POM 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置文件在 Nacos 控制台修改配置文件，增加对 Sentinel 的支持 1234567891011121314151617181920212223242526272829303132333435spring: application: # 服务名 name: service-consumer cloud: nacos: discovery: # 服务注册中心 server-addr: 192.168.141.132:8848 config: # 服务配置中心 server-addr: 192.168.141.132:8848 # 熔断限流 sentinel: transport: dashboard: localhost:8888# 开启 Feign 对 Sentinel 的支持feign: sentinel: enabled: trueserver: # 服务端口 port: 8080management: # 端点检查（健康检查） endpoints: web: exposure: include: "*"user: name: "灶门祢豆子" 配置熔断类编写一个 Feign 接口的实现类并增加 @Component 注解 123456789101112131415161718package com.funtl.spring.cloud.alibaba.consumer.service.fallback;import com.funtl.spring.cloud.alibaba.consumer.service.EchoService;import org.springframework.stereotype.Component;@Componentpublic class EchoServiceFallback implements EchoService &#123; @Override public String echo(String string) &#123; return "echo fallback"; &#125; @Override public String lb() &#123; return "lb fallback"; &#125;&#125; 修改 Feign 接口在 @FeignClient 接口上增加 fallback 属性指定熔断类即可 12345678910111213141516package com.funtl.spring.cloud.alibaba.consumer.service;import com.funtl.spring.cloud.alibaba.consumer.service.fallback.EchoServiceFallback;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(value = "service-provider", fallback = EchoServiceFallback.class)public interface EchoService &#123; @GetMapping(value = "/echo/&#123;string&#125;") String echo(@PathVariable("string") String string); @GetMapping(value = "/lb") String lb();&#125; 测试熔断启动 service-consumer 服务并停止 service-provider 服务，通过浏览器访问 http://localhost:8080/feign/echo/hi 1echo fallback 注意： 必须至少请求过一次才能在 Sentinel 控制台看到对应的服务]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sentinel 控制台]]></title>
    <url>%2F2013%2F04%2F21%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F056.Spring%20Cloud%20Alibaba-Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[Sentinel 控制台概述Sentinel 提供一个轻量级的开源控制台，它提供机器发现以及健康情况管理、监控（单机和集群），规则管理和推送的功能。另外，鉴权在生产环境中也必不可少。这里，我们将会详细讲述如何通过简单的步骤就可以使用这些功能。Sentinel 控制台最少应该包含如下功能 查看机器列表以及健康情况： 收集 Sentinel 客户端发送的心跳包，用于判断机器是否在线。 监控 (单机和集群聚合)： 通过 Sentinel 客户端暴露的监控 API，定期拉取并且聚合应用监控信息，最终可以实现秒级的实时监控。 规则管理和推送： 统一管理推送规则。 鉴权： 生产环境中鉴权非常重要。这里每个开发者需要根据自己的实际情况进行定制。 启动控制台获取您可以从 官方 GitHub Release 页面 页面下载最新版本的控制台 JAR 包。 启动 注意： 启动 Sentinel 控制台需要 JDK 版本为 1.8 及以上版本 1java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar 其中 -Dserver.port=8080 用于指定 Sentinel 控制台端口为 8080 注意： 从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的 登录 功能，默认用户名和密码都是 sentinel 鉴权用户可以通过如下参数进行配置 -Dsentinel.dashboard.auth.username=sentinel 用于指定控制台的登录用户名为 sentinel -Dsentinel.dashboard.auth.password=123456 用于指定控制台的登录密码为 123456；如果省略这两个参数，默认用户和密码均为 sentinel -Dserver.servlet.session.timeout=7200 用于指定 Spring Boot 服务端 session 的过期时间，如 7200 表示 7200 秒；60m 表示 60 分钟，默认为 30 分钟 验证安装是否成功通过浏览器访问 http://localhost:8080/#/login 账号： sentinel 密码： sentinel 详细说明请参考 官方 Sentinel Wiki]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sentinel 分布式系统的流量防卫兵]]></title>
    <url>%2F2013%2F04%2F20%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F055.Spring%20Cloud%20Alibaba-Sentinel-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B5%81%E9%87%8F%E9%98%B2%E5%8D%AB%E5%85%B5%2F</url>
    <content type="text"><![CDATA[Sentinel 分布式系统的流量防卫兵什么是服务雪崩在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以通过 HTTP/RPC 相互调用，在 Spring Cloud 中可以用 RestTemplate + LoadBalanceClient 和 Feign 来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证 100% 可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet 容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的 “雪崩” 效应。为了解决这个问题，业界提出了 熔断器模型。 阿里巴巴开源了 Sentinel 组件，实现了熔断器模式，Spring Cloud 对这一组件进行了整合。在微服务架构中，一个请求需要调用多个服务是非常常见的 较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值熔断器将会被打开 熔断器打开后，为了避免连锁故障，通过 fallback 方法可以直接返回一个固定值。 什么是 Sentinel随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Sentinel 的特征 丰富的应用场景： Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷（对于突然到来的大量请求，您可以配置流控规则，以稳定的速度逐步处理这些请求，从而避免流量突刺造成系统负载过高）、集群流量控制、实时熔断下游不可用应用等 完备的实时监控： Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况 广泛的开源生态： Sentinel 提供开箱即用的与其它开源框架 / 库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel 完善的 SPI 扩展点： Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等 Sentinel 的主要特性 Sentinel 的开源生态 Sentinel 的组成 核心库（Java 客户端）： 不依赖任何框架 / 库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持 控制台（Dashboard）： 基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nacos 多环境配置]]></title>
    <url>%2F2013%2F04%2F19%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F054.Spring%20Cloud%20Alibaba-Nacos-%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Nacos 多环境配置概述我们在做项目开发的时候，生产环境和测试环境的一些配置可能会不一样，有时候一些功能也可能会不一样，所以我们可能会在上线的时候手工修改这些配置信息。Spring 为我们提供了 Spring Boot Profile 这个功能（Maven 也为我们提供了 Maven Profile）。我们只需要在启动的时候添加一个虚拟机参数，激活自己环境所要用的 Profile 就可以了。 操作起来很简单，只需要为不同的环境编写专门的配置文件，如：application-dev.yml、application-prod.yml， 启动项目时只需要增加一个命令参数 --spring.profiles.active= 环境配置即可 1java -jar 1.0.0-SNAPSHOT.jar --spring.profiles.active=prod 什么是 Nacos Config Profilespring-cloud-starter-alibaba-nacos-config 在加载配置的时候，不仅仅加载了以 dataid 为 ${spring.application.name}.${file-extension:properties} 为前缀的基础配置，还加载了 dataid 为 ${spring.application.name}-${profile}.${file-extension:properties} 的基础配置。在日常开发中如果遇到多套环境下的不同配置，可以通过 Spring 提供的 ${spring.profiles.active} 这个配置项来配置。 使用 Nacos Config Profile我们以 service-provider 项目为例，演示多环境配置效果，不要忘记依赖 Nacos Config Starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 使用控制台发布配置 注意： 控制台发布配置时不要加注释，否则打成 Jar 包后运行会报无法解析配置文件的错误 通过浏览器访问 http://192.168.141.132:8848/nacos ，访问 Nacos Server 发布一个名为 service-provider-config.yaml 的 测试环境 配置 1234567891011121314151617181920spring: application: # 服务名 name: service-provider cloud: nacos: discovery: # 服务注册中心 server-addr: 192.168.141.132:8848server: # 服务端口 port: 8070management: # 端点检查（健康检查） endpoints: web: exposure: include: "*" 发布一个名为 service-provider-config-prod.yaml 的 生产环境 配置 1234567891011121314151617181920spring: application: # 服务名 name: service-provider cloud: nacos: discovery: # 服务注册中心 server-addr: 192.168.141.132:8848server: # 修改了上面的端口号，区分配置的不同 port: 8071management: # 端点检查（健康检查） endpoints: web: exposure: include: "*" 修改客户端配置 创建名为 bootstrap.properties 的配置文件并删除之前创建的 application.yml 配置文件 123spring.application.name=service-provider-configspring.cloud.nacos.config.server-addr=192.168.141.132:8848spring.cloud.nacos.config.file-extension=yaml 创建名为 bootstrap-prod.properties 的配置文件 1234spring.profiles.active=prodspring.application.name=service-provider-configspring.cloud.nacos.config.server-addr=192.168.141.132:8848spring.cloud.nacos.config.file-extension=yaml 测试多环境配置此时我们有两个配置文件，分别为 bootstrap.properties 和 bootstrap-prod.properties ，我们需要指定启动时加载哪一个配置文件 Run -&gt; Edit Configurations -&gt; Active profiles: 运行项目并观察日志 由上图可知，我们成功加载了不同环境的配置]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nacos 分布式配置中心]]></title>
    <url>%2F2013%2F04%2F18%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F053.Spring%20Cloud%20Alibaba-Nacos-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Nacos 分布式配置中心概述在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件 什么是 Nacos ConfigNacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置。 Spring Cloud Alibaba Nacos Config 是 Spring Cloud Config Server 和 Client 的替代方案，客户端和服务器上的概念与 Spring Environment 和 PropertySource 有着一致的抽象，在特殊的 bootstrap 阶段，配置被加载到 Spring 环境中。当应用程序通过部署管道从开发到测试再到生产时，您可以管理这些环境之间的配置，并确保应用程序具有迁移时需要运行的所有内容。 接入配置中心POM我们以 service-consumer 项目为例，修改 pom.xml ，引入 Nacos Config Starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; Controller完成上述两步后，应用会从 Nacos Config 中获取相应的配置，并添加在 Spring Environment 的 PropertySources 中。这里我们使用 @Value 注解来将对应的配置注入到 TestEchoController 的 username字段，并添加 @RefreshScope 打开动态刷新功能 12345678910111213141516171819202122232425package com.funtl.spring.cloud.alibaba.consumer.controller;import com.funtl.spring.cloud.alibaba.consumer.service.EchoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RefreshScope@RestControllerpublic class TestEchoController &#123; @Autowired private EchoService echoService; @Value("$&#123;user.name&#125;") private String username; @GetMapping(value = "/config") public String config() &#123; return echoService.echo(username); &#125;&#125; 使用控制台发布配置通过浏览器访问 http://192.168.141.132:8848/nacos ，访问 Nacos Server 注意： Data ID 的默认扩展名为 .properties ，希望使用 YAML 配置，此处必须指明是 .yaml 1234567891011121314151617181920212223spring: application: # 服务名 name: service-consumer cloud: nacos: discovery: # 服务注册中心 server-addr: 192.168.141.132:8848server: # 服务端口 port: 8080management: # 端点检查（健康检查） endpoints: web: exposure: include: "*"user: name: "灶门炭治郎" 修改客户端配置创建名为 bootstrap.properties 的配置文件并删除之前创建的 application.yml 配置文件 123spring.application.name=service-consumer-configspring.cloud.nacos.config.server-addr=192.168.141.132:8848spring.cloud.nacos.config.file-extension=yaml 通过浏览器访问 http://localhost:8080/config ，浏览器输出如下 1Hello Nacos Provider 灶门炭治郎 注意： Spring Boot 配置文件的加载顺序，依次为 bootstrap.properties -&gt; bootstrap.yml -&gt; application.properties -&gt; application.yml ，其中 bootstrap.properties 配置为最高优先级 动态刷新配置在 Nacos Server 控制台修改配置文件，将 user.name 属性修改为 灶门祢豆子，此时观察控制台日志，你会发现我们已经成功刷新了配置 验证是否成功通过浏览器访问 http://localhost:8080/config ，浏览器输出如下 1Hello Nacos Provider 灶门祢豆子 提示： 你可以使用 spring.cloud.nacos.config.refresh.enabled=false 来关闭动态刷新 附：扩展阅读Endpoint 信息查看Spring Boot 应用支持通过 Endpoint 来暴露相关信息，Nacos Config Starter 也支持这一点。在使用之前需要在 maven 中添加 spring-boot-starter-actuator 依赖，并在配置中允许 Endpoints 的访问。 nacos-discovery： http://localhost:8080/actuator/nacos-discovery 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; "subscribe": [ &#123; "jsonFromServer": "", "name": "service-consumer", "groupName": "DEFAULT_GROUP", "clusters": null, "cacheMillis": 1000, "hosts": [], "lastRefTime": 0, "checksum": "", "allIPs": false, "key": "service-consumer", "valid": true, "keyEncoded": "service-consumer" &#125;, &#123; "jsonFromServer": "", "name": "service-provider", "groupName": "DEFAULT_GROUP", "clusters": null, "cacheMillis": 1000, "hosts": [], "lastRefTime": 0, "checksum": "", "allIPs": false, "key": "service-provider", "valid": true, "keyEncoded": "service-provider" &#125; ], "NacosDiscoveryProperties": &#123; "serverAddr": "192.168.141.132:8848", "endpoint": "", "namespace": "", "watchDelay": 30000, "logName": "", "service": "service-consumer", "weight": 1, "clusterName": "DEFAULT", "namingLoadCacheAtStart": "false", "metadata": &#123; "preserved.register.source": "SPRING_CLOUD" &#125;, "registerEnabled": true, "ip": "192.168.141.1", "networkInterface": "", "port": 8080, "secure": false, "accessKey": "", "secretKey": "" &#125;&#125; nacos-config： http://localhost:8080/actuator/nacos-config 1234567891011121314151617181920212223242526272829303132333435363738&#123; "NacosConfigProperties": &#123; "serverAddr": "192.168.141.132:8848", "encode": null, "group": "DEFAULT_GROUP", "prefix": null, "fileExtension": "yaml", "timeout": 3000, "endpoint": null, "namespace": null, "accessKey": null, "secretKey": null, "contextPath": null, "clusterName": null, "name": null, "sharedDataids": null, "refreshableDataids": null, "extConfig": null &#125;, "RefreshHistory": [ &#123; "timestamp": "2019-06-30 18:30:45", "dataId": "service-consumer-config.yaml", "md5": "690fd78b5ae9fac5b545c1a8d7ec4e2b" &#125;, &#123; "timestamp": "2019-06-30 18:22:08", "dataId": "service-consumer-config.yaml", "md5": "40b12ffc9d305ec1cad65d606e8f4708" &#125; ], "Sources": [ &#123; "lastSynced": "2019-06-30 18:22:05", "dataId": "service-consumer-config.yaml" &#125; ]&#125; 注意： Sources 表示此客户端从哪些 Nacos Config 配置项中获取了信息，RefreshHistory 表示动态刷新的历史记录，最多保存20条，NacosConfigProperties 则为 Nacos Config Starter 本身的配置 更多配置 配置项 key 默认值 说明 服务端地址 spring.cloud.nacos.config.server-addr DataId前缀 spring.cloud.nacos.config.prefix spring.application.name Group spring.cloud.nacos.config.group DEFAULT_GROUP dataID后缀及内容文件格式 spring.cloud.nacos.config.file-extension properties dataId的后缀，同时也是配置内容的文件格式，目前只支持 properties 配置内容的编码方式 spring.cloud.nacos.config.encode UTF-8 配置的编码 获取配置的超时时间 spring.cloud.nacos.config.timeout 3000 单位为 ms 配置的命名空间 spring.cloud.nacos.config.namespace 常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源隔离等。 AccessKey spring.cloud.nacos.config.access-key SecretKey spring.cloud.nacos.config.secret-key 相对路径 spring.cloud.nacos.config.context-path 服务端 API 的相对路径 接入点 spring.cloud.nacos.config.endpoint UTF-8 地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址 是否开启监听和自动刷新 spring.cloud.nacos.config.refresh.enabled true 更多介绍Nacos为用户提供包括动态服务发现，配置管理，服务管理等服务基础设施，帮助用户更灵活，更轻松地构建，交付和管理他们的微服务平台，基于 Nacos, 用户可以更快速的构建以“服务”为中心的现代云原生应用。Nacos 可以和 Spring Cloud、Kubernetes/CNCF、Dubbo 等微服务生态无缝融合，为用户提供更卓越的体验]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nacos Feign 客户端]]></title>
    <url>%2F2013%2F04%2F17%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F052.Spring%20Cloud%20Alibaba-Nacos-Feign%2F</url>
    <content type="text"><![CDATA[Nacos Feign 客户端什么是 FeignFeign 是一个声明式的伪 HTTP 客户端，它使得写 HTTP 客户端变得更简单。使用 Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用 Feign 注解和 JAX-RS 注解。Feign 支持可插拔的编码器和解码器。Feign 默认集成了 Ribbon，Nacos 也很好的兼容了 Feign，默认实现了负载均衡的效果 Feign 采用的是基于接口的注解 Feign 整合了 Ribbon POM在 hello-spring-cloud-alibaba-consumer 项目中增加 org.springframework.cloud:spring-cloud-starter-openfeign 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; Application通过 @EnableFeignClients 注解开启 Feign 功能 123456789101112131415package com.funtl.spring.cloud.alibaba.consumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; Service创建业务结构，通过 @FeignClient(&quot;服务名&quot;) 注解来指定调用哪个服务 1234567891011package com.funtl.spring.cloud.alibaba.consumer.service;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(value = "service-provider")public interface EchoService &#123; @GetMapping(value = "/echo/&#123;string&#125;") String echo(@PathVariable("string") String string);&#125; Controller12345678910111213141516171819package com.funtl.spring.cloud.alibaba.consumer.controller;import com.funtl.spring.cloud.alibaba.consumer.service.EchoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestEchoController &#123; @Autowired private EchoService echoService; @GetMapping(value = "/feign/echo/&#123;str&#125;") public String echo(@PathVariable String str) &#123; return echoService.echo(str); &#125;&#125; 验证是否成功通过浏览器访问 http://localhost:8080/feign/echo/hi 1Hello Nacos Provider hi 配置负载均衡 修改 service-provider 服务的端口号如 8071，并启动多个实例，IDEA 中依次点击 Run -&gt; Edit Configurations 并勾选 Allow parallel run 以允许 IDEA 多实例运行项目 再次启动 service-provider 实例，IDEA Spring Boot 面板可以看到 Nacos Server 控制台可以看到 service-provider 有 2 个实例 服务： 通过预定义接口网络访问的提供给客户端的软件功能服务名： 服务提供的标识，通过该标识可以唯一确定其指代的服务服务分组： 不同的服务可以归类到同一分组虚拟集群： 同一个服务下的所有服务实例组成一个默认集群，集群可以被进一步按需求划分，划分的单位可以是虚拟集群实例： 提供一个或多个服务的具有可访问网络地址（IP:Port）的进程权重： 实例级别的配置。权重为浮点数。权重越大，分配给该实例的流量越大健康保护阈值： 为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ，继而造成流量压力把健康 健康实例 (Instance) 压垮并形成雪崩效应，应将健康保护阈值定义为一个 0 到 1 之间的浮点数。当域名健康实例 (Instance) 占总服务实例 (Instance) 的比例小于该值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。这样做虽然损失了一部分流量，但是保证了集群的剩余健康实例 (Instance) 能正常工作 在 service-provider 项目的 EchoController 中增加测试方法 1234567@Value("$&#123;server.port&#125;")private String port;@GetMapping(value = "/lb")public String lb() &#123; return "Hello Nacos Provider i am from port: " + port;&#125; 在 service-consumer 项目的 EchoService 中增加测试方法 12@GetMapping(value = "/lb")String lb(); 在 service-consumer 项目的 TestEchoController 中增加测试方法 1234@GetMapping(value = "/lb")public String lb() &#123; return echoService.lb();&#125; 重启服务，通过浏览器访问 http://localhost:8080/lb ，反复刷新浏览器，浏览器交替显示 12Hello Nacos Provider i am from port: 8070Hello Nacos Provider i am from port: 8071 附：扩展阅读常见负载均衡策略负载主机可以提供很多种负载均衡方法，也就是我们常说的调度方法或算法 轮循Round Robin： 这种方法会将收到的请求循环分配到服务器集群中的每台机器，即有效服务器。如果使用这种方式，所有的标记进入虚拟服务的服务器应该有相近的资源容量 以及负载形同的应用程序。如果所有的服务器有相同或者相近的性能那么选择这种方式会使服务器负载形同。基于这个前提，轮循调度是一个简单而有效的分配请求 的方式。然而对于服务器不同的情况，选择这种方式就意味着能力比较弱的服务器也会在下一轮循环中接受轮循，即使这个服务器已经不能再处理当前这个请求了。 这可能导致能力较弱的服务器超载。 加权轮循Weighted Round Robin： 这种算法解决了简单轮循调度算法的缺点：传入的请求按顺序被分配到集群中服务器，但是会考虑提前为每台服务器分配的权重。管理员只是简单的通过服务 器的处理能力来定义各台服务器的权重。例如，能力最强的服务器 A 给的权重是 100，同时能力最低的服务器给的权重是 50。这意味着在服务器 B 接收到第一个 请求之前前，服务器 A 会连续的接受到 2 个请求，以此类推。 最少连接数Least Connection： 以上两种方法都没有考虑的是系统不能识别在给定的时间里保持了多少连接。因此可能发生，服务器 B 服务器收到的连接比服务器 A 少但是它已经超载，因为 服务器 B 上的用户打开连接持续的时间更长。这就是说连接数即服务器的负载是累加的。这种潜在的问题可以通过 “最少连接数” 算法来避免：传入的请求是根据每 台服务器当前所打开的连接数来分配的。即活跃连接数最少的服务器会自动接收下一个传入的请求。接本上和简单轮询的原则相同：所有拥有虚拟服务的服务器资源 容量应该相近。值得注意的是，在流量率低的配置环境中，各服务器的流量并不是相同的，会优先考虑第一台服务器。这是因为，如果所有的服务器是相同的，那么 第一个服务器优先，直到第一台服务器有连续的活跃流量，否则总是会优先选择第一台服务器。 最少连接数慢启动时间Least Connection Slow Start Time： 对最少连接数和带权重的最小连接数调度方法来说，当一个服务器刚加入线上环境是，可以为其配置一个时间段，在这段时间内连接数是有限制的而且是缓慢 增加的。这为服务器提供了一个‘过渡时间’以保证这个服务器不会因为刚启动后因为分配的连接数过多而超载。这个值在 L7 配置界面设置。 加权最少连接Weighted Least Connection： 如果服务器的资源容量各不相同，那么 “加权最少连接” 方法更合适：由管理员根据服务器情况定制的权重所决定的活跃连接数一般提供了一种对服务器非常 平衡的利用，因为他它借鉴了最少连接和权重两者的优势。通常，这是一个非常公平的分配方式，因为它使用了连接数和服务器权重比例；集群中比例最低的服务器 自动接收下一个请求。但是请注意，在低流量情况中使用这种方法时，请参考 “最小连接数” 方法中的注意事项。 基于代理的自适应负载均衡Agent Based Adaptive Balancing： 除了上述方法之外，负载主机包含一个自适用逻辑用来定时监测服务器状态和该服务器的权重。对于非常强大的 “基于代理的自适应负载均衡” 方法来说，负 载主机以这种方式来定时检测所有服务器负载情况：每台服务器都必须提供一个包含文件，这个文件包含一个 0~99 的数字用来标明改服务器的实际负载情况 (0 = 空前，99 = 超载，101 = 失败，102 = 管理员禁用)，而服务器同构 http get 方法来获取这个文件；同时对集群中服务器来说，以二进制文件形式提供自身负载情况也是该服务器工作之一，然而，并没有限制服务器如何计算自身的负载 情况。根据服务器整体负载情况，有两种策略可以选择：在常规的操作中，调度算法通过收集的服务器负载值和分配给该服务器的连接数的比例计算出一个权重比 例。因此，如果一个服务器负载过大，权重会通过系统透明的作重新调整。和加权轮循调度方法一样，不正确的分配可以被记录下来使得可以有效的为不同服务器分 配不同的权重。然而，在流量非常低的环境下，服务器报上来的负载值将不能建立一个有代表性的样本；那么基于这些值来分配负载的话将导致失控以及指令震荡。 因此，在这种情况下更合理的做法是基于静态的权重比来计算负载分配。当所有服务器的负载低于管理员定义的下限时，负载主机就会自动切换为加权轮循方式来分 配请求；如果负载大于管理员定义的下限，那么负载主机又会切换回自适应方式。 固定权重Fixed Weighted： 最高权重只有在其他服务器的权重值都很低时才使用。然而，如果最高权重的服务器下降，则下一个最高优先级的服务器将为客户端服务。这种方式中每个真实服务器的权重需要基于服务器优先级来配置。 加权响应Weighted Response： 流量的调度是通过加权轮循方式。加权轮循中所使用的权重是根据服务器有效性检测的响应时间来计算。每个有效性检测都会被计时，用来标记它响应成功花 了多长时间。但是需要注意的是，这种方式假定服务器心跳检测是基于机器的快慢，但是这种假设也许不总是能够成立。所有服务器在虚拟服务上的响应时间的总和 加在一起，通过这个值来计算单个服务物理服务器的权重；这个权重值大约每 15 秒计算一次。 源 IP 哈希Source IP Hash： 这种方式通过生成请求源 IP 的哈希值，并通过这个哈希值来找到正确的真实服务器。这意味着对于同一主机来说他对应的服务器总是相同。使用这种方式，你不需要保存任何源 IP。但是需要注意，这种方式可能导致服务器负载不平衡。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nacos 服务注册与发现]]></title>
    <url>%2F2013%2F04%2F16%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F051.Spring%20Cloud%20Alibaba-Nacos-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Nacos 服务注册与发现概述 服务注册中心： 存储服务实例和服务负载均衡策略的数据库 本节通过实现一个简单的 echo service 演示如何在您的 Spring Cloud 项目中启用 Nacos 的服务发现功能，如下图示: 服务提供者 服务提供方： 是指提供可复用和可调用服务的应用方 POM创建一个名为 hello-spring-cloud-alibaba-provider 的服务提供者项目，pom.xml 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba-provider&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.spring.cloud.alibaba.provider.ProviderApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml在 application.yml 中配置 Nacos Server 的地址 1234567891011121314151617181920spring: application: # 服务名 name: service-provider cloud: nacos: discovery: # 服务注册中心 server-addr: 192.168.141.132:8848server: # 服务端口 port: 8070management: # 端点检查（健康检查） endpoints: web: exposure: include: "*" Application通过 Spring Cloud 原生注解 @EnableDiscoveryClient 开启服务注册发现功能 12345678910111213package com.funtl.spring.cloud.alibaba.provider;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApplication.class, args); &#125;&#125; Controller编写一个 RestController 提供 RESTFul API 用于测试提供者 1234567891011121314package com.funtl.spring.cloud.alibaba.provider.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class EchoController &#123; @GetMapping(value = "/echo/&#123;string&#125;") public String echo(@PathVariable String string) &#123; return "Hello Nacos Provider " + string; &#125;&#125; 验证是否成功通过浏览器访问 http://192.168.141.132:8848/nacos Nacos Server 网址 你会发现一个服务已经注册在服务中了，服务名为 service-provider，通过浏览器访问 http://localhost:8070/echo/hi 1Hello Nacos Provider hi 服务端点检查 健康检查： 以指定方式检查服务下挂载的实例 (Instance) 的健康度，从而确认该实例 (Instance) 是否能提供服务。根据检查结果，实例 (Instance) 会被判断为健康或不健康。对服务发起解析请求时，不健康的实例 (Instance) 不会返回给客户端。 通过浏览器访问 http://localhost:8070/actuator/nacos-discovery 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; "subscribe": [ &#123; "jsonFromServer": "", "name": "service-provider", "groupName": "DEFAULT_GROUP", "clusters": null, "cacheMillis": 1000, "hosts": [], "lastRefTime": 0, "checksum": "", "allIPs": false, "key": "service-provider", "valid": true, "keyEncoded": "service-provider" &#125;, &#123; "jsonFromServer": "", "name": "service-consumer", "groupName": "DEFAULT_GROUP", "clusters": null, "cacheMillis": 1000, "hosts": [], "lastRefTime": 0, "checksum": "", "allIPs": false, "key": "service-consumer", "valid": true, "keyEncoded": "service-consumer" &#125; ], "NacosDiscoveryProperties": &#123; "serverAddr": "192.168.141.132:8848", "endpoint": "", "namespace": "", "watchDelay": 30000, "logName": "", "service": "service-provider", "weight": 1, "clusterName": "DEFAULT", "namingLoadCacheAtStart": "false", "metadata": &#123; "preserved.register.source": "SPRING_CLOUD" &#125;, "registerEnabled": true, "ip": "192.168.141.1", "networkInterface": "", "port": 8070, "secure": false, "accessKey": "", "secretKey": "" &#125;&#125; 服务消费者 服务消费方： 是指会发起对某个服务调用的应用方 服务消费者的创建与服务提供者大同小异，这里采用最原始的一种方式，即显示的使用 LoadBalanceClient 和 RestTemplate 结合的方式来访问 POM创建一个名为 hello-spring-cloud-alibaba-consumer 的服务消费者项目，pom.xml 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba-consumer&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.spring.cloud.alibaba.consumer.ConsumerApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml在 application.yml 中配置 Nacos Server 的地址 1234567891011121314151617181920spring: application: # 服务名 name: service-consumer cloud: nacos: discovery: # 服务注册中心 server-addr: 192.168.141.132:8848server: # 服务端口 port: 8080management: # 端点检查（健康检查） endpoints: web: exposure: include: "*" Application通过 Spring Cloud 原生注解 @EnableDiscoveryClient 开启服务注册发现功能 12345678910111213package com.funtl.spring.cloud.alibaba.consumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; Configuration创建一个 Java 配置类，主要作用是为了注入 RestTemplate 12345678910111213141516package com.funtl.spring.cloud.alibaba.consumer.configure;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ConsumerConfiguration &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; Controller123456789101112131415161718192021222324package com.funtl.spring.cloud.alibaba.consumer.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@RestControllerpublic class TestController &#123; private final RestTemplate restTemplate; @Autowired public TestController(RestTemplate restTemplate) &#123; this.restTemplate = restTemplate; &#125; @GetMapping(value = "/echo/&#123;str&#125;") public String echo(@PathVariable String str) &#123; // 使用服务名请求服务提供者 return restTemplate.getForObject("http://service-provider/echo/" + str, String.class); &#125;&#125; 验证是否成功通过浏览器访问 http://192.168.141.132:8848/nacos Nacos Server 网址 你会发现一个服务已经注册在服务中了，服务名为 service-consumer，通过浏览器访问 http://localhost:8080/echo/hi 1Hello Nacos Provider hi 服务端点检查通过浏览器访问 http://localhost:8080/actuator/nacos-discovery 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; "subscribe": [ &#123; "jsonFromServer": "", "name": "service-provider", "groupName": "DEFAULT_GROUP", "clusters": null, "cacheMillis": 1000, "hosts": [], "lastRefTime": 0, "checksum": "", "allIPs": false, "key": "service-provider", "valid": true, "keyEncoded": "service-provider" &#125;, &#123; "jsonFromServer": "", "name": "service-consumer", "groupName": "DEFAULT_GROUP", "clusters": null, "cacheMillis": 1000, "hosts": [], "lastRefTime": 0, "checksum": "", "allIPs": false, "key": "service-consumer", "valid": true, "keyEncoded": "service-consumer" &#125; ], "NacosDiscoveryProperties": &#123; "serverAddr": "192.168.141.132:8848", "endpoint": "", "namespace": "", "watchDelay": 30000, "logName": "", "service": "service-consumer", "weight": 1, "clusterName": "DEFAULT", "namingLoadCacheAtStart": "false", "metadata": &#123; "preserved.register.source": "SPRING_CLOUD" &#125;, "registerEnabled": true, "ip": "192.168.141.1", "networkInterface": "", "port": 8080, "secure": false, "accessKey": "", "secretKey": "" &#125;&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nacos 安装]]></title>
    <url>%2F2013%2F04%2F15%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F050.Spring%20Cloud%20Alibaba-Nacos-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Nacos 安装概述Nacos 官方提供了 Docker 版本，方便我们快速部署，操作步骤如下 操作步骤Clone 项目12git clone https://github.com/nacos-group/nacos-docker.gitcd nacos-docker 单机模式1docker-compose -f example/standalone-mysql.yaml up -d 查看日志1docker-compose -f example/standalone-mysql.yaml logs -f Nacos 控制台http://192.168.141.132:8848/nacos 登录 账号： nacos 密码： nacos 访问]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nacos 注册中心]]></title>
    <url>%2F2013%2F04%2F14%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F049.Spring%20Cloud%20Alibaba-Nacos-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Nacos 注册中心概述Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以 “服务” 为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。 Nacos 官网 关键特性服务发现和服务健康监测Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 原生 SDK、OpenAPI、或一个 独立的 Agent TODO 注册 Service 后，服务消费者可以使用 DNS TODO 或 HTTP&amp;API 查找和发现服务。 Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP) 和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测 2 种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。 动态配置服务动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。 Nacos 提供了一个简洁易用的 UI 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。 动态 DNS 服务动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单 DNS 解析服务。动态 DNS 服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。 Nacos 提供了一些简单的 DNS APIs TODO 帮助您管理服务的关联域名和可用的 IP:PORT 列表. 服务及其元数据管理Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。 Nacos 地图 特性大图：要从功能特性，非功能特性，全面介绍我们要解的问题域的特性诉求 架构大图：通过清晰架构，让您快速进入 Nacos 世界 业务大图：利用当前特性可以支持的业务场景，及其最佳实践 生态大图：系统梳理 Nacos 和主流技术生态的关系 优势大图：展示 Nacos 核心竞争力 战略大图：要从战略到战术层面讲 Nacos 的宏观优势 Nacos 架构基本架构及概念 服务 (Service)服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service. 服务注册中心 (Service Registry)服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。 服务元数据 (Service Metadata)服务元数据是指包括服务端点 (endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据 服务提供方 (Service Provider)是指提供可复用和可调用服务的应用方 服务消费方 (Service Consumer)是指会发起对某个服务调用的应用方 配置 (Configuration)在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。 配置管理 (Configuration Management)在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。 名字服务 (Naming Service)提供分布式系统中所有对象 (Object)、实体 (Entity) 的 “名字” 到关联的元数据之间的映射管理服务，例如 ServiceName -&gt; Endpoints Info, Distributed Lock Name -&gt; Lock Owner/Status Info, DNS Domain Name -&gt; IP List, 服务发现和 DNS 就是名字服务的 2 大场景。 配置服务 (Configuration Service)在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。 逻辑架构及其组件介绍 服务管理： 实现服务 CRUD，域名 CRUD，服务健康状态检查，服务权重管理等功能 配置管理： 实现配置管 CRUD，版本管理，灰度管理，监听管理，推送轨迹，聚合数据等功能 元数据管理： 提供元数据 CURD 和打标能力 插件机制： 实现三个模块可分可合能力，实现扩展点 SPI 机制 事件机制： 实现异步化事件通知，sdk 数据变化异步通知等逻辑 日志模块： 管理日志分类，日志级别，日志可移植性（尤其避免冲突），日志格式，异常码 + 帮助文档 回调机制： sdk 通知数据，通过统一的模式回调用户处理。接口和数据结构需要具备可扩展性 寻址模式： 解决 ip，域名，nameserver、广播等多种寻址模式，需要可扩展 推送通道： 解决 server 与存储、server 间、server 与 sdk 间推送性能问题 容量管理： 管理每个租户，分组下的容量，防止存储被写爆，影响服务可用性 流量管理： 按照租户，分组等多个维度对请求频率，长链接个数，报文大小，请求流控进行控制 缓存机制： 容灾目录，本地缓存，server 缓存机制。容灾目录使用需要工具 启动模式： 按照单机模式，配置模式，服务模式，dns 模式，或者 all 模式，启动不同的程序 + UI 一致性协议： 解决不同数据，不同一致性要求情况下，不同一致性机制 存储模块： 解决数据持久化、非持久化存储，解决数据分片问题 Nameserver： 解决 namespace 到 clusterid 的路由问题，解决用户环境与 nacos 物理环境映射问题 CMDB： 解决元数据存储，与三方 cmdb 系统对接问题，解决应用，人，资源关系 Metrics： 暴露标准 metrics 数据，方便与三方监控系统打通 Trace： 暴露标准 trace，方便与 SLA 系统打通，日志白平化，推送轨迹等能力，并且可以和计量计费系统打通 接入管理： 相当于阿里云开通服务，分配身份、容量、权限过程 用户管理： 解决用户管理，登录，sso 等问题 权限管理： 解决身份识别，访问控制，角色管理等问题 审计系统： 扩展接口方便与不同公司审计系统打通 通知系统： 核心数据变更，或者操作，方便通过 SMS 系统打通，通知到对应人数据变更 OpenAPI： 暴露标准 Rest 风格 HTTP 接口，简单易用，方便多语言集成 Console： 易用控制台，做服务管理、配置管理等操作 SDK： 多语言 sdk Agent： dns-f 类似模式，或者与 mesh 等方案集成 CLI： 命令行对产品进行轻量化管理，像 git 一样好用]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba 创建统一的依赖管理]]></title>
    <url>%2F2013%2F04%2F13%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F048.Spring%20Cloud%20Alibaba-%E5%88%9B%E5%BB%BA%E7%BB%9F%E4%B8%80%E7%9A%84%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[创建统一的依赖管理POM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;spring-cloud-alibaba.verion&gt;0.9.0.RELEASE&lt;/spring-cloud-alibaba.verion&gt; &lt;/properties&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.verion&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba 创建项目工程]]></title>
    <url>%2F2013%2F04%2F12%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F047.Spring%20Cloud%20Alibaba-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[创建项目工程POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;modules&gt; &lt;module&gt;hello-spring-cloud-alibaba-dependencies&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;licenses&gt; &lt;license&gt; &lt;name&gt;Apache 2.0&lt;/name&gt; &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;liwemin&lt;/id&gt; &lt;name&gt;Lusifer Lee&lt;/name&gt; &lt;email&gt;lee.lusifer@gmail.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;default&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;spring-javaformat.version&gt;0.0.12&lt;/spring-javaformat.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;io.spring.javaformat&lt;/groupId&gt; &lt;artifactId&gt;spring-javaformat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-javaformat.version&#125;&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;**/*Tests.java&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/Abstract*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;systemPropertyVariables&gt; &lt;java.security.egd&gt;file:/dev/./urandom&lt;/java.security.egd&gt; &lt;java.awt.headless&gt;true&lt;/java.awt.headless&gt; &lt;/systemPropertyVariables&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;enforce-rules&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;enforce&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;rules&gt; &lt;bannedDependencies&gt; &lt;excludes&gt; &lt;exclude&gt;commons-logging:*:*&lt;/exclude&gt; &lt;/excludes&gt; &lt;searchTransitive&gt;true&lt;/searchTransitive&gt; &lt;/bannedDependencies&gt; &lt;/rules&gt; &lt;fail&gt;true&lt;/fail&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestone&lt;/id&gt; &lt;name&gt;Spring Milestone&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;name&gt;Spring Snapshot&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba简介]]></title>
    <url>%2F2013%2F04%2F11%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F046.Spring%20Cloud%20Alibaba-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Spring Cloud Alibaba概述2018 年 10 月 31 日的凌晨，这个伟大的日子里，Spring Cloud Alibaba 正式入驻了 Spring Cloud 官方孵化器，并在 Maven 中央库发布了第一个版本。 Spring Cloud for Alibaba 0.2.0 released The Spring Cloud Alibaba project, consisting of Alibaba’s open-source components and several Alibaba Cloud products, aims to implement and expose well known Spring Framework patterns and abstractions to bring the benefits of Spring Boot and Spring Cloud to Java developers using Alibaba products. Spring Cloud for Alibaba，它是由一些阿里巴巴的开源组件和云产品组成的。这个项目的目的是为了让大家所熟知的 Spring 框架，其优秀的设计模式和抽象理念，以给使用阿里巴巴产品的 Java 开发者带来使用 Spring Boot 和 Spring Cloud 的更多便利。 Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 Spring Cloud Alibaba GitHub 主要功能 服务限流降级： 默认支持 Servlet、Feign、RestTemplate、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。 服务注册与发现： 适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。 分布式配置管理： 支持分布式系统中的外部化配置，配置更改时自动刷新。 消息驱动能力： 基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。 阿里云对象存储： 阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。 分布式任务调度： 提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。 组件 Sentinel： 把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Nacos： 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 RocketMQ： 一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo： Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata： 阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud ACM： 一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS： 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX： 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS： 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 更新包名和 Maven 坐标接到阿里官方通知在 2019 年 7 月 4 日修改相关包名和 Maven 坐标，请参考 Update package name &amp; maven coordinates ，由于视频录制于 2019 年 6 月 28 日，故所使用的包名和坐标依然沿用原先的 org.springframework.cloud，后面的视频会改用最新的标准，看到这里的小伙伴可以尝试使用新坐标。 包名修改包名前缀由 org.springframework.cloud.alibaba 变更为 com.alibaba.cloud Maven 坐标修改bom 由 spring-cloud-alibaba-dependencies 变更为 alibaba-spring-cloud-dependencies maven groupid 由 org.springframework.cloud 变更为 com.alibaba.cloud Spring Cloud Alibaba 修改前 修改后 sentinel starter spring-cloud-starter-alibaba-sentinel alibaba-sentinel-spring-cloud-starter nacos config starter spring-cloud-starter-alibaba-nacos-config alibaba-nacos-config-spring-cloud-starter nacos discovery starter spring-cloud-starter-alibaba-nacos-discovery alibaba-nacos-discovery-spring-cloud-starter seata starter spring-cloud-starter-alibaba-seata alibaba-seata-spring-cloud-starter dubbo starter spring-cloud-starter-dubbo dubbo-spring-cloud-starter rocketmq binder starter spring-cloud-starter-stream-rocketmq rocketmq-stream-spring-cloud-starter rocketmq bus module name spring-cloud-starter-bus-rocketmq rocketmq-bus-spring-cloud-starter sentinel module name spring-cloud-alibaba-sentinel alibaba-sentinel-spring-cloud sentinel datasource module name spring-cloud-alibaba-sentinel-datasource alibaba-sentinel-datasource-spring-cloud sentinel gateway module name spring-cloud-alibaba-sentinel-gateway alibaba-sentinel-gateway-spring-cloud nacos config module name spring-cloud-alibaba-nacos-config alibaba-nacos-config-spring-cloud nacos discovery module name spring-cloud-alibaba-nacos-discovery alibaba-nacos-discovery-spring-cloud dubbo module name spring-cloud-alibaba-dubbo alibaba-dubbo-spring-cloud seata module name spring-cloud-alibaba-seata alibaba-seata-spring-cloud rocketmq binder module name spring-cloud-stream-binder-rocketmq rocketmq-spring-cloud-stream-binder Spring Cloud Alicloud(商业化组件) 修改前 修改后 oss starter spring-cloud-alicloud-oss alicloud-oss-spring-cloud sms starter spring-cloud-alicloud-sms alicloud-sms-spring-cloud schedulerx starter spring-cloud-alicloud-schedulerx alicloud-schedulerx-spring-cloud ans starter spring-cloud-alicloud-ans alicloud-ans-spring-cloud acm starter spring-cloud-alicloud-acm alicloud-acm-spring-cloud oss module name spring-cloud-alicloud-oss alicloud-oss-spring-cloud sms module name spring-cloud-alicloud-sms alicloud-sms-spring-cloud schedulerx module name spring-cloud-alicloud-schedulerx alicloud-schedulerx-spring-cloud ans module name spring-cloud-alicloud-ans alicloud-ans-spring-cloud acm module name spring-cloud-alicloud-acm alicloud-acm-spring-cloud]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Netflix]]></title>
    <url>%2F2013%2F04%2F10%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay62_Spring%20Cloud%20Alibaba%2F045.Spring%20Cloud%20Netflix-%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%85%A5%E7%BB%B4%E6%8A%A4%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Spring Cloud Netflix概述Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线）。分布式系统的协调导致了样板模式, 使用 Spring Cloud 开发人员可以快速地支持实现这些模式的服务和应用程序。他们将在任何分布式环境中运行良好，包括开发人员自己的笔记本电脑，裸机数据中心，以及 Cloud Foundry 等托管平台。 由于 Spring Cloud Netflix 项目已进入维护期。这意味着继续使用它再也没有新功能福利了；故我们采用 Spring Cloud Alibaba 方案来替代 Spring Cloud Netflix。 项目进入维护期【官方新闻】Spring Cloud Greenwich.RC1 available now 2018 年 12 月 12 日，Netflix 宣布 Spring Cloud Netflix 系列技术栈进入维护模式（不再添加新特性） 最近，Netflix 宣布 Hystrix 正在进入维护模式。自 2016 年以来，Ribbon 已处于类似状态。虽然 Hystrix 和 Ribbon 现已处于维护模式，但它们仍然在 Netflix 大规模部署。 Hystrix Dashboard 和 Turbine 已被 Atlas 取代。这些项目的最后一次提交分别是 2 年前和 4 年前。Zuul1 和 Archaius1 都被后来不兼容的版本所取代。 以下 Spring Cloud Netflix 模块和相应的 Starter 将进入维护模式： spring-cloud-netflix-archaius spring-cloud-netflix-hystrix-contract spring-cloud-netflix-hystrix-dashboard spring-cloud-netflix-hystrix-stream spring-cloud-netflix-hystrix spring-cloud-netflix-ribbon spring-cloud-netflix-turbine-stream spring-cloud-netflix-turbine spring-cloud-netflix-zuul 什么是维护模式将模块置于维护模式，意味着 Spring Cloud 团队将不会再向模块添加新功能。我们将修复 block 级别的 bug 以及安全问题，我们也会考虑并审查社区的小型 pull request。 替代品我们建议对这些模块提供的功能进行以下替换 CURRENT REPLACEMENT Hystrix Resilience4j Hystrix Dashboard / Turbine Micrometer + Monitoring System Ribbon Spring Cloud Loadbalancer Zuul 1 Spring Cloud Gateway Archaius 1 Spring Boot external config + Spring Cloud Config 附：扩展阅读Netflix Concurrency Limits并发限制模块，它是 Netflix 开源的限流器项目，Spring Cloud 在 Greenwich 版本中引入 spring-cloud-netflix-concurrency-limits Archaius 1有些人对它可能比较陌生，也是 Netflix 公司开源项目，基于 Java 的配置管理类库（apache common configuration 类库的扩展），主要用于多配置存储的动态获取。它主要的特性： 动态类型化属性 高效和线程安全的配置操作 配置改变时的回调机制 轮询框架 JMX，通过Jconsole检查和调用操作属性 组合配置 Resilience4j目前还中孵化中，Spring 可能是要抽象一个断路器的统一规范，让不同的断路器（Hystrix、Resilience4j、Sentinel（阿里开源））选择使用 MicrometerSpring Boot 2 中的 Spring Boot Actuator 底层用的就是 Micrometer，它是 Pivotal 公司（也就是 Spring 所在的公司）开源的监控门面，类似于监控世界的 Slf4j。Resilience4j 自带整合了 Micrometer；目前还无法判断是否比 Hystrix Dashboard /Turbine 的更强大，更好用。 Spring Cloud Loadbalancer目前还中孵化中，使用上和 Ribbon 区别不大 Spring Cloud GatewayZuul 持续跳票 1 年多，1.x 是一个基于阻塞 IO 的 API Gateway 以及 Servlet；直到 2018 年 5 月，Zuul 2.x（基于 Netty，也是非阻塞的，支持长连接）才发布，但 Spring Cloud 暂时还没有整合计划。Spring Cloud Gateway 比 Zuul 1.x 系列的性能和功能整体要好。 Spring Boot external config + Spring Cloud ConfigNetflix 开源的组件（Archaius 1/Ribbon/Hystrix）都没有使用 Spring Boot 的规范（spring-boot-configuration-processor），根本没有 metadata.json 文件，于是这部分配置 IDE 无法给你提示]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 表达式语法]]></title>
    <url>%2F2013%2F04%2F09%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F%E9%99%84%EF%BC%9AThymeleaf%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Thymeleaf 表达式语法Message 表达式#{...} 12&lt;p th:utext="#&#123;home.welcome($&#123;session.user.name&#125;)&#125;"&gt; Welcome to our grocery store, Sebastian Pepper!&lt;/p&gt;&lt;p th:utext="#&#123;$&#123;welcomeMsgKey&#125;($&#123;session.user.name&#125;)&#125;"&gt; Welcome to our grocery store, Sebastian Pepper!&lt;/p&gt; 变量表达式${} 1ongl 标准语法，方法也可以被调用 选择变量表达式*{} 12345678910111213141516171819202122&lt;div th:object="$&#123;session.user&#125;"&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&#123;nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 等价于&lt;div&gt; &lt;p&gt;Name: &lt;span th:text="$&#123;session.user.firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="$&#123;session.user.lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text="$&#123;session.user.nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;当然了，这两者可以混合使用还有一种方式&lt;div&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;session.user.name&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="*&#123;session.user.surname&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text="*&#123;session.user.nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 链接 URL 表达式@{} 123456789&lt;!-- Will produce 'http://localhost:8080/gtvg/order/details?orderId=3' (plus rewriting) --&gt; &lt;a href="details.html"th:href="@&#123;http://localhost:8080/gtvg/order/details(orderId=$&#123;o.id&#125;)&#125;"&gt;view&lt;/a&gt; &lt;!-- Will produce '/gtvg/order/details?orderId=3' (plus rewriting) --&gt;&lt;a href="details.html" th:href="@&#123;/order/details(orderId=$&#123;o.id&#125;)&#125;"&gt;view&lt;/a&gt;&lt;!-- Will produce '/gtvg/order/3/details' (plus rewriting) --&gt;&lt;a href="details.html" th:href="@&#123;/order/&#123;orderId&#125;/details(orderId=$&#123;o.id&#125;)&#125;"&gt;view&lt;/a&gt; 变量 分类 实例 文本 one text，Another one!，… 数字 0 , 34 , 3.0 , 12.3 ,… 真假 true , false 文字符号 one , sometext , main ,… 算数运算 分类 实例 +, -, *, /, % 二元运算符 - 减号（一元运算符） 真假运算 分类 实例 and , or 二元运算符 ! , not 否定（一元运算符） 比较运算 分类 实例 &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) 比较 == , != ( eq , ne ) 平等 条件运算 分类 实例 if-then (if) ? (then) if-then-else (if) ? (then) : (else) Default (value) ?: (defaultvalue)]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 模板布局]]></title>
    <url>%2F2013%2F04%2F08%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F%E9%99%84%EF%BC%9AThymeleaf%20%E6%A8%A1%E6%9D%BF%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Thymeleaf 模板布局概述这节主要介绍模板的引入。及如何在不改变前端人员的 HTML 显示结果的情况下设计模板（通过属性配置动态时不显示的部分）。 模板模块导入首先定义一个 /resources/templates/footer.html 文件： 12345678&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt; &lt;body&gt; &lt;div th:fragment="copy"&gt; &amp;copy; 2018 Copyright by Lusifer. &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面的代码定义了一个片段称为 copy，我们可以很容易地使用 th:include 或者 th:replace 属性包含在我们的主页上 123&lt;body&gt; &lt;div th:include="footer :: copy"&gt;&lt;/div&gt;&lt;/body&gt; include 的表达式想当简洁。这里有三种写法： templatename::domselector 或者 templatename::[domselector] 引入模板页面中的某个模块 templatename 引入模板页面 ::domselector 或者 this::domselector 引入自身模板的模块 上面所有的 templatename 和 domselector 的写法都支持表达式写法： 1&lt;div th:include="footer :: ($&#123;user.isAdmin&#125;? #&#123;footer.admin&#125; : #&#123;footer.normaluser&#125;)"&gt;&lt;/div&gt; 不使用 fragment 来引用模块123&lt;div id="copy-section"&gt; &amp;copy; 2018 Copyright by Lusifer.&lt;/div&gt; 我们可以用 CSS 的选择器写法来引入 123&lt;body&gt; &lt;div th:include="footer :: #copy-section"&gt;&lt;/div&gt;&lt;/body&gt; include 和 replace 的区别th:include 和 th:replace 都可以引入模块，两者的区别在于： th:include：引入子模块的 children，依然保留父模块的 tag th:replace：引入子模块的所有，不保留父模块的 tag 举个例子123&lt;footer th:fragment="copy"&gt; &amp;copy; 2018 Copyright by Lusifer.&lt;/footer&gt; 引入界面1234&lt;body&gt; &lt;div th:include="footer :: copy"&gt;&lt;/div&gt; &lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;/body&gt; 显示结果12345678&lt;body&gt; &lt;div&gt; &amp;copy; 2018 Copyright by Lusifer. &lt;/div&gt; &lt;footer&gt; &amp;copy; 2018 Copyright by Lusifer. &lt;/footer&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 常用语法]]></title>
    <url>%2F2013%2F04%2F07%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F%E9%99%84%EF%BC%9AThymeleaf%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Thymeleaf 常用语法引入 Thymeleaf修改 html 标签用于引入 thymeleaf 引擎，这样才可以在其他标签里使用 th:* 语法，这是下面语法的前提。 12&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt; 获取变量值1&lt;p th:text="'Hello！, ' + $&#123;name&#125; + '!'" &gt;name&lt;/p&gt; 可以看出获取变量值用 $ 符号,对于javaBean的话使用 变量名.属性名 方式获取,这点和 EL 表达式一样. 另外 $ 表达式只能写在th标签内部,不然不会生效,上面例子就是使用 th:text 标签的值替换 p 标签里面的值,至于 p 里面的原有的值只是为了给前端开发时做展示用的.这样的话很好的做到了前后端分离. 引入 URLThymeleaf 对于 URL 的处理是通过语法 @{…} 来处理的 123&lt;a th:href="@&#123;http://www.baidu.com&#125;"&gt;绝对路径&lt;/a&gt;&lt;a th:href="@&#123;/&#125;"&gt;相对路径&lt;/a&gt;&lt;a th:href="@&#123;css/bootstrap.min.css&#125;"&gt;Content路径,默认访问static下的css文件夹&lt;/a&gt; 类似的标签有:th:href 和 th:src 字符串替换很多时候可能我们只需要对一大段文字中的某一处地方进行替换，可以通过字符串拼接操作完成： 1&lt;span th:text="'Welcome to our application, ' + $&#123;user.name&#125; + '!'"&gt; 一种更简洁的方式是： 1&lt;span th:text="|Welcome to our application, $&#123;user.name&#125;!|"&gt; 当然这种形式限制比较多，|…|中只能包含变量表达式${…}，不能包含其他常量、条件表达式等。 运算符在表达式中可以使用各类算术运算符，例如+, -, *, /, % 1th:with="isEven=($&#123;prodStat.count&#125; % 2 == 0)" 逻辑运算符&gt;, &lt;, &lt;=,&gt;=，==,!=都可以使用，唯一需要注意的是使用&lt;,&gt;时需要用它的HTML转义符： 12th:if="$&#123;prodStat.count&#125; &amp;gt; 1"th:text="'Execution mode is ' + ( ($&#123;execMode&#125; == 'dev')? 'Development' : 'Production')" 条件if/unlessThymeleaf 中使用 th:if 和 th:unless 属性进行条件判断，下面的例子中，标签只有在 th:if 中条件成立时才显示： 1&lt;a th:href="@&#123;/login&#125;" th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt; th:unless 于 th:if 恰好相反，只有表达式中的条件不成立，才会显示其内容。 switchThymeleaf 同样支持多路选择 Switch 结构： 1234&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt;&lt;/div&gt; 默认属性 default 可以用 * 表示： 12345&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt; &lt;p th:case="*"&gt;User is some other thing&lt;/p&gt;&lt;/div&gt; 循环渲染列表数据是一种非常常见的场景，例如现在有 n 条记录需要渲染成一个表格，该数据集合必须是可以遍历的，使用 th:each 标签： 1234567891011121314151617181920&lt;body&gt; &lt;h1&gt;Product list&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="prod : $&#123;prods&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;td th:text="$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;"&gt;yes&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;a href="../home.html" th:href="@&#123;/&#125;"&gt;Return to home&lt;/a&gt; &lt;/p&gt;&lt;/body&gt; 可以看到，需要在被循环渲染的元素（这里是）中加入 th:each 标签，其中 th:each=&quot;prod : ${prods}&quot; 意味着对集合变量 prods 进行遍历，循环变量是 prod 在循环体中可以通过表达式访问。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 参考手册]]></title>
    <url>%2F2013%2F04%2F06%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F%E9%99%84%EF%BC%9AThymeleaf%20%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Thymeleaf 参考手册概述本章为 Thymeleaf 语法参考，主要介绍如：循环、判断、模板布局、内置对象等。 声明修改 html 标签用于引入 thymeleaf 引擎，这样才可以在其他标签里使用 th:* 语法。 12&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt; 使用文本 语法 说明 {home.welcome} 使用国际化文本,国际化传参直接追加 (value…) ${user.name} 使用会话属性 @{} 表达式中使用超链接 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;href=&quot;../../css/gtvg.css&quot; th:href=&quot;@{/css/gtvg.css}&quot; /&gt; - - ${} 表达式中基本对象 param 获取请求参数，比如 ${param.name}, http://localhost:8080?name=jeff session 获取 session 的属性 application 获取 application 的属性 execInfo 有两个属性 templateName 和 now (是 java 的 Calendar 对象) ctx vars locale httpServletRequest httpSession - - th 扩展标签 th:text 普通字符串 th:utext 转义文本 th:href 链接 th:attr 设置元素属性 &lt;img src=&quot;../../images/gtvglogo.png&quot; th:attr=&quot;src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}&quot; /&gt; th:with 定义常量 th:attrappend 追加属性 th:classappend 追加类样式 th:styleappend 追加样式 其他标签 语法 说明 th:abbr th:accept th:accept-charset th:accesskey th:action th:align th:alt th:archive th:audio th:autocomplete th:axis th:background th:bgcolor th:border th:cellpadding th:cellspacing th:challenge th:charset th:cite th:class th:classid th:codebase th:codetype th:cols th:colspan th:compact th:content th:contenteditable th:contextmenu th:data th:datetime th:dir th:draggable th:dropzone th:enctype th:for th:form th:formaction th:formenctype th:formmethod th:formtarget th:frame th:frameborder th:headers th:height th:high th:href th:hreflang th:hspace th:http-equiv th:icon th:id th:keytype th:kind th:label th:lang th:list th:longdesc th:low th:manifest th:marginheight th:marginwidth th:max th:maxlength th:media th:method th:min th:name th:optimum th:pattern th:placeholder th:poster th:preload th:radiogroup th:rel th:rev th:rows th:rowspan th:rules th:sandbox th:scheme th:scope th:scrolling th:size th:sizes th:span th:spellcheck th:src th:srclang th:standby th:start th:step th:style th:summary th:tabindex th:target th:title th:type th:usemap th:value th:valuetype th:vspace th:width th:wrap th:xmlbase th:xmllang th:xmlspace th:alt-title th:lang-xmllang 循环123456789101112131415161718&lt;tr th:each="prod : $&#123;prods&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;td th:text="$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;"&gt;yes&lt;/td&gt;&lt;/tr&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="prod,iterStat : $&#123;prods&#125;" th:class="$&#123;iterStat.odd&#125;? 'odd'"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;td th:text="$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;"&gt;yes&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 迭代器的状态： index: 当前的索引，从0开始 count: 当前的索引，从1开始 size：总数 current: even/odd: first last 判断if1&lt;a href="comments.html" th:href="@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;" th:if="$&#123;not #lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt; unless1&lt;a href="comments.html" th:href="@&#123;/comments(prodId=$&#123;prod.id&#125;)&#125;" th:unless="$&#123;#lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt; switch1234567&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt;&lt;/div&gt;&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt; &lt;p th:case="*"&gt;User is some other thing&lt;/p&gt;&lt;/div&gt; th:block12345678910&lt;table&gt; &lt;th:block th:each="user : $&#123;users&#125;"&gt; &lt;tr&gt; &lt;td th:text="$&#123;user.login&#125;"&gt;...&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" th:text="$&#123;user.address&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;/th:block&gt;&lt;/table&gt; 推荐下面写法（编译前看不见） 123456789&lt;table&gt; &lt;tr&gt; &lt;td th:text="$&#123;user.login&#125;"&gt;...&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" th:text="$&#123;user.address&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;!--/*/ &lt;/th:block&gt; /*/--&gt; &lt;/table&gt; th:inlineth:inlineth:inline 可以等于 text , javascript(dart) , none text: [[…]]1&lt;p th:inline=&quot;text&quot;&gt;Hello, [[#&#123;test&#125;]]&lt;/p&gt; javascript: /[[…]]/12345678&lt;script th:inline="javascript"&gt; var username = /*[[ #&#123;test&#125; ]]*/; var name = /*[[ $&#123;param.name[0]&#125;+$&#123;execInfo.templateName&#125;+'-'+$&#123;#dates.createNow()&#125;+'-'+$&#123;#locale&#125; ]]*/;&lt;/script&gt; 1234567891011&lt;script th:inline="javascript"&gt;/*&lt;![CDATA[*/ var username = [[#&#123;test&#125;]]; var name = [[$&#123;param.name[0]&#125;+$&#123;execInfo.templateName&#125;+'-'+$&#123;#dates.createNow()&#125;+'-'+$&#123;#locale&#125;]];/*]]&gt;*/&lt;/script&gt; adding code: /* [+…+]*/1234var x = 23;/*[+var msg = 'Hello, ' + [[$&#123;session.user.name&#125;]]; +]*/var f = function() &#123; removind code: /[- / and /* -]*/1234var x = 23;/*[- */var msg = 'This is a non-working template'; /* -]*/var f = function() &#123;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 内置对象]]></title>
    <url>%2F2013%2F04%2F05%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F%E9%99%84%EF%BC%9AThymeleaf%20%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Thymeleaf 内置对象#dates12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Dates* ======================================================================*//** Format date with the standard locale format* Also works with arrays, lists or sets*/$&#123;#dates.format(date)&#125;$&#123;#dates.arrayFormat(datesArray)&#125;$&#123;#dates.listFormat(datesList)&#125;$&#123;#dates.setFormat(datesSet)&#125;/** Format date with the ISO8601 format* Also works with arrays, lists or sets*/$&#123;#dates.formatISO(date)&#125;$&#123;#dates.arrayFormatISO(datesArray)&#125;$&#123;#dates.listFormatISO(datesList)&#125;$&#123;#dates.setFormatISO(datesSet)&#125;/** Format date with the specified pattern* Also works with arrays, lists or sets*/$&#123;#dates.format(date, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.arrayFormat(datesArray, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.listFormat(datesList, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.setFormat(datesSet, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;/** Obtain date properties* Also works with arrays, lists or sets*/$&#123;#dates.day(date)&#125; // also arrayDay(...), listDay(...), etc.$&#123;#dates.month(date)&#125; // also arrayMonth(...), listMonth(...), etc.$&#123;#dates.monthName(date)&#125; // also arrayMonthName(...), listMonthName(...), etc.$&#123;#dates.monthNameShort(date)&#125; // also arrayMonthNameShort(...), listMonthNameShort(...), etc.$&#123;#dates.year(date)&#125; // also arrayYear(...), listYear(...), etc.$&#123;#dates.dayOfWeek(date)&#125; // also arrayDayOfWeek(...), listDayOfWeek(...), etc.$&#123;#dates.dayOfWeekName(date)&#125; // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc.$&#123;#dates.dayOfWeekNameShort(date)&#125; // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc.$&#123;#dates.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#dates.minute(date)&#125; // also arrayMinute(...), listMinute(...), etc.$&#123;#dates.second(date)&#125; // also arraySecond(...), listSecond(...), etc.$&#123;#dates.millisecond(date)&#125; // also arrayMillisecond(...), listMillisecond(...), etc./** Create date (java.util.Date) objects from its components*/$&#123;#dates.create(year,month,day)&#125;$&#123;#dates.create(year,month,day,hour,minute)&#125;$&#123;#dates.create(year,month,day,hour,minute,second)&#125;$&#123;#dates.create(year,month,day,hour,minute,second)&#125;$&#123;#dates.create(year,month,day,hour,minute,second,millisecond)&#125;/** Create a date (java.util.Date) object for the current date and time*/$&#123;#dates.createNow()&#125;/** Create a date (java.util.Date) object for the current date (time set to 00:00)*/$&#123;#dates.createToday()&#125; #Calendars12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Calendars* ======================================================================*//** Format calendar with the standard locale format* Also works with arrays, lists or sets*/$&#123;#calendars.format(cal)&#125;$&#123;#calendars.arrayFormat(calArray)&#125;$&#123;#calendars.listFormat(calList)&#125;$&#123;#calendars.setFormat(calSet)&#125;/** Format calendar with the ISO8601 format* Also works with arrays, lists or sets*/$&#123;#calendars.formatISO(cal)&#125;$&#123;#calendars.arrayFormatISO(calArray)&#125;$&#123;#calendars.listFormatISO(calList)&#125;$&#123;#calendars.setFormatISO(calSet)&#125;/** Format calendar with the specified pattern* Also works with arrays, lists or sets*/$&#123;#calendars.format(cal, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#calendars.arrayFormat(calArray, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#calendars.listFormat(calList, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#calendars.setFormat(calSet, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;/** Obtain calendar properties* Also works with arrays, lists or sets*/$&#123;#calendars.day(date)&#125; // also arrayDay(...), listDay(...), etc.$&#123;#calendars.month(date)&#125; // also arrayMonth(...), listMonth(...), etc.$&#123;#calendars.monthName(date)&#125; // also arrayMonthName(...), listMonthName(...), etc.$&#123;#calendars.monthNameShort(date)&#125; // also arrayMonthNameShort(...), listMonthNameShort(...), etc.$&#123;#calendars.year(date)&#125; // also arrayYear(...), listYear(...), etc.$&#123;#calendars.dayOfWeek(date)&#125; // also arrayDayOfWeek(...), listDayOfWeek(...), etc.$&#123;#calendars.dayOfWeekName(date)&#125; // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc.$&#123;#calendars.dayOfWeekNameShort(date)&#125; // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc.$&#123;#calendars.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#calendars.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#calendars.minute(date)&#125; // also arrayMinute(...), listMinute(...), etc.$&#123;#calendars.second(date)&#125; // also arraySecond(...), listSecond(...), etc.$&#123;#calendars.millisecond(date)&#125; // also arrayMillisecond(...), listMillisecond(...), etc./** Create calendar (java.util.Calendar) objects from its components*/$&#123;#calendars.create(year,month,day)&#125;$&#123;#calendars.create(year,month,day,hour,minute)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second,millisecond)&#125;/** Create a calendar (java.util.Calendar) object for the current date and time*/$&#123;#calendars.createNow()&#125;/** Create a calendar (java.util.Calendar) object for the current date (time set to 00:00)*/$&#123;#calendars.createToday()&#125; #numbers1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Numbers* ======================================================================*//** ==========================* Formatting integer numbers* ==========================*//** Set minimum integer digits.* Also works with arrays, lists or sets*/$&#123;#numbers.formatInteger(num,3)&#125;$&#123;#numbers.arrayFormatInteger(numArray,3)&#125;$&#123;#numbers.listFormatInteger(numList,3)&#125;$&#123;#numbers.setFormatInteger(numSet,3)&#125;/** Set minimum integer digits and thousands separator:* &apos;POINT&apos;, &apos;COMMA&apos;, &apos;WHITESPACE&apos;, &apos;NONE&apos; or &apos;DEFAULT&apos; (by locale).* Also works with arrays, lists or sets*/$&#123;#numbers.formatInteger(num,3,&apos;POINT&apos;)&#125;$&#123;#numbers.arrayFormatInteger(numArray,3,&apos;POINT&apos;)&#125;$&#123;#numbers.listFormatInteger(numList,3,&apos;POINT&apos;)&#125;$&#123;#numbers.setFormatInteger(numSet,3,&apos;POINT&apos;)&#125;/** ==========================* Formatting decimal numbers* ==========================*//** Set minimum integer digits and (exact) decimal digits.* Also works with arrays, lists or sets*/$&#123;#numbers.formatDecimal(num,3,2)&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2)&#125;$&#123;#numbers.listFormatDecimal(numList,3,2)&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2)&#125;/** Set minimum integer digits and (exact) decimal digits, and also decimal separator.* Also works with arrays, lists or sets*/$&#123;#numbers.formatDecimal(num,3,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.listFormatDecimal(numList,3,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2,&apos;COMMA&apos;)&#125;/** Set minimum integer digits and (exact) decimal digits, and also thousands and* decimal separator.* Also works with arrays, lists or sets*/$&#123;#numbers.formatDecimal(num,3,&apos;POINT&apos;,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,&apos;POINT&apos;,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.listFormatDecimal(numList,3,&apos;POINT&apos;,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.setFormatDecimal(numSet,3,&apos;POINT&apos;,2,&apos;COMMA&apos;)&#125;/** ==========================* Utility methods* ==========================*//** Create a sequence (array) of integer numbers going* from x to y*/$&#123;#numbers.sequence(from,to)&#125;$&#123;#numbers.sequence(from,to,step)&#125; #strings123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Strings* ======================================================================*//** Null-safe toString()*/$&#123;#strings.toString(obj)&#125; // also array*, list* and set*/** Check whether a String is empty (or null). Performs a trim() operation before check* Also works with arrays, lists or sets* * Also works with arrays, lists or sets*/$&#123;#strings.isEmpty(name)&#125;$&#123;#strings.arrayIsEmpty(nameArr)&#125;$&#123;#strings.listIsEmpty(nameList)&#125;$&#123;#strings.setIsEmpty(nameSet)&#125;/** Perform an &apos;isEmpty()&apos; check on a string and return it if false, defaulting to* another specified string if true.* Also works with arrays, lists or sets*/$&#123;#strings.defaultString(text,default)&#125;$&#123;#strings.arrayDefaultString(textArr,default)&#125;$&#123;#strings.listDefaultString(textList,default)&#125;$&#123;#strings.setDefaultString(textSet,default)&#125;/** Check whether a fragment is contained in a String* Also works with arrays, lists or sets*/$&#123;#strings.contains(name,&apos;ez&apos;)&#125; // also array*, list* and set*$&#123;#strings.containsIgnoreCase(name,&apos;ez&apos;)&#125; // also array*, list* and set*/** Check whether a String starts or ends with a fragment* Also works with arrays, lists or sets*/$&#123;#strings.startsWith(name,&apos;Don&apos;)&#125; // also array*, list* and set*$&#123;#strings.endsWith(name,endingFragment)&#125; // also array*, list* and set*/** Substring-related operations* Also works with arrays, lists or sets*/$&#123;#strings.indexOf(name,frag)&#125; // also array*, list* and set*$&#123;#strings.substring(name,3,5)&#125; // also array*, list* and set*$&#123;#strings.substringAfter(name,prefix)&#125; // also array*, list* and set*$&#123;#strings.substringBefore(name,suffix)&#125; // also array*, list* and set*$&#123;#strings.replace(name,&apos;las&apos;,&apos;ler&apos;)&#125; // also array*, list* and set*/** Append and prepend* Also works with arrays, lists or sets*/$&#123;#strings.prepend(str,prefix)&#125; // also array*, list* and set*$&#123;#strings.append(str,suffix)&#125; // also array*, list* and set*/** Change case* Also works with arrays, lists or sets*/$&#123;#strings.toUpperCase(name)&#125; // also array*, list* and set*$&#123;#strings.toLowerCase(name)&#125; // also array*, list* and set*/** Split and join*/$&#123;#strings.arrayJoin(namesArray,&apos;,&apos;)&#125;$&#123;#strings.listJoin(namesList,&apos;,&apos;)&#125;$&#123;#strings.setJoin(namesSet,&apos;,&apos;)&#125;$&#123;#strings.arraySplit(namesStr,&apos;,&apos;)&#125; // returns String[]$&#123;#strings.listSplit(namesStr,&apos;,&apos;)&#125; // returns List&lt;String&gt;$&#123;#strings.setSplit(namesStr,&apos;,&apos;)&#125; // returns Set&lt;String&gt;/** Trim* Also works with arrays, lists or sets*/$&#123;#strings.trim(str)&#125; // also array*, list* and set*/** Compute length* Also works with arrays, lists or sets*/$&#123;#strings.length(str)&#125; // also array*, list* and set*/** Abbreviate text making it have a maximum size of n. If text is bigger, it* will be clipped and finished in &quot;...&quot;* Also works with arrays, lists or sets*/$&#123;#strings.abbreviate(str,10)&#125; // also array*, list* and set*/** Convert the first character to upper-case (and vice-versa)*/$&#123;#strings.capitalize(str)&#125; // also array*, list* and set*$&#123;#strings.unCapitalize(str)&#125; // also array*, list* and set*/** Convert the first character of every word to upper-case*/$&#123;#strings.capitalizeWords(str)&#125; // also array*, list* and set*$&#123;#strings.capitalizeWords(str,delimiters)&#125; // also array*, list* and set*/** Escape the string*/$&#123;#strings.escapeXml(str)&#125; // also array*, list* and set*$&#123;#strings.escapeJava(str)&#125; // also array*, list* and set*$&#123;#strings.escapeJavaScript(str)&#125; // also array*, list* and set*$&#123;#strings.unescapeJava(str)&#125; // also array*, list* and set*$&#123;#strings.unescapeJavaScript(str)&#125; // also array*, list* and set*/** Null-safe comparison and concatenation*/$&#123;#strings.equals(first, second)&#125;$&#123;#strings.equalsIgnoreCase(first, second)&#125;$&#123;#strings.concat(values...)&#125;$&#123;#strings.concatReplaceNulls(nullValue, values...)&#125;/** Random*/$&#123;#strings.randomAlphanumeric(count)&#125; #objects12345678910111213/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Objects* ======================================================================*//** Return obj if it is not null, and default otherwise* Also works with arrays, lists or sets*/$&#123;#objects.nullSafe(obj,default)&#125;$&#123;#objects.arrayNullSafe(objArray,default)&#125;$&#123;#objects.listNullSafe(objList,default)&#125;$&#123;#objects.setNullSafe(objSet,default)&#125; #bools123456789101112131415161718192021222324252627282930313233343536/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Bools* ======================================================================*//** Evaluate a condition in the same way that it would be evaluated in a th:if tag* (see conditional evaluation chapter afterwards).* Also works with arrays, lists or sets*/$&#123;#bools.isTrue(obj)&#125;$&#123;#bools.arrayIsTrue(objArray)&#125;$&#123;#bools.listIsTrue(objList)&#125;$&#123;#bools.setIsTrue(objSet)&#125;/** Evaluate with negation* Also works with arrays, lists or sets*/$&#123;#bools.isFalse(cond)&#125;$&#123;#bools.arrayIsFalse(condArray)&#125;$&#123;#bools.listIsFalse(condList)&#125;$&#123;#bools.setIsFalse(condSet)&#125;/** Evaluate and apply AND operator* Receive an array, a list or a set as parameter*/$&#123;#bools.arrayAnd(condArray)&#125;$&#123;#bools.listAnd(condList)&#125;$&#123;#bools.setAnd(condSet)&#125;/** Evaluate and apply OR operator* Receive an array, a list or a set as parameter*/$&#123;#bools.arrayOr(condArray)&#125;$&#123;#bools.listOr(condList)&#125;$&#123;#bools.setOr(condSet)&#125; #arrays12345678910111213141516171819202122232425262728293031323334/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Arrays* ======================================================================*//** Converts to array, trying to infer array component class.* Note that if resulting array is empty, or if the elements* of the target object are not all of the same class,* this method will return Object[].*/$&#123;#arrays.toArray(object)&#125;/** Convert to arrays of the specified component class.*/$&#123;#arrays.toStringArray(object)&#125;$&#123;#arrays.toIntegerArray(object)&#125;$&#123;#arrays.toLongArray(object)&#125;$&#123;#arrays.toDoubleArray(object)&#125;$&#123;#arrays.toFloatArray(object)&#125;$&#123;#arrays.toBooleanArray(object)&#125;/** Compute length*/$&#123;#arrays.length(array)&#125;/** Check whether array is empty*/$&#123;#arrays.isEmpty(array)&#125;/** Check if element or elements are contained in array*/$&#123;#arrays.contains(array, element)&#125;$&#123;#arrays.containsAll(array, elements)&#125; #lists12345678910111213141516171819202122232425262728/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Lists* ======================================================================*//** Converts to list*/$&#123;#lists.toList(object)&#125;/** Compute size*/$&#123;#lists.size(list)&#125;/** Check whether list is empty*/$&#123;#lists.isEmpty(list)&#125;/** Check if element or elements are contained in list*/$&#123;#lists.contains(list, element)&#125;$&#123;#lists.containsAll(list, elements)&#125;/** Sort a copy of the given list. The members of the list must implement* comparable or you must define a comparator.*/$&#123;#lists.sort(list)&#125;$&#123;#lists.sort(list, comparator)&#125; #sets12345678910111213141516171819202122/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Sets* ======================================================================*//** Converts to set*/$&#123;#sets.toSet(object)&#125;/** Compute size*/$&#123;#sets.size(set)&#125;/** Check whether set is empty*/$&#123;#sets.isEmpty(set)&#125;/** Check if element or elements are contained in set*/$&#123;#sets.contains(set, element)&#125;$&#123;#sets.containsAll(set, elements)&#125; #maps1234567891011121314151617181920/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Maps* ======================================================================*//** Compute size*/$&#123;#maps.size(map)&#125;/** Check whether map is empty*/$&#123;#maps.isEmpty(map)&#125;/** Check if key/s or value/s are contained in maps*/$&#123;#maps.containsKey(map, key)&#125;$&#123;#maps.containsAllKeys(map, keys)&#125;$&#123;#maps.containsValue(map, value)&#125;$&#123;#maps.containsAllValues(map, value)&#125; #aggregates123456789101112131415/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Aggregates* ======================================================================*//** Compute sum. Returns null if array or collection is empty*/$&#123;#aggregates.sum(array)&#125;$&#123;#aggregates.sum(collection)&#125;/** Compute average. Returns null if array or collection is empty*/$&#123;#aggregates.avg(array)&#125;$&#123;#aggregates.avg(collection)&#125; #messages12345678910111213141516171819202122232425262728293031/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Messages* ======================================================================*//** Obtain externalized messages. Can receive a single key, a key plus arguments,* or an array/list/set of keys (in which case it will return an array/list/set of* externalized messages).* If a message is not found, a default message (like &apos;??msgKey??&apos;) is returned.*/$&#123;#messages.msg(&apos;msgKey&apos;)&#125;$&#123;#messages.msg(&apos;msgKey&apos;, param1)&#125;$&#123;#messages.msg(&apos;msgKey&apos;, param1, param2)&#125;$&#123;#messages.msg(&apos;msgKey&apos;, param1, param2, param3)&#125;$&#123;#messages.msgWithParams(&apos;msgKey&apos;, new Object[] &#123;param1, param2, param3, param4&#125;)&#125;$&#123;#messages.arrayMsg(messageKeyArray)&#125;$&#123;#messages.listMsg(messageKeyList)&#125;$&#123;#messages.setMsg(messageKeySet)&#125;/** Obtain externalized messages or null. Null is returned instead of a default* message if a message for the specified key is not found.*/$&#123;#messages.msgOrNull(&apos;msgKey&apos;)&#125;$&#123;#messages.msgOrNull(&apos;msgKey&apos;, param1)&#125;$&#123;#messages.msgOrNull(&apos;msgKey&apos;, param1, param2)&#125;$&#123;#messages.msgOrNull(&apos;msgKey&apos;, param1, param2, param3)&#125;$&#123;#messages.msgOrNullWithParams(&apos;msgKey&apos;, new Object[] &#123;param1, param2, param3, param4&#125;)&#125;$&#123;#messages.arrayMsgOrNull(messageKeyArray)&#125;$&#123;#messages.listMsgOrNull(messageKeyList)&#125;$&#123;#messages.setMsgOrNull(messageKeySet)&#125; #ids1234567891011121314151617181920/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Ids* ======================================================================*//** Normally used in th:id attributes, for appending a counter to the id attribute value* so that it remains unique even when involved in an iteration process.*/$&#123;#ids.seq(&apos;someId&apos;)&#125;/** Normally used in th:for attributes in &lt;label&gt; tags, so that these labels can refer to Ids* generated by means if the #ids.seq(...) function.** Depending on whether the &lt;label&gt; goes before or after the element with the #ids.seq(...)* function, the &quot;next&quot; (label goes before &quot;seq&quot;) or the &quot;prev&quot; function (label goes after* &quot;seq&quot;) function should be called.*/$&#123;#ids.next(&apos;someId&apos;)&#125;$&#123;#ids.prev(&apos;someId&apos;)&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot MyBatis CRUD操作]]></title>
    <url>%2F2013%2F04%2F04%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F044.Spring%20Boot-MyBatis-CRUD%2F</url>
    <content type="text"><![CDATA[CRUD 操作案例代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.funtl.hello.spring.boot;import java.util.Date;import com.funtl.hello.spring.boot.domain.TbUser;import com.funtl.hello.spring.boot.mapper.TbUserMapper;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.transaction.annotation.Transactional;import tk.mybatis.mapper.entity.Example;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest@Transactional@Rollbackpublic class HelloSpringBootApplicationTests &#123; /** * 注入 DAO */ @Autowired private TbUserMapper tbUserMapper; /** * 查询 */ @Test public void testSelectAll() &#123; List&lt;TbUser&gt; tbUsers = tbUserMapper.selectAll(); tbUsers.forEach(tbUser -&gt; &#123; System.out.println(tbUser); &#125;); &#125; /** * 条件查询 */ @Test public void testSelectCondition() &#123; Example example = new Example(TbUser.class); example.createCriteria().andEqualTo("username", "zhangsan"); List&lt;TbUser&gt; tbUsers = tbUserMapper.selectByExample(example); tbUsers.forEach(tbUser -&gt; &#123; System.out.println(tbUser); &#125;); &#125; /** * 新增 */ @Test public void testInsert() &#123; TbUser tbUser = new TbUser(); tbUser.setUsername("Lusifer"); tbUser.setPassword("123456"); tbUser.setPhone("15888888888"); tbUser.setEmail("topsale@vip.qq.com"); tbUser.setCreated(new Date()); tbUser.setUpdated(new Date()); tbUserMapper.insert(tbUser); &#125; /** * 更新 */ @Test public void testUpdate() &#123; TbUser tbUser = tbUserMapper.selectByPrimaryKey(37L); tbUser.setUsername("Happy"); tbUserMapper.updateByPrimaryKey(tbUser); &#125; /** * 修改 */ @Test public void testDelete() &#123; tbUserMapper.deleteByPrimaryKey(37L); &#125; /** * 分页 */ @Test public void testPage() &#123; Example example = new Example(TbUser.class); example.createCriteria().andLike("username", "z%"); PageHelper.startPage(1, 5); PageInfo&lt;TbUser&gt; pageInfo = new PageInfo&lt;&gt;(tbUserMapper.selectByExample(example)); System.out.println(pageInfo.getTotal()); System.out.println(pageInfo.getPages()); pageInfo.getList().forEach(tbUser -&gt; &#123; System.out.println(tbUser); &#125;); &#125;&#125;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码生成插件]]></title>
    <url>%2F2013%2F04%2F03%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F043.Spring%20Boot-MyBatis-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[代码生成插件概述我们无需手动编写 实体类、DAO、XML 配置文件，只需要使用 MyBatis 提供的一个 Maven 插件就可以自动生成所需的各种文件便能够满足基本的业务需求，如果业务比较复杂只需要修改相关文件即可。 配置插件在 pom.xml 文件中增加 mybatis-generator-maven-plugin 插件 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;4.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 注意： configurationFile 自动生成所需的配置文件路径 自动生成的配置在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 引入数据库连接配置 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;context id="Mysql" targetRuntime="MyBatis3Simple" defaultModelType="flat"&gt; &lt;property name="beginningDelimiter" value="`"/&gt; &lt;property name="endingDelimiter" value="`"/&gt; &lt;!-- 配置 tk.mybatis 插件 --&gt; &lt;plugin type="tk.mybatis.mapper.generator.MapperPlugin"&gt; &lt;property name="mappers" value="com.funtl.utils.MyMapper"/&gt; &lt;/plugin&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;jdbc.driverClass&#125;" connectionURL="$&#123;jdbc.connectionURL&#125;" userId="$&#123;jdbc.username&#125;" password="$&#123;jdbc.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- 配置实体类存放路径 --&gt; &lt;javaModelGenerator targetPackage="com.funtl.hello.spring.boot.domain" targetProject="src/main/java"/&gt; &lt;!-- 配置 XML 存放路径 --&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"/&gt; &lt;!-- 配置 DAO 存放路径 --&gt; &lt;javaClientGenerator targetPackage="com.funtl.hello.spring.boot.mapper" targetProject="src/main/java" type="XMLMAPPER"/&gt; &lt;!-- 配置需要指定生成的数据库和表，% 代表所有表 --&gt; &lt;table catalog="myshop" tableName="%"&gt; &lt;!-- 默认为 false，如果设置为 true，在生成的 SQL 中，table 名字不会加上 catalog 或 schema --&gt; &lt;property name="ignoreQualifiersAtRuntime" value="true"/&gt; &lt;!-- mysql 配置 --&gt; &lt;generatedKey column="id" sqlStatement="Mysql" identity="true"/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 配置数据源在 src/main/resources 目录下创建 jdbc.properties 数据源配置： 1234jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.connectionURL=jdbc:mysql://192.168.141.130:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsejdbc.username=rootjdbc.password=123456 插件自动生成12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091mvn mybatis-generator:generate# 输出如下"C:\Program Files\Java\jdk1.8.0_181\bin\java.exe" -Dvisualvm.id=757855494303000 -Dmaven.multiModuleProjectDirectory=D:\Workspace\Study\other\hello-spring-boot "-Dmaven.home=C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.3\plugins\maven\lib\maven3" "-Dclassworlds.conf=C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.3\plugins\maven\lib\maven3\bin\m2.conf" "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.3\lib\idea_rt.jar=64651:C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.3\bin" -Dfile.encoding=UTF-8 -classpath "C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.3\plugins\maven\lib\maven3\boot\plexus-classworlds-2.5.2.jar" org.codehaus.classworlds.Launcher -Didea.version2019.1.3 --update-snapshots -s D:\apache-maven-3.6.1\conf\settings.xml org.mybatis.generator:mybatis-generator-maven-plugin:1.3.7:generate[INFO] Scanning for projects...[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building hello-spring-boot 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- mybatis-generator-maven-plugin:1.3.7:generate (default-cli) @ hello-spring-boot ---[INFO] Connecting to the Database[INFO] Introspecting table myshop..%[INFO] Generating Record class for table myshop..tb_item_param_item[INFO] Generating Mapper Interface for table myshop..tb_item_param_item[INFO] Generating SQL Map for table myshop..tb_item_param_item[INFO] Generating Record class for table myshop..tb_item_cat[INFO] Generating Mapper Interface for table myshop..tb_item_cat[INFO] Generating SQL Map for table myshop..tb_item_cat[INFO] Generating Record class for table myshop..tb_order[INFO] Generating Mapper Interface for table myshop..tb_order[INFO] Generating SQL Map for table myshop..tb_order[INFO] Generating Record class for table myshop..tb_content[INFO] Generating Mapper Interface for table myshop..tb_content[INFO] Generating SQL Map for table myshop..tb_content[INFO] Generating Record class for table myshop..tb_order_item[INFO] Generating Mapper Interface for table myshop..tb_order_item[INFO] Generating SQL Map for table myshop..tb_order_item[INFO] Generating Record class for table myshop..tb_item[INFO] Generating Mapper Interface for table myshop..tb_item[INFO] Generating SQL Map for table myshop..tb_item[INFO] Generating Record class for table myshop..tb_item_desc[INFO] Generating Mapper Interface for table myshop..tb_item_desc[INFO] Generating SQL Map for table myshop..tb_item_desc[INFO] Generating Record class for table myshop..tb_item_param[INFO] Generating Mapper Interface for table myshop..tb_item_param[INFO] Generating SQL Map for table myshop..tb_item_param[INFO] Generating Record class for table myshop..tb_order_shipping[INFO] Generating Mapper Interface for table myshop..tb_order_shipping[INFO] Generating SQL Map for table myshop..tb_order_shipping[INFO] Generating Record class for table myshop..tb_user[INFO] Generating Mapper Interface for table myshop..tb_user[INFO] Generating SQL Map for table myshop..tb_user[INFO] Generating Record class for table myshop..tb_content_category[INFO] Generating Mapper Interface for table myshop..tb_content_category[INFO] Generating SQL Map for table myshop..tb_content_category[INFO] Saving file TbItemParamItemMapper.xml[INFO] Saving file TbItemCatMapper.xml[INFO] Saving file TbOrderMapper.xml[INFO] Saving file TbContentMapper.xml[INFO] Saving file TbOrderItemMapper.xml[INFO] Saving file TbItemMapper.xml[INFO] Saving file TbItemDescMapper.xml[INFO] Saving file TbItemParamMapper.xml[INFO] Saving file TbOrderShippingMapper.xml[INFO] Saving file TbUserMapper.xml[INFO] Saving file TbContentCategoryMapper.xml[INFO] Saving file TbItemParamItem.java[INFO] Saving file TbItemParamItemMapper.java[INFO] Saving file TbItemCat.java[INFO] Saving file TbItemCatMapper.java[INFO] Saving file TbOrder.java[INFO] Saving file TbOrderMapper.java[INFO] Saving file TbContent.java[INFO] Saving file TbContentMapper.java[INFO] Saving file TbOrderItem.java[INFO] Saving file TbOrderItemMapper.java[INFO] Saving file TbItem.java[INFO] Saving file TbItemMapper.java[INFO] Saving file TbItemDesc.java[INFO] Saving file TbItemDescMapper.java[INFO] Saving file TbItemParam.java[INFO] Saving file TbItemParamMapper.java[INFO] Saving file TbOrderShipping.java[INFO] Saving file TbOrderShippingMapper.java[INFO] Saving file TbUser.java[INFO] Saving file TbUserMapper.java[INFO] Saving file TbContentCategory.java[INFO] Saving file TbContentCategoryMapper.java[WARNING] Column id, specified as an identity column in table myshop..tb_order, does not exist in the table.[WARNING] Column id, specified as an identity column in table myshop..tb_item_desc, does not exist in the table.[WARNING] Column id, specified as an identity column in table myshop..tb_order_shipping, does not exist in the table.[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.892 s[INFO] Finished at: 2019-06-24T03:40:09+08:00[INFO] Final Memory: 30M/634M[INFO] ------------------------------------------------------------------------Process finished with exit code 0 附：扩展阅读完整配置案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN""http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt;&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项 resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties. 注意，两个属性只能选址一个; 另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用&lt;properties resource="" url="" /&gt; --&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包 location属性指明加载jar/zip包的全路径&lt;classPathEntry location="/Program Files/IBM/SQLLIB/java/db2java.zip" /&gt; --&gt; &lt;!-- context:生成一组对象的环境 id:必选，上下文id，用于在生成错误时提示 defaultModelType:指定生成对象的样式 1，conditional：类似hierarchical； 2，flat：所有内容（主键，blob）等全部生成在一个对象中； 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class) targetRuntime: 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample； 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample； introspectedColumnImpl：类全限定名，用于扩展MBG--&gt;&lt;context id="mysql" defaultModelType="hierarchical" targetRuntime="MyBatis3Simple" &gt; &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt; &lt;property name="autoDelimitKeywords" value="false"/&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name="javaFileEncoding" value="UTF-8"/&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name="javaFormatter" value="org.mybatis.generator.api.dom.DefaultJavaFormatter"/&gt; &lt;!-- 格式化XML代码 --&gt; &lt;property name="xmlFormatter" value="org.mybatis.generator.api.dom.DefaultXmlFormatter"/&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt; &lt;property name="beginningDelimiter" value="`"/&gt; &lt;property name="endingDelimiter" value="`"/&gt; &lt;!-- 必须要有的，使用这个配置链接数据库 @TODO:是否可以扩展 # MySQL 8.x: com.mysql.cj.jdbc.Driver --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql:///pss" userId="root" password="admin"&gt; &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt; &lt;/jdbcConnection&gt; &lt;!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --&gt; &lt;javaTypeResolver type="org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl"&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length&lt;5：使用Short； --&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --&gt; &lt;javaModelGenerator targetPackage="com._520it.mybatis.domain" targetProject="src/main/java"&gt; &lt;!-- for MyBatis3/MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --&gt; &lt;property name="constructorBased" value="false"/&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;!-- for MyBatis3 / MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;!-- 设置一个根对象， 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括： 1，属性名相同，类型相同，有相同的getter/setter方法； --&gt; &lt;property name="rootClass" value="com._520it.mybatis.domain.BaseDomain"/&gt; &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage/targetProject:同javaModelGenerator --&gt; &lt;sqlMapGenerator targetPackage="com._520it.mybatis.mapper" targetProject="src/main/resources"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage/targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --&gt; &lt;javaClientGenerator targetPackage="com._520it.mybatis.mapper" type="ANNOTATEDMAPPER" targetProject="src/main/java"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 &lt;property name="rootInterface" value=""/&gt; --&gt; &lt;/javaClientGenerator&gt; &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素 选择的table会生成一下文件： 1，SQL map文件 2，生成一个主键类； 3，除了BLOB和主键的其他字段的类； 4，包含BLOB的类； 5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选； 6，Mapper接口（可选） tableName（必要）：要生成对象的表名； 注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会 根据设置的schema，catalog或tablename去查询数据表，按照下面的流程： 1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询； 2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找； 3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找； 4，否则，使用指定的大小写格式查询； 另外的，如果在创建表的时候，使用的""把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名； 这个时候，请设置delimitIdentifiers="true"即可保留大小写格式； 可选： 1，schema：数据库的schema； 2，catalog：数据库的catalog； 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面； 5，enableInsert（默认true）：指定是否生成insert语句； 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）； 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句； 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)； 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）； 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句； 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）； 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）； 13，modelType：参考context元素的defaultModelType，相当于覆盖； 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性） 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性 注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写； --&gt; &lt;table tableName="userinfo" &gt; &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt; &lt;property name="constructorBased" value="false"/&gt; &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt; &lt;property name="ignoreQualifiersAtRuntime" value="false"/&gt; &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt; &lt;property name="modelOnly" value="false"/&gt; &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 &lt;property name="rootClass" value=""/&gt; --&gt; &lt;!-- 参考javaClientGenerator 的 rootInterface 属性 &lt;property name="rootInterface" value=""/&gt; --&gt; &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog &lt;property name="runtimeCatalog" value=""/&gt; --&gt; &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema &lt;property name="runtimeSchema" value=""/&gt; --&gt; &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename &lt;property name="runtimeTableName" value=""/&gt; --&gt; &lt;!-- 注意，该属性只针对MyBatis3Simple有用； 如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件； --&gt; &lt;property name="selectAllOrderByClause" value="age desc,username asc"/&gt; &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt; &lt;property name="useActualColumnNames" value="false"/&gt; &lt;!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选 column:主键的列名； sqlStatement：要生成的selectKey语句，有以下可选项： Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() Informix :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1 MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY JDBC :相当于在生成的insert元素上添加useGeneratedKeys="true"和keyProperty属性 &lt;generatedKey column="" sqlStatement=""/&gt; --&gt; &lt;!-- 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候， 比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等； 那么就可以设置searchString为"^CUST_"，并使用空白替换，那么生成的Customer对象中的属性名称就不是 custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email； 注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的， 如果使用了columnOverride元素，该属性无效； &lt;columnRenamingRule searchString="" replaceString=""/&gt; --&gt; &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性； column:要重新设置的列名； 注意，一个table元素中可以有多个columnOverride元素哈~ --&gt; &lt;columnOverride column="username"&gt; &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt; &lt;property name="property" value="userName"/&gt; &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名 &lt;property name="javaType" value=""/&gt; --&gt; &lt;!-- jdbcType用于指定该列的JDBC类型 &lt;property name="jdbcType" value=""/&gt; --&gt; &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述 &lt;property name="jdbcType" value=""/&gt; --&gt; &lt;!-- 参考table元素的delimitAllColumns配置，默认为false &lt;property name="delimitedColumnName" value=""/&gt; --&gt; &lt;/columnOverride&gt; &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 column:指定要忽略的列的名字； delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false 注意，一个table元素中可以有多个ignoreColumn元素 &lt;ignoreColumn column="deptId" delimitedColumnName=""/&gt; --&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 整合 TkMyBatis]]></title>
    <url>%2F2013%2F04%2F02%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F042.Spring%20Boot-MyBatis-TkMyBatis%2F</url>
    <content type="text"><![CDATA[Spring Boot 整合 TkMyBatis什么是 TkMyBatistk.mybatis 是在 MyBatis 框架的基础上提供了很多工具，让开发更加高效 POM在 pom.xml 文件中引入 mapper-spring-boot-starter 依赖，该依赖会自动引入 MyBaits 相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt;&lt;/dependency&gt; application.yml1234mybatis: # 实体类的存放路径 type-aliases-package: com.funtl.hello.spring.boot.domain mapper-locations: classpath:mapper/*.xml 创建通用父级接口主要作用是让 DAO 层的接口继承该接口，以达到使用 tk.mybatis 的目的 1234567891011121314151617package tk.mybatis.mapper;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * &lt;p&gt;Title: MyMapper&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * * @author Lusifer * @version 1.0.0 * @date 2018/5/29 0:57 */public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123;&#125; 什么是 PageHelperPageHelper 是 Mybatis 的分页插件，支持多数据库、多数据源。可以简化数据库的分页查询操作，整合过程也极其简单，只需引入依赖即可。 POM在 pom.xml 文件中引入 pagehelper-spring-boot-starter 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 整合 HikariCP]]></title>
    <url>%2F2013%2F04%2F01%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F041.Spring%20Boot-MyBatis-HikariCP%2F</url>
    <content type="text"><![CDATA[Spring Boot 整合 HikariCP什么是 HikariCPHiKariCP 是数据库连接池的一个后起之秀，号称性能最好，可以完美地 PK 掉其他连接池。是一个高性能的 JDBC 连接池，基于 BoneCP 做了不少的改进和优化。超快，快到连 Spring Boot 2 都宣布支持了。 官方 GitHub 地址 什么是 BoneCP传说中 BoneCP 在快速这个特点上做到了极致，官方数据是 C3P0 等的 25 倍左右，以下为性能测试报告。 单线程 1,000,000 获取连接/释放连接请求 获取/释放连接之间没有延迟 连接池范围：20-50 增量：5 线程：1 分区：1 多线程 500 个线程分别获取释放 100 个连接 在获取连接和释放连接之间引入了 10ms 的延迟 Thread.sleep()，模拟连接完成工作 连接池范围：50-200 增量：5 线程：5 Prepared Statement 500 个线程分别获取释放 100 个连接 无延迟 连接池范围：50-200 增量：5 线程：5 为什么需要 HikariCPBoneCP 作者放弃维护，并在 Github 项目主页推荐大家使用 HikariCP，Hikari（ひかり[shi ga li]） 来自日文，是 光 的意思。这个产品的口号是 快速、简单、可靠 优化 字节码精简 ： 优化代码，直到编译后的字节码最少，这样，CPU 缓存可以加载更多的程序代码 优化代理和拦截器 ： 减少代码，例如 HikariCP 的 Statement proxy 只有 100 行代码，只有 BoneCP 的十分之一 自定义数组类型（FastStatementList）代替 ArrayList ： 避免每次 get() 调用都要进行 range check，避免调用 remove() 时的从头到尾的扫描 自定义集合类型（ConcurrentBag）： 提高并发读写的效率 其他针对 BoneCP 缺陷的优化： 比如对于耗时超过一个 CPU 时间片的方法调用的研究（但没说具体怎么优化） 代码量几个连接池的代码量对比（代码量越少，一般意味着执行效率越高、发生 BUG 的可能性越低） Pool Files Code Vibur 34 1927 HikariCP 21 2228 Tomcat 31 6345 BoneCP 49 7293 C3P0 120 15550 速度别人发推文测试 Hikari 速度 稳定性 可靠性另外，关于可靠性方面，也是有实验和数据支持的。对于数据库连接中断的情况，通过测试 getConnection()，各种 CP 的不相同处理方法如下（所有 CP 都配置了跟 connectionTimeout 类似的参数为 5 秒钟） HikariCP(A)： 等待 5 秒钟后，如果连接还是没有恢复，则抛出一个 SQLExceptions 异常；后续的 getConnection() 也是一样处理 C3P0(C-)： 完全没有反应，没有提示，也不会在 CheckoutTimeout 配置的时长超时后有任何通知给调用者；然后等待 2 分钟后终于醒来了，返回一个 error Tomcat(F)： 返回一个 connection，然后调用者如果利用这个无效的 connection 执行 SQL 语句 结果可想而知；大约 55 秒之后终于醒来了，这时候的 getConnection() 终于可以返回一个 error，但没有等待参数配置的 5 秒钟，而是立即返回 error BoneCP(C)： 跟 Tomcat 的处理方法一样；也是大约 55 秒之后才醒来，有了正常的反应，并且终于会等待 5 秒钟之后返回 error 了 整合 HikariCPPOM1234567891011121314151617181920212223&lt;!-- 主要增加 HikariCP 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;$&#123;hikaricp.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除 tomcat-jdbc 以使用 HikariCP --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- MySQL 驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;&lt;/dependency&gt; application.yml12345678910111213141516spring: datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.141.130:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 hikari: minimum-idle: 5 idle-timeout: 600000 maximum-pool-size: 10 auto-commit: true pool-name: MyHikariCP max-lifetime: 1800000 connection-timeout: 30000 connection-test-query: SELECT 1 注意： 具体使用方法在 测试 MyBatis 操作数据库 时进行介绍，此处仅为准备环节]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个 Thymeleaf 页面]]></title>
    <url>%2F2013%2F03%2F31%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F040.Spring%20Boot-Thymeleaf-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[第一个 Thymeleaf 页面引入依赖主要增加 spring-boot-starter-thymeleaf 和 nekohtml 这两个依赖 spring-boot-starter-thymeleaf：Thymeleaf 自动配置 nekohtml：允许使用非严格的 HTML 语法 完整的 pom.xml 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-boot&lt;/name&gt; &lt;description&gt;&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.boot.HelloSpringBootApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置 Thymeleaf在 application.yml 配置 Thymeleaf 1234567spring: thymeleaf: cache: false # 开发时关闭缓存,不然没法看到实时页面 mode: HTML # 用非严格的 HTML encoding: UTF-8 servlet: content-type: text/html 创建测试用 JavaBean创建一个测试效果的 JavaBean，简单封装一下即可 12345678910111213141516171819202122232425package com.funtl.hello.spring.boot.entity;import java.io.Serializable;public class PersonBean implements Serializable &#123; private String name; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 创建测试用 Controller创建一个 Controller，造一些测试数据并设置跳转 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.funtl.hello.spring.boot.controller;import com.funtl.hello.spring.boot.entity.PersonBean;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.ArrayList;import java.util.List;@Controller@RequestMapping(value = "thymeleaf")public class IndexController &#123; @RequestMapping(value = "index", method = RequestMethod.GET) public String index(Model model) &#123; PersonBean person = new PersonBean(); person.setName("张三"); person.setAge(22); List&lt;PersonBean&gt; people = new ArrayList&lt;&gt;(); PersonBean p1 = new PersonBean(); p1.setName("李四"); p1.setAge(23); people.add(p1); PersonBean p2 = new PersonBean(); p2.setName("王五"); p2.setAge(24); people.add(p2); PersonBean p3 = new PersonBean(); p3.setName("赵六"); p3.setAge(25); people.add(p3); model.addAttribute("person", person); model.addAttribute("people", people); return "index"; &#125;&#125; 创建测试页面在 templates 目录下创建 index.html 文件，代码如下： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello Thymeleaf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;访问 Model：&lt;/span&gt;&lt;span th:text="$&#123;person.name&#125;"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;访问列表&lt;/span&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each="human : $&#123;people&#125;"&gt; &lt;td th:text="$&#123;human.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;human.age&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 修改 html 标签用于引入 thymeleaf 引擎，这样才可以在其他标签里使用 th:* 语法，声明如下： 12&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt; 测试访问启动成功后，访问：http://localhost:9090/thymeleaf/index 即可看到效果]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 简介]]></title>
    <url>%2F2013%2F03%2F30%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F039.Spring%20Boot-Thymeleaf-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Thymeleaf 简介什么是 ThymeleafThymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点 Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板 + 数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 Thymeleaf 开箱即用的特性。它提供标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式效果，避免每天套模板、改 JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 Thymeleaf 提供 Spring 标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 为什么需要 Thymeleaf如果希望以 Jar 形式发布模块则尽量不要使用 JSP 相关知识，这是因为 JSP 在内嵌的 Servlet 容器上运行有一些问题 (内嵌 Tomcat、 Jetty 不支持 Jar 形式运行 JSP，Undertow 不支持 JSP)。 Spring Boot 中推荐使用 Thymeleaf 作为模板引擎，因为 Thymeleaf 提供了完美的 Spring MVC 支持，Spring Boot 提供了大量模板引擎，包括： FreeMarker Groovy Mustache Thymeleaf Velocity Beetl]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 常用配置]]></title>
    <url>%2F2013%2F03%2F29%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F038.Spring%20Boot-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Spring Boot 常用配置概述本章节主要介绍一下 Spring Boot 中的一些常用配置，比如：自定义 Banner、配置日志、关闭特定的自动配置等。 自定义 Banner在 Spring Boot 启动的时候会有一个默认的启动图案 . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.1.6.RELEASE) 我们在 src/main/resources 目录下新建一个 banner.txt 通过 http://patorjk.com/software/taag 网站生成字符串，将网站生成的字符复制到 banner.txt 中 再次运行这个程序 1234567891011121314151617181920212223$&#123;AnsiColor.BRIGHT_RED&#125;////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88&quot; . &quot;88 //// (| ^_^ |) //// O\ = /O //// ____/`---&apos;\____ //// .&apos; \\| |// `. //// / \\||| : |||// \ //// / _||||| -:- |||||- \ //// | | \\\ - /// | | //// | \_| &apos;&apos;\---/&apos;&apos; | | //// \ .-\__ `-` ___/-. / //// ___`. .&apos; /--.--\ `. . ___ //// .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. //// | | : `- \`.;`\ _ /`;.`/ - ` : | | //// \ \ `-. \_ __\ /__ _/ .-` / / //// ========`-.____`-.___\_____/___.-`____.-&apos;======== //// `=---=&apos; //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永不宕机 永无BUG ////////////////////////////////////////////////////////////////////// 常用属性设置： ${AnsiColor.BRIGHT_RED}：设置控制台中输出内容的颜色 ${application.version}：用来获取 MANIFEST.MF 文件中的版本号 ${application.formatted-version}：格式化后的 ${application.version} 版本信息 ${spring-boot.version}：Spring Boot 的版本号 ${spring-boot.formatted-version}：格式化后的 ${spring-boot.version} 版本信息 配置文件Spring Boot 项目使用一个全局的配置文件 application.properties 或者是 application.yml，在 resources 目录下或者类路径下的 /config 下，一般我们放到 resources 下。 修改 Tomcat 的端口为 9090，并将默认的访问路径 “/“ 修改为 “boot”，可以在 application.properties 中添加： 12server.port=9090server.context-path=/boot 或在 application.yml 中添加： 123server: port: 9090 context-path: /boot 测试效果： 更多配置 Starter POMSpring Boot 为我们提供了简化企业级开发绝大多数场景的 starter pom ，只要使用了应用场景所需要的 starter pom ，相关的技术配置将会消除，就可以得到 Spring Boot 为我们提供的自动配置的 Bean。 更多 Starter POM 日志配置Spring Boot 对各种日志框架都做了支持，我们可以通过配置来修改默认的日志的配置 默认情况下，Spring Boot 使用 Logback 作为日志框架 123logging: file: ../logs/spring-boot-hello.log level.org.springframework.web: DEBUG 关闭特定的自动配置关闭特定的自动配置使用 @SpringBootApplication 注解的 exclude 参数即可，这里以关闭数据源的自动配置为例 1@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 单元测试]]></title>
    <url>%2F2013%2F03%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F037.Spring%20Boot-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Spring Boot 单元测试概述主要是通过 @RunWith 和 @SpringBootTest 注解来开启单元测试功能 1234567891011121314151617181920212223242526272829303132333435363738394041package com.funtl.hello.spring.boot;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.boot.web.server.LocalServerPort;import org.springframework.http.ResponseEntity;import org.springframework.test.context.junit4.SpringRunner;import java.net.URL;import static org.hamcrest.CoreMatchers.equalTo;import static org.junit.Assert.assertThat;@RunWith(SpringRunner.class)@SpringBootTest(classes = HelloSpringBootApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class HelloSpringBootApplicationTests &#123; @LocalServerPort private int port; private URL base; @Autowired private TestRestTemplate template; @Before public void setUp() throws Exception &#123; this.base = new URL("http://localhost:" + port + "/"); &#125; @Test public void contextLoads() &#123; ResponseEntity&lt;String&gt; response = template.getForEntity(base.toString(), String.class); assertThat(response.getBody(), equalTo("Hello Spring Boot")); &#125;&#125; 运行它会先启动 Spring Boot 工程，再启动单元测试]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个 SpringBoot 应用程序]]></title>
    <url>%2F2013%2F03%2F27%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F036.Spring%20Boot-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[第一个 Spring Boot 应用程序创建项目这里我们使用 Intellij IDEA 来新建一个 Spring Boot 项目。 Spring 初始化器 填写项目信息 选择版本和依赖 保存项目到指定目录 工程目录结构创建完成后的工程目录结构如下： 123456789101112131415161718192021222324252627│ .gitignore│ pom.xml││└─src ├─main │ ├─java │ │ └─com │ │ └─funtl │ │ └─hello │ │ └─spring │ │ └─boot │ │ HelloSpringBootApplication.java │ │ │ └─resources │ │ application.properties │ │ │ ├─static │ └─templates └─test └─java └─com └─funtl └─hello └─spring └─boot HelloSpringBootApplicationTests.java .gitignore：Git 过滤配置文件 pom.xml：Maven 的依赖管理配置文件 HelloSpringBootApplication.java：程序入口 resources：资源文件目录 static: 静态资源文件目录 templates：模板资源文件目录 application.properties：Spring Boot 的配置文件，实际开发中会替换成 YAML 语言配置（application.yml） POM12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello-spring-boot&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.boot.HelloSpringBootApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; parent：继承了 Spring Boot 的 Parent，表示我们是一个 Spring Boot 工程 spring-boot-starter-web：包含了 spring-boot-starter 还自动帮我们开启了 Web 支持 功能演示我们创建一个 Controller 来演示一下 Spring Boot 的神奇功能 123456789101112package com.funtl.hello.spring.boot.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @GetMapping(value = "/") public String sayHi() &#123; return "Hello Spring Boot."; &#125;&#125; 启动 HelloSpringBootApplication 的 main() 方法，浏览器访问 http://localhost:8080 可以看到： 1Hello Spring Boot. 神奇之处 没有配置 web.xml 没有配置 application.xml，Spring Boot 帮你配置了 没有配置 application-mvc.xml，Spring Boot 帮你配置了 没有配置 Tomcat，Spring Boot 内嵌了 Tomcat 容器]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务设计模式]]></title>
    <url>%2F2013%2F03%2F26%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay60_%E5%86%8D%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F034.%E5%86%8D%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[微服务设计模式微服务架构需要考虑的问题 API Gateway 服务间调用 服务发现 服务容错 服务部署 数据调用 聚合器微服务设计模式这是一种最常见也最简单的设计模式 聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的 WEB 页面，将检索到的数据进行处理展示。它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步发布成一个新的微服务，这符合 DRY 原则。另外，每个服务都有自己的缓存和数据库。如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿 X轴 和 Z轴 独立扩展。 代理微服务设计模式这是聚合模式的一个变种，如下图所示 在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。 链式微服务设计模式这种模式在接收到请求后会产生一个经过合并的响应，如下图所示 在这种情况下，服务A 接收到请求后会与 服务B 进行通信，类似地，服务B 会同 服务C 进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。因此，服务调用链不宜过长，以免客户端长时间等待。 分支微服务设计模式这种模式是聚合器模式的扩展，允许同时调用两个微服务链，如下图所示 数据共享微服务设计模式自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的“单体应用（Monolithic Application）”时，SQL 数据库反规范化可能会导致数据重复和不一致。因此，在单体应用到微服务架构的过渡阶段，可以使用这种设计模式，如下图所示 在这种情况下，部分微服务可能会共享缓存和数据库存储。不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式。 异步消息传递微服务设计模式虽然 REST 设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替 REST 请求/响应，如下图所示 新架构新起点对于微服务架构，最重要的是思维上的转变，技术不是问题，思想才是王道（有道无术，术尚可求，有术无道，止于术），对于做微服务开发的几点建议： 应用程序的核心是业务逻辑，按照业务或客户需求组织资源（这是最难的） 做有生命的产品，而不是项目 全栈化 后台服务贯彻 Single Responsibility Principle（单一职责原则） VM -&gt; Docker -&gt; Kubernetes -&gt; Istio DevOps]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 简介]]></title>
    <url>%2F2013%2F03%2F26%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay61_Spring%20Boot%2F035.Spring%20Boot-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Spring Boot 简介概述Spring Boot 可以称之为 新一代 JavaEE 开发标准；随着动态语言的流行 (Ruby、Groovy、Scala、Node.js)，Java 的开发显得格外的笨重：繁多的配置、低下的开发效率、复杂的部署流程以及第三方技术集成难度大。 在上述环境下，Spring Boot 应运而生。它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速的运行起来。使用 Spring Boot 很容易创建一个独立运行（运行 Jar，内嵌 Servlet 容器）准生产级别的基于 Spring 框架的项目，使用 Spring Boot 你可以不用或者只需很少的 Spring 配置。 Spring 简史Spring 1.x 时代在 Spring1.x 时代，都是通过 xml 文件配置 bean，随着项目的不断扩大，需要将 xml 配置分放到不同的配置文件中，需要频繁的在 java 类和 xml 配置文件中切换。 Spring 2.x 时代随着 JDK 1.5 带来的注解支持，Spring2.x 可以使用注解对 Bean 进行申明和注入，大大的减少了 xml 配置文件，同时也大大简化了项目的开发。 那么，问题来了，究竟是应该使用 xml 还是注解呢？ 最佳实践： 应用的基本配置用 xml，比如：数据源、资源文件等 业务开发用注解，比如：Service 中注入 bean 等 Spring 3.x 时代从 Spring3.x 开始提供了 Java 配置方式，使用 Java 配置方式可以更好的理解你配置的 Bean，现在我们就处于这个时代，并且 Spring4.x 和 Spring boot 都推荐使用 java 配置的方式。 Spring 5.x 时代Spring5.x 是 Java 界首个支持响应式的 Web 框架，是 Spring 的一个重要版本，距离 Spring4.x 差不多四年。在此期间，大多数增强都是在 Spring Boot 项目中完成的，其最大的亮点就是提供了完整的端到端响应式编程的支持（新增 Spring WebFlux 模块）。 Spring WebFlux 同时支持使用旧的 Spring MVC 注解声明 Reactive Controller。和传统的 MVC Controller 不同，Reactive Controller 操作的是 非阻塞 的 ServerHttpRequest 和 ServerHttpResponse，而不再是 Spring MVC 里的 HttpServletRequest 和 HttpServletResponse。 至此也代表着 Java 正式迎来了响应式异步编程的时代。 Spring Boot 优缺点优点 快速构建项目 对主流开发框架的无配置集成 项目可独立运行，无需外部依赖 Servlet 容器 提供运行时的应用监控 极大地提高了开发、部署效率 与云计算的天然集成 缺点 版本迭代速度很快，一些模块改动很大 由于不用自己做配置，报错时很难定位]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务的实践]]></title>
    <url>%2F2013%2F03%2F25%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay60_%E5%86%8D%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F033.%E5%86%8D%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[微服务的实践概述要实际的应用微服务，需要解决以下问题： 客户端如何访问这些服务 每个服务之间如何通信 如此多的服务，如何实现？ 服务挂了，如何解决？（备份方案，应急处理机制） 客户端如何访问这些服务原来的 Monolithic 方式开发，所有的服务都是本地的，UI 可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在独立的虚拟机上的 Java 进程了。客户端 UI 如何访问他？ 后台有 N 个服务，前台就需要记住管理 N 个服务，一个服务 下线、更新、升级，前台就要重新部署，这明显不服务我们拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。 另外，N 个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。 所以，一般在后台 N 个服务和 UI 之间一般会一个代理或者叫 API Gateway，他的作用包括： 提供统一服务入口，让微服务对前台透明 聚合后台的服务，节省流量，提升性能 提供安全，过滤，流控等API管理功能 其实这个 API Gateway 可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的 MVC 框架，甚至是一个 Node.js 的服务端。他们最重要的作用是为前台（通常是移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合，不过 API Gateway 也有可能成为 单点故障 点或者性能的瓶颈。 每个服务之间如何通信所有的微服务都是独立的 Java 进程跑在独立的虚拟机上，所以服务间的通信就是 IPC（Inter Process Communication），已经有很多成熟的方案。现在基本最通用的有两种方式： 同步调用 REST（JAX-RS，Spring Boot） RPC（Thrift, Dubbo） 同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。一般 REST 基于 HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了 HTTP 的 SDK 就能调用，所以相对使用的广一些。RPC 也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个的开发规范和统一的服务框架时，他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。 异步消息调用 Kafka Notify MessageQueue 异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据 最终一致性；还有就是后台服务一般要实现 幂等性，因为消息送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的 Broker 如此多的服务，如何实现？在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。服务之间如何相互感知？服务如何管理？ 这就是服务发现的问题了。一般有两类做法，也各有优缺点。基本都是通过 Zookeeper 等类似技术做服务注册信息的分布式管理。当服务上线时，服务提供者将自己的服务信息注册到 ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。服务调用者通过 ZK 寻址，根据可定制算法，找到一个服务，还可以将服务信息缓存在本地以提高性能。当服务下线时，ZK 会发通知给服务客户端。 基于客户端的服务注册与发现优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如 Dubbo。 基于服务端的服务注册与发现优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多。 服务挂了，如何解决？前面提到，Monolithic 方式开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。而分布式最大的特性就是 网络是不可靠的。通过微服务拆分能降低这个风险，不过如果没有特别的保障，结局肯定是噩梦。所以当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。相应的手段有很多： 重试机制 限流 熔断机制 负载均衡 降级（本地缓存）]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务的概念]]></title>
    <url>%2F2013%2F03%2F24%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay60_%E5%86%8D%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F032.%E5%86%8D%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[微服务的概念概述微服务架构是一种架构思想，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。 概念把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。 定义围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。 本质用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。 备注： 微服务这个概念是 2012 年出现的，作为加快 Web 和移动应用程序开发进程的一种方法，2014 年开始受到各方的关注，同年为微服务的元年； 与传统架构的区别系统架构需要遵循的三个标准 提高敏捷性：及时响应业务需求，促进企业发展 提升用户体验：提升用户体验，减少用户流失 降低成本：降低增加产品、客户或业务方案的成本 传统的开发模式先来看看传统的 WEB 开发方式，通过对比比较容易理解什么是 微服务架构。和 微服务 相对应的，这种方式一般被称为 单体式开发（Monolithic）。 既所有的功能打包在一个 WAR 包里，基本没有外部依赖（除了容器），部署在一个 JavaEE 容器（Tomcat，JBoss，WebLogic）里，包含了 DO/DAO，Service，UI 等所有逻辑。 优点 开发简单，集中式管理 基本不会重复开发 功能都在本地，没有分布式的管理和调用消耗 缺点 效率低：开发都在同一个项目改代码，相互等待，冲突不断 维护难：代码功功能耦合在一起，新人不知道何从下手 不灵活：构建时间长，任何小修改都要重构整个项目，耗时 稳定性差：一个微小的问题，都可能导致整个应用挂掉 扩展性不够：无法满足高并发下的业务需求 微服务架构目的有效的拆分应用，实现敏捷开发和部署 微服务的特征官方的定义 一系列的独立的服务共同组成系统 单独部署，跑在自己的进程中 每个服务为独立的业务开发 分布式管理 非常强调隔离性 大概的标准 分布式服务组成的系统 按照业务，而不是技术来划分组织 做有生命的产品而不是项目 强服务个体和弱通信（ Smart endpoints and dumb pipes ） 自动化运维（ DevOps ） 高度容错性 快速演化和迭代]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何应对高并发]]></title>
    <url>%2F2013%2F03%2F23%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay55_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F007.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E9%AB%98%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[如何应对高并发什么是高并发高并发(High Concurrency)是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。高并发相关常用的一些指标有 响应时间(Response Time)，吞吐量(Throughput)，每秒查询率 QPS(Query Per Second)，并发用户数 等。 响应时间： 系统对请求做出响应的时间。例如系统处理一个 HTTP 请求需要 200ms，这个 200ms 就是系统的响应时间。 吞吐量： 单位时间(年，月，日，时，分，秒)内处理的请求数量。 QPS： 每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。 并发用户数： 同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。 如何提升系统的并发能力互联网分布式架构设计，提高系统并发能力的方式，方法论上主要有两种：垂直扩展(Scale Up) 与 水平扩展(Scale Out)。 垂直扩展提升单机处理能力。垂直扩展的方式又有两种： 增强单机硬件性能，例如：增加 CPU 核数如 32 核，升级更好的网卡如万兆，升级更好的硬盘如 SSD，扩充硬盘容量如 2T，扩充系统内存如 128G； 提升单机架构性能，例如：使用 Cache 来减少 IO 次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间； 在互联网业务发展非常迅猛的早期，如果预算不是问题，强烈建议使用 “增强单机硬件性能” 的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而 “增强单机硬件性能” 往往是最快的方法。 不管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足：单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展。 水平扩展只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，如何在架构各层进行可水平扩展的设计，以及互联网公司架构各层常见的水平扩展实践，是本文重点讨论的内容。 典型互联网分层架构 客户端层： 典型调用方是浏览器或手机应用 APP 反向代理层： 系统入口(Ingress)，反向代理(Nginx) 站点应用层： 实现核心应用逻辑，返回 HTML 或者 JSON 服务层： 微服务体现在这一层 数据缓存层： 缓存加速访问存储 数据库层： 数据库持久化数据存储 水平扩展分层架构反向代理层的水平扩展 反向代理层的水平扩展，是通过 DNS 轮询 实现的：DNS Server 对于一个域名配置了多个解析 IP，每次 DNS 解析请求来访问 DNS Server，会轮询返回这些 IP。 当 Nginx 成为瓶颈的时候，只要增加服务器数量，新增 Nginx 服务的部署，增加一个外网 IP，就能扩展反向代理层的性能，做到理论上的无限高并发。 站点应用层的水平扩展 站点层的水平扩展，是通过 Nginx 实现的。通过修改 nginx.conf，可以设置多个 Web 后端。 当 Web 后端成为瓶颈的时候，只要增加服务器数量，新增 Web 服务的部署，在 Nginx 配置中配置上新的 Web 后端，就能扩展站点层的性能，做到理论上的无限高并发。 服务层的水平扩展 服务层的水平扩展，是通过 服务连接池 实现的。 站点层通过 RPC Client 调用下游的服务层 RPC Server 时，RPC Client 中的连接池会建立与下游服务多个连接，当服务成为瓶颈的时候，只要增加服务器数量，新增服务部署，在 RPC Client 处建立新的下游服务连接，就能扩展服务层性能，做到理论上的无限高并发。如果需要优雅的进行服务层自动扩容，这里可能需要配置中心里服务自动发现功能的支持。 数据层的水平扩展在数据量很大的情况下，数据层(缓存，数据库)涉及数据的水平扩展，将原本存储在一台服务器上的数据(缓存，数据库)水平拆分到不同服务器上去，以达到扩充系统性能的目的。 按照范围水平拆分 每一个数据服务，存储一定范围的数据 user0 库，存储 uid 范围 1-1kw user1 库，存储 uid 范围 1kw-2kw 优点： 规则简单，Service 只需判断一下 uid 范围就能路由到对应的存储服务 数据均衡性较好 比较容易扩展，可以随时加一个 uid [2kw,3kw] 的数据服务 缺点： 请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大范围的服务请求压力会更大 按照哈希水平拆分 每一个数据库，存储某个 key 值 hash 后的部分数据 user0 库，存储偶数 uid 数据 user1 库，存储奇数 uid 数据 优点： 规则简单，Service 只需对 uid 进行 hash 能路由到对应的存储服务 数据均衡性较好 请求均匀性较好 缺点： 不容易扩展，扩展一个数据服务，hash 方法改变时候，可能需要进行数据迁移 水平拆分与主从同步这里需要注意的是，通过水平拆分来扩充系统性能，与主从同步读写分离来扩充数据库性能的方式有本质的不同。 通过水平拆分扩展数据库性能 每个服务器上存储的数据量是总量的 1/n，所以单机的性能也会有提升 n 个服务器上的数据没有交集，那个服务器上数据的并集是数据的全集 数据水平拆分到了 n 个服务器上，理论上读性能扩充了 n 倍，写性能也扩充了 n 倍(其实远不止 n 倍，因为单机的数据量变为了原来的 1/n) 通过主从同步读写分离扩展数据库性能 每个服务器上存储的数据量是和总量相同 n 个服务器上的数据都一样，都是全集 理论上读性能扩充了 n 倍，写仍然是单点，写性能不变 注意： 缓存层的水平拆分和数据库层的水平拆分类似，也是以范围拆分和哈希拆分的方式居多 总结高并发(High Concurrency)是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。 提高系统并发能力的方式，方法论上主要有两种：垂直扩展(Scale Up)与水平扩展(Scale Out)。前者垂直扩展可以通过提升单机硬件性能，或者提升单机架构性能，来提高并发性，但单机性能总是有极限的，互联网分布式架构设计高并发终极解决方案还是后者：水平扩展。 互联网分层架构中，各层次水平扩展的实践又有所不同： 反向代理层可以通过 DNS 轮询 的方式来进行水平扩展 站点层可以通过 Nginx 来进行水平扩展 服务层可以通过服务连接池来进行水平扩展 数据库可以按照数据范围，或者数据哈希的方式来进行水平扩展 各层实施水平扩展后，能够通过增加服务器数量的方式来提升系统的性能，做到理论上的性能无限。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAP定理 与 BASE理论]]></title>
    <url>%2F2013%2F03%2F22%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay55_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F006.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1-CAP%20%E5%AE%9A%E7%90%86%E4%B8%8E%20BASE%20%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[CAP 定理与 BASE 理论CAP 定理2000 年 7 月，加州大学伯克利分校的 Eric Brewer 教授在 ACM PODC 会议上提出 CAP 猜想。2年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP。之后，CAP 理论正式成为分布式计算领域的公认定理。 CAP 理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。 一致性(Consistency)： 一致性指 (all nodes see the same data at the same time)，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。 可用性(Availability)： 可用性指(Reads and writes always succeed)，即服务一直可用，而且是正常响应时间。 分区容错性(Partition tolerance)： 分区容错性指(the system continues to operate despite arbitrary message loss or failure of part of the system)，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 CAP 权衡通过 CAP 理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？ 对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到 N 个 9，即保证 P 和 A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。 对于涉及到钱财这样不能有一丝让步的场景，C 必须保证。网络发生故障宁可停止服务，这是保证 CA，舍弃 P。貌似这几年国内银行业发生了不下 10 起事故，但影响面不大，报道也不多，广大群众知道的少。还有一种是保证 CP，舍弃 A。例如网络故障是只读不写。 孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。 BASE 理论eBay 的架构师 Dan Pritchett 源于对大规模分布式系统的实践总结，在 ACM 上发表文章提出 BASE 理论，BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。 基本可用(Basically Available)： 基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。 软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。MySQL Replication 的异步复制也是一种体现。 最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。 ACID 和 BASE 的区别与联系ACID 是传统数据库常用的设计理念，追求强一致性模型。BASE 支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。 ACID 和 BASE 代表了两种截然相反的设计哲学，在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此 ACID 和 BASE 又会结合使用。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务的缺点]]></title>
    <url>%2F2013%2F03%2F21%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay55_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F005.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[微服务的缺点概述就像 Fred Brooks 大约在 30 年前写的《人月神话》中说的，没有银弹。与其他技术一样，微服务架构模式也存在着缺点。其中一个缺点就是名称本身。微服务这个术语的重点过多偏向于服务的规模。事实上，有些开发者主张构建极细粒度的 10 至 100 LOC（代码行） 服务，虽然这对于小型服务可能比较好，但重要的是要记住，小型服务只是一种手段，而不是主要目标。微服务的目标在于充分分解应用程序以方便应用敏捷开发和部署。 微服务另一个主要缺点是由于微服务是一个分布式系统，其使得整体变得复杂。开发者需要选择和实现基于消息或者 RPC 的进程间通信机制。此外，由于目标请求可能很慢或者不可用，他们必须要编写代码来处理局部故障。虽然这些并不是很复杂、高深，但模块间通过语言级方法/过程调用相互调用，这比单体应用要复杂得多。 微服务的另一个挑战是分区数据库架构。更新多个业务实体的业务事务是相当普遍的。这些事务在单体应用中的实现显得微不足道，因为单体只存在一个单独的数据库。在基于微服务的应用程序中，您需要更新不同服务所用的数据库。通常不会选择分布式事务，不仅仅是因为 CAP 定理。他们根本不支持如今高度可扩展的 NoSQL 数据库和消息代理。您最后不得不使用基于最终一致性的方法，这对于开发人员来说更具挑战性。 测试微服务应用程序也很复杂。例如，使用现代框架如 Spring Boot，只需要编写一个测试类来启动一个单体 web 应用程序并测试其 REST API。相比之下，一个类似的测试类对于微服务来说需要启动该服务及其所依赖的所有服务，或者至少为这些服务配置存根。再次声明，虽然这不是一件高深的事情，但不要低估了这样做的复杂性。 微服务架构模式的另一个主要挑战是实现了跨越多服务变更。例如，我们假设您正在实现一个变更服务 A、服务 B 和 服务 C 的需求，其中 A 依赖于 B，且 B 依赖于 C。在单体应用程序中，您可以简单地修改相应的模块、整合变更并一次性部署他们。相反，在微服务中您需要仔细规划和协调出现的变更至每个服务。例如，您需要更新服务 C，然后更新服务 B，最后更新服务 A。幸运的是，大多数变更只会影响一个服务，需要协调的多服务变更相对较少。 部署基于微服务的应用程序也是相当复杂的。一个单体应用可以很容易地部署到基于传统负载均衡器的一组相同服务器上。每个应用程序实例都配置有基础设施服务的位置（主机和端口），比如数据库和消息代理。相比之下，微服务应用程序通常由大量的服务组成。例如，据 Adrian Cockcroft 了解到，Hailo 拥有 160 个不同的服务，Netflix 拥有的服务超过 600 个。 每个服务都有多个运行时实例。还有更多的移动部件需要配置、部署、扩展和监控。此外，您还需要实现服务发现机制，使得服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。比较传统麻烦的基于票据（ticket-based）和手动的操作方式无法扩展到如此复杂程度。因此，要成功部署微服务应用程序，需要求开发人员能高度控制部署方式和高度自动化。 一种自动化方式是使用现成的平台即服务（PaaS），如 Cloud Foundry。PaaS 为开发人员提供了一种简单的方式来部署和管理他们的微服务。它让开发人员避开了诸如采购和配置 IT 资源等烦恼。同时，配置 PaaS 的系统人员和网络专业人员可以确保达到最佳实践以落实公司策略。 自动化微服务部署的另一个方式是开发自己的 PaaS。一个普遍的起点是使用集群方案，如 Kubernetes，与 Docker 等容器技术相结合。 小结构建复杂的微服务应用程序本质上是困难的。单体架构模式只适用于简单、轻量级的应用程序，如果您使用它来构建复杂应用，您最终会陷入痛苦的境地。微服务架构模式是复杂、持续发展应用的一个更好的选择。尽管它存在着缺点和实现挑战。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务的优点]]></title>
    <url>%2F2013%2F03%2F20%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay55_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F004.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BC%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[微服务的优点概述微服务架构模式有许多非常好的地方。 第一，它解决了复杂问题。它把可能会变得庞大的单体应用程序分解成一套服务。虽然功能数量不变，但是应用程序已经被分解成可管理的块或者服务。每个服务都有一个明确定义边界的方式，如远程过程调用（RPC）驱动或消息驱动 API。微服务架构模式强制一定程度的模块化，实际上，使用单体代码来实现是极其困难的。因此，使用微服务架构模式，个体服务能被更快地开发，并更容易理解与维护。 第二，这种架构使得每个服务都可以由一个团队独立专注开发。开发者可以自由选择任何符合服务 API 契约的技术。当然，更多的组织是希望通过技术选型限制来避免完全混乱的状态。然而，这种自由意味着开发人员不再有可能在这种自由的新项目开始时使用过时的技术。当编写一个新服务时，他们可以选择当前的技术。此外，由于服务较小，使用当前技术重写旧服务将变得更加可行。 第三，微服务架构模式可以实现每个微服务独立部署。开发人员根本不需要去协调部署本地变更到服务。这些变更一经测试即可立即部署。比如，UI 团队可以执行 A|B 测试，并快速迭代 UI 变更。微服务架构模式使得持续部署成为可能。 最后，微服务架构模式使得每个服务能够独立扩展。您可以仅部署满足每个服务的容量和可用性约束的实例数目。此外，您可以使用与服务资源要求最匹配的硬件。例如，您可以在 EC2 Compute Optimized 实例上部署一个 CPU 密集型图像处理服务，并且在 EC2 Memory-optimized 实例上部署一个内存数据库服务。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务解决复杂问题]]></title>
    <url>%2F2013%2F03%2F19%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay55_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F003.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[微服务解决复杂问题概述许多如 Amazon、 eBay 和 Netflix 这样的组织，已经采用现在所谓的微服务架构模式解决了这个问题，而不是构建一个臃肿的单体应用。它的思路是将应用程序分解成一套较小的互连服务。一个服务通常实现了一组不同的特性或功能，例如订单管理、客户管理等。每一个微服务都是一个迷你应用，它自己的六边形架构包括了业务逻辑以及多个适配器。 一些微服务会暴露一个供其他微服务或应用客户端消费的 API。其他微服务可能实现了一个 web UI。在运行时，每个实例通常是一个云虚拟机 (virtual machine， VM) 或者一个 Docker 容器。 例如，前面描述的系统可能分解成如下图（一个单体应用分解成微服务) 所示： 应用程序的每个功能区域现在都由自己的微服务实现。此外，Web 应用程序被划分为一组更简单的 Web 应用程序。例如，以我们的出租车为例，一个是乘客的应用，一个是司机的应用。这使得它更容易地为特定的用户、司机、设备或者专门的用例部署不同的场景。每个后端服务暴露一个 REST API，大部分服务消费的 API 由其他服务提供。例如， Driver Management 使用了 Notification 服务器来通知一个可用司机一个可选路程。UI 服务调用了其他服务来渲染页面。服务也可以使用异步、基于消息的通信。 一些 REST API 也暴露给移动端应用以供司机和乘客使用。然而，应用不能直接访问后端服务。相反，他们之间的通信是由一个称为 API 网关 (API Gateway) 的中介负责。 API 网关负责负载均衡、缓存、访问控制、 API 计量和监控， 可以通过使用 NGINX 来实现。 开发和交付中的伸缩立方： 微服务架构模式相当于此伸缩立方的 Y 轴坐标，此立方是一个来自《架构即未来》 的三维伸缩模型。另外两个坐标轴是由运行多个相同应用程序副本的负载均衡器组成的X 轴坐标和 Z 轴坐标（或数据分区) ，其中请求的属性（例如，一行记录的主键或者客户标识) 用于将请求路由到特定的服务器。 在运行时，X 坐标轴上运行着服务的多个实例，每个服务配合负载均衡器以满足吞吐量和可用性。某些应用程序也有可能使用 Z 坐标轴来进行分区服务。下图展示了如何用 Docker 将 Trip Management 服务部署到 Amazon EC2 上运行。 使用 Docker 部署 Trip Management 服务： 在运行时，Trip Management 服务由多个服务实例组成，每个服务实例是一个 Docker容器。为了实现高可用，容器是在多个云虚拟机上运行的。服务实例的之前是一个类似 NGINX 的负载均衡器，用于跨实例分发请求。负载均衡器也可以处理其他问题，如缓存、访问控制、API 度量和监控。 微服务架构模式明显影响到了应用程序与数据库之间的关系。与其他共享单个数据库模式 (schema) 服务有所不同， 其每一个服务都有自己的数据库模式。一方面，这种做法与企业级数据库数据模型的想法相背，此外，它经常导致部分数据冗余。然而，如果您想从微服务中受益，每一个服务都应该有自己的数据库模式。因为它能实现松耦合。下图展示了数据库架构示例应用程序。 每个服务都拥有各自的数据库。而且，服务可以使用一种最适合其需求、号称多语言持久架构 （polyglot persistence architecture ) 的数据库。例如，DriverManagement，要找到与潜在乘客接近的司机，就必须使用支持高效地理查询的数据库。 打车应用的数据库架构： 从表面上看，微服务架构模式类似于 SOA。微服务是由一组服务组成。然而，换另一种方式去思考微服务架构模式，它是没有商业化的 SOA，没有集成 Web 服务规范 (WS-*) 和企业服务总线 (Enterprise Service Bus， ESB) 。基于微服务的应用支持更简单、轻量级的协议，例如，REST，而不是 WS-*。他们也尽量避免使用 ESB，而是实现微服务本身具有类似 ESB 的功能。微服务架构也拒绝了 SOA 的其他部分，例如，数据访问规范模式概念。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走向单体地狱]]></title>
    <url>%2F2013%2F03%2F18%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay55_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F002.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E8%B5%B0%E5%90%91%E5%8D%95%E4%BD%93%E5%9C%B0%E7%8B%B1%2F</url>
    <content type="text"><![CDATA[走向单体地狱概述不幸的是，这种简单的方法有很大的局限性。成功的应用有一个趋势，随着时间推移而变得越来越臃肿。您的开发团队在每个冲刺阶段都要实现更多的用户需求，这意味着需要添加了许多行代码。几年之后，小而简单的应用将会逐渐成长成一个庞大的单体。为了给出一个极端示例，我最近和一位开发者做了交谈，他正在编写一个工具，该工具用于从他们的数百万行代码 (lines of code， LOC) 应用中分析出数千个 JAR 之间的依赖。我相信这是大量开发者在多年齐心协力下创造出了这样的野兽。 一旦您的应用程序成为了一个庞大、复杂的单体，您的开发组织可能会陷入了一个痛苦的境地，敏捷开发和交付的任何一次尝试都将原地徘徊。一个主要问题是应用程序实在非常复杂。对于任何一个开发人员来说显得过于庞大，这是可以理解的。最终，正确修复 bug 和实现新功能变得非常困难而耗时。此外， 这种趋势就像是往下的螺旋。如果基本代码都令人难以理解，那么改变也不会变得正确，您最终得到的将是一个巨大且不可思议的大泥球。 应用程序的规模也将减缓发展。应用程序越大，启动时间越长。我调查过开发者们的单体应用的大小和性能，一些报告的启动时间为 12 分钟。我也听说过应用程序启动需要 40 分钟以上的怪事。如果开发人员经常要重启应用服务器，那么很大一部分时间都是在等待中度过，他们的生产力将受到限制。 另一个大问题是，复杂的单体应用本身就是持续部署的障碍。如今， SaaS 应用发展到了可以每天多次将变更推送到生产环境中。这对于复杂的单体来说非常困难，因为您需要重新部署整个应用程序才能更新其中任何一部分。 联想到我之前提到的漫长启动时间，这也不会是什么好事。此外，因变更所产生的影响通常不是很明确，您很可能需要做大量的手工测试。因此，持续部署是不可能做到的。 当不同模块存在资源需求冲突时，单体应用可能难以扩展。例如，一个模块可能会执行 CPU 密集型图像处理逻辑，理想情况下是部署在 Amazon EC2 Compute Optimized 实例中。另一个模块可能是一个内存数据库，最适合部署到 EC2 Memory-optimized 实例。然而， 由于这些模块被部署在一起，您必须在硬件选择上做出妥协。 单体应用的另一个问题是可靠性。因为所有模块都运行在同一进程中。任何模块的一个 bug，比如内存泄漏，可能会拖垮整个进程。此外，由于应用程序的所有实例都是相同的，该错误将影响到整个应用的可用性。 最后但同样重要，单体应用使得采用新框架和语言变得非常困难。例如，我们假设您有 200 万行代码使用了 XYZ 框架编写。如果使用较新的 ABC 框架来重写整个应用，这将非常昂贵（在时间和成本方面），即使框架非常好。因此，这对于采用新技术是一个非常大的障碍。在项目开始时， 您无论选择何种新技术都会感到困扰。 总结一下：您有一个成功的关键业务应用程序，它已经发展成为一个只有少数开发人员（如果有的话）能够理解的巨大单体。它使用了过时、非生产性技术编写，这使得招聘优秀开发人员变得非常困难。应用程序变得难以扩展，不可靠。因此敏捷开发和应用交付是不可能的。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建单体应用模型]]></title>
    <url>%2F2013%2F03%2F17%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FDay55_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F001.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E6%9E%84%E5%BB%BA%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[构建单体应用模型概述我们假设，您开始开发一个打车应用，打算与 Uber 和 Hailo 竞争。经过初步交流和需求收集，您开始手动或者使用类似 Rails、Spring Boot、Play 或者 Maven 等平台来生成一个新项目。 该新应用是一个模块化的六边形架构，如下图（一个简单的打车应用）所示： 该应用的核心是由模块实现的业务逻辑，它定义了服务、领域对象和事件。围绕核心的是与外部世界接口对接的适配器。适配器示例包括数据库访问组件、生产和消费消息的消息组件和暴露了 API 或实现了一个 UI 的 web 组件。 尽管有一个逻辑模块化架构，但应用程序被作为一个单体进行打包和部署。实际格式取决于应用程序的语言和框架。例如，许多 Java 应用程序被打包成 WAR 文件部署在如 Tomcat 或者 Jetty 之类的应用服务器上。其他 Java 应用程序被打包成自包含 (self-contained) 的可执行 JAR。类似地， Rails 和 Node.js 应用程序被打包为有目录层次的结构 以这种风格编写的应用是很常见的。他们很容易开发，因为我们的 IDE 和其他工具就是专注于构建单体应用。这些应用程序也很容易测试， 您可以通过简单地启动并使用如 Selenium 测试包来测试 UI 以轻松地实现端到端 (end-to-end) 测试。单体应用同样易于部署。您只需拷贝打包好的应用程序到服务器上。您还可以通过运行多个副本和结合负载均衡器来扩展应用。在项目的早期阶段，它可以良好运作。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化项目]]></title>
    <url>%2F2013%2F03%2F16%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay54_%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%2F03.%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[搭建通用模块项目创建统一的依赖管理创建一个名为 myshop-dependencies 项目，该项目的主要作用是对依赖包的版本进行统一管理，pom.xml 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;properties&gt; &lt;!-- Environment Settings --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- Spring Boot Starter Settings --&gt; &lt;boot-dubbo.version&gt;0.2.0&lt;/boot-dubbo.version&gt; &lt;boot-mapper.version&gt;2.0.2&lt;/boot-mapper.version&gt; &lt;boot-pagehelper.version&gt;1.2.5&lt;/boot-pagehelper.version&gt; &lt;boot-druid.version&gt;1.1.10&lt;/boot-druid.version&gt; &lt;!-- Spring Cloud Settings --&gt; &lt;cloud-hystrix.version&gt;2.0.1.RELEASE&lt;/cloud-hystrix.version&gt; &lt;!-- Commons Settings --&gt; &lt;kyro.version&gt;0.42&lt;/kyro.version&gt; &lt;mysql.version&gt;8.0.12&lt;/mysql.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Starter Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;boot-dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-actuator&lt;/artifactId&gt; &lt;version&gt;$&#123;boot-dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;boot-mapper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;boot-pagehelper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;boot-druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Starter End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;$&#123;cloud-hystrix.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;$&#123;cloud-hystrix.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- Commons Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;de.javakaffee&lt;/groupId&gt; &lt;artifactId&gt;kryo-serializers&lt;/artifactId&gt; &lt;version&gt;$&#123;kyro.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Commons End --&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Compiler 插件, 设定 JDK 版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 打包 jar 文件时，配置 manifest 文件，加入 lib 包的 jar 依赖 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- Add directory entries --&gt; &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt; &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- resource --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- install --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- clean --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- ant --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- dependency --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- Java Document Generate --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- YUI Compressor (CSS/JS压缩) --&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;yuicompressor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compress&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;jswarn&gt;false&lt;/jswarn&gt; &lt;nosuffix&gt;true&lt;/nosuffix&gt; &lt;linebreakpos&gt;30000&lt;/linebreakpos&gt; &lt;force&gt;true&lt;/force&gt; &lt;includes&gt; &lt;include&gt;**/*.js&lt;/include&gt; &lt;include&gt;**/*.css&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.min.js&lt;/exclude&gt; &lt;exclude&gt;**/*.min.css&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!-- 资源文件配置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://192.168.10.133:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;url&gt;http://192.168.10.133:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Repository&lt;/name&gt; &lt;url&gt;http://192.168.10.133:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos-s&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Plugin Repository&lt;/name&gt; &lt;url&gt;http://192.168.10.133:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 创建通用工具类项目创建一个名为 myshop-commons 项目，该项目的主要作用是提供通用的工具类，pom.xml 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../myshop-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;myshop-commons&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpa-2.1-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.javakaffee&lt;/groupId&gt; &lt;artifactId&gt;kryo-serializers&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建通用的领域模型创建一个名为 myshop-commons-domain 项目，该项目的主要作用是提供通用的实体类,pom.xml 配置如下： 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../myshop-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;myshop-commons-domain&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建通用的数据访问创建一个名为 myshop-commons-mapper 项目，该项目的主要作用是提供通用的数据访问接口，pom.xml配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../myshop-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;myshop-commons-mapper&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-commons-domain&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建通用的 MyMapper 接口1234567891011121314151617package tk.mybatis.mapper;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * &lt;p&gt;Title: MyMapper&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * * @author Lusifer * @version 1.0.0 * @date 2018/5/29 0:57 */public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123;&#125; 创建数据库生成项目创建一个名为 myshop-databases 项目，该项目的主要作用是使用 MyBatis 自动生成插件生成实体类对象和数据访问接口，pom.xml 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../myshop-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;myshop-databases&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-commons-mapper&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 自动生成的配置在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 引入数据库连接配置 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;context id="Mysql" targetRuntime="MyBatis3Simple" defaultModelType="flat"&gt; &lt;property name="beginningDelimiter" value="`"/&gt; &lt;property name="endingDelimiter" value="`"/&gt; &lt;!-- 配置 tk.mybatis 插件 --&gt; &lt;plugin type="tk.mybatis.mapper.generator.MapperPlugin"&gt; &lt;property name="mappers" value="tk.mybatis.mapper.MyMapper"/&gt; &lt;/plugin&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;jdbc.driverClass&#125;" connectionURL="$&#123;jdbc.connectionURL&#125;" userId="$&#123;jdbc.username&#125;" password="$&#123;jdbc.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- 配置实体类存放路径 --&gt; &lt;javaModelGenerator targetPackage="com.funtl.myshop.commons.domain" targetProject="src/main/java"/&gt; &lt;!-- 配置 XML 存放路径 --&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"/&gt; &lt;!-- 配置 DAO 存放路径 --&gt; &lt;javaClientGenerator targetPackage="com.funtl.myshop.commons.mapper" targetProject="src/main/java" type="XMLMAPPER"/&gt; &lt;!-- 配置需要生成的表，% 代表所有 --&gt; &lt;table catalog="myshop" tableName="%"&gt; &lt;!-- mysql 配置 --&gt; &lt;generatedKey column="id" sqlStatement="Mysql" identity="true"/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 配置数据源在 src/main/resources 目录下创建 jdbc.properties 数据源配置： 1234jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.connectionURL=jdbc:mysql://192.168.10.131:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsejdbc.username=rootjdbc.password=123456 插件自动生成命令1mvn mybatis-generator:generate 创建通用的静态资源创建一个名为 myshop-static-backend 项目，该项目的主要作用是将通用的静态资源文件打包到一个项目里，利用 Maven 的依赖机制其他项目可以很方便的共用，就不需要手工重复复制这些静态资源文件了，pom.xml 配置如下： 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;myshop-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../myshop-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;myshop-static-backend&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XP极限编程]]></title>
    <url>%2F2013%2F03%2F15%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay54_%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%2F02.xp%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[了解 XP 极限编程概述敏捷方法论有一个共同的特点，那就是都将矛头指向了“文档”，它们认为传统的软件工程方法文档量太“重”了，称为“重量级”方法，而相应的敏捷方法则是“轻量级”方法。正是因为“轻量级”感觉没有什么力量，不但不能够有效体现灵活性，反而显得是不解决问题的方法论似的。因此，就有了一次划时代的会议，创建了敏捷联盟。 在敏捷方法论领域中，比较知名的、有影响力的，是拥有与 Microsoft 的操作系统相同缩写语——XP的极限编程（eXtreme Programming）。极限编程方法论可以说是敏捷联盟中最鲜艳的一面旗帜，也是被研究、尝试、应用、赞扬、批判最多的一种方法论，也是相对来说最成熟的一种。 这一被誉为“黑客文化”的方法论的雏形最初形成于1996—1999年间，Kent Beck、Ward Cunninggham、Ron Jeffrey 在开发 C3 项目（Chrysler Comprehensive Compensation）的实践中总结出了 XP 的基本元素。在此之后，Kent Beck 和他的一些好朋友们一起在实践中完善提高，终于形成了极限编程方法论。 解析极限编程那么什么是 XP 呢？XP 是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。与其他方法论相比，其最大的不同在于： 在更短的周期内，更早地提供具体、持续的反馈信息。 在迭代的进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断的发展它。 依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。 依赖于口头交流、测试和源程序进行沟通。 倡导持续的演化式设计。 依赖于开发团队内部的紧密协作。 尽可能达到程序员短期利益和项目长期利益的平衡。 Kent Beck 曾经说过“开车”就是一个 XP 的范例，即使看上去进行得很顺利，也不要把视线从公路上移开，因为路况的变化，将使得你必须随时做出一些这样那样的调整。而在软件项目中，客户就是司机，他们也没有办法确切地知道软件应该做什么，因此程序员就需要向客户提供方向盘，并且告知我们现在的位置。 XP 包括写什么呢？如图，XP 由价值观、原则、实践和行为四个部分组成，它们彼此相互依赖、关联， 并通过行为贯穿于整个生命期。 四大价值观1XP 的核心是其总结的沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）四大价值观，它们是XP的基础，也是XP的灵魂。 此外还扩展了第五个价值观：谦逊（Modesty）。 XP用“沟通、简单、反馈、勇气和谦逊”来减轻开发压力和包袱；XP 精神可以启发我们如何学习和对待快速变化、多样的开发技术。成功学习 XP 的关键，是用“沟通、简单、反馈、勇气和谦逊”的态度来对待 XP；轻松愉快地来感受 XP 的实践思想；自己认真实践后，通过对真实反馈的分析，来决定 XP 对自己的价值；有勇气接受它，或改进它。 沟通通常程序员给人留下的印象就是“内向、不善言谈”，然后项目中的许多问题就出在这些缺乏沟通的开发人员身上。经常由于某个程序员做出了一个设计决定，但是却不能及时地通知大家，结果使得大家在协作与配合上出现了很多的麻烦，而在传统的方法论中，并不在意这种口头沟通不畅的问题，而是希望借助于完善的流程和面面俱到的文档、报表、计划来替代，但是这同时又引入了效率不高的新问题。 XP 方法论认为，如果小组成员之间无法做到持续的、无间断的交流，那么协作就无从谈起，从这个角度能够发现，通过文档、报表等人工制品进行交流面临巨大的局限性。因此，XP 组合了诸如对编程这样的最佳实践，鼓励大家进行口头交流，通过交流解决问题，提高效率。 简单XP 方法论提倡在工作中秉承“够用就好”的思路，也就是尽量地简单化，只要今天够用就行，不考虑明天会发现的新问题。这一点看上去十分容易，但是要真正做到保持简单的工作其实很难的。因为在传统的开发方法中，都要求大家对未来做一些预先规划，以便对今后可能发生的变化预留一些扩展的空间。 正如对传统开发方法的认识一样，许多开发人员也会质疑 XP，保持系统的扩展性很重要，如果都保持简单，那么如何使得系统能够有良好的扩展性呢？其实不然，保持简单的理由有两个： 开发小组在开发时所做的规划，并无法保证其符合客户需要的，因此做的大部分工作都将落空，使得开发过程中重复的、没有必要的工作增加，导致整体效率降低。 另外，在 XP 中提倡时刻对代码进行重构，一直保持其良好的结构与可扩展性。也就是说，可扩展性和为明天设计并不是同一个概念，XP 是反对为明天考虑而工作，并不是说代码要失去扩展性 而且简单和沟通之间还有一种相对微妙的相互支持关系。当一个团队之间，沟通的越多，那么就越容易明白哪些工作需要做，哪些工作不需要做。另一方面，系统越简单，需要沟通的内容也就越少，沟通也将更加全面。 反馈是什么原因使得我们的客户、管理层这么不理解开发团队？为什么客户、管理层总是喜欢给我们一个死亡之旅？究其症结，就是开发的过程中缺乏必要的反馈。在许许多多项目中，当开发团队经历过了需求分析阶段之后，在相当长的一段时间内，是没有任何反馈信息的。整个开发过程对于客户和管理层而言就像一个黑盒子，进度完全是不可见的。 而且在项目的过程中，这样的现象不仅出现在开发团队与客户、管理层之间，还包括在开发团队内部。这一切问题都需要我们更加注重反馈。，反馈对于任何软件项目的成功都是至关重要的，而在 XP 方法论中则更进一步，通过持续、明确的反馈来暴露软件状态的问题。具体而言就是： 在开发团队内部，通过提前编写单元测试代码，时时反馈代码的问题与进展。 在开发过程中，还应该加强集成工作，做到持续集成，使得每一次增量都是一个可执行的工作版本，也就是逐渐是软件长大，整个过程中，应该通过向客户和管理层演示这些可运行的版本，以便及早地反馈，及早地发现问题。 同时，我们也会发现反馈与沟通也有着良好的配合，及时和良好的反馈有助于沟通。而简单的系统更有利于测试和反馈。 勇气在应用 XP 方法论时，我们每时每刻都在应对变化：由于沟通良好，因此会有更多需求变更的机会；由于时刻保持系统的简单，因此新的变化会带来一些重新开发的需要；由于反馈及时，因此会有更多中间打断你的思路的新需求。 总之这一切，使得你立刻处于变化之中，因此这时就需要你有勇气来面对快速开发，面对可能的重新开发。也许你会觉得，为什么要让我们的开发变得如此零乱，但是其实这些变化若你不让它早暴露，那么它就会迟一些出现，并不会因此消亡，因此，XP 方法论让它们早出现、早解决，是实现“小步快走”开发节奏的好办法。 也就是 XP 方法论要求开发人员穿上强大、自动测试的盔甲，勇往直前，在重构、编码规范的支持下，有目的地快速开发。 勇气可以来源于沟通，因为它使得高风险、高回报的试验成为可能；勇气可以来源于简单，因为面对简单的系统，更容易鼓起勇气；勇气可以来源于反馈，因为你可以及时获得每一步前进的状态（自动测试），会使得你更勇于重构代码。 四大价值观之外在这四大价值观之下，隐藏着一个更深刻的东西，那就是尊重。因为这一切都建立在团队成员之间的相互关心、相互理解的基础之上。 5 个原则快速反馈及时地、快速地获取反馈，并将所学到的知识尽快地投入到系统中去。也就是指开发人员应该通过较短的反馈循环迅速地了解现在的产品是否满足了客户的需求。这也是对反馈这一价值观的进一步补充。 简单性假设类似地，简单性假设原则是对简单这一价值观的进一步补充。这一原则要求开发人员将每个问题都看得十分容易解决，也就是说只为本次迭代考虑，不去想未来可能需要什么，相信具有将来必要时增加系统复杂性的能力，也就是号召大家出色地完成今天的任务。 逐步修改就像开车打方向盘一样，不要一次做出很大的改变，那样将会使得可控性变差，更适合的方法是进行微调。而在软件开发中，这样的道理同样适用，任何问题都应该通过一系列能够带来差异的微小改动来解决。 提倡更改在软件开发过程中，最好的办法是在解决最重要问题时，保留最多选项的那个。也就是说，尽量为下一次修改做好准备。 优质工作在实践中，经常看到许多开发人员喜欢将一些细小的问题留待后面解决。例如，界面的按钮有一些不平整，由于不影响使用就先不管；某一两个成员函数暂时没用就不先写等。这就是一种工作拖泥带水的现象，这样的坏习惯一旦养成，必然使得代码质量大打折扣。 而在 XP 方法论中，贯彻的是“小步快走”的开发原则，因此工作质量决不可打折扣，通常采用测试先行的编码方式来提供支持。 13 个最佳实践在 XP 中，集成了 13 个最佳实践，有趣的是，它们没有一个是创新的概念，大多数概念和编程一样老。其主要创新点在于提供一种良好的思路，将这些最佳实践结合在一起，并且确保尽可能彻底地执行它们，使得它们能够在最大程度上相互支持，紧接下来，我们就对每一种最佳实践进行一番了解。 计划游戏计划游戏的主要思想就是先快速地制定一份概要的计划，然后随着项目细节的不断清晰，再逐步完善这份计划。计划游戏产生的结果是一套用户故事及后续的一两次迭代的概要计划。 “客户负责业务决策，开发团队负责技术决策”是计划游戏获得成功的前提条件。也就是说，系统的范围、下一次迭代的发布时间、用户故事的优先级应该由客户决定；而每个用户故事所需的开发时间、不同技术的成本、如何组建团队、每个用户故事的风险，以及具体的开发顺序应该由开发团队决定。 好了，明白这些就可以进行计划游戏了。首先客户和开发人员坐在同一间屋子里，每个人都准备一支笔、一些用于记录用户故事的纸片，最好再准备一个白板，就可以开始了。 客户编写故事：由客户谈论系统应该完成什么功能，然后用通俗的自然语言，使用自己的语汇，将其写在卡片上，这也就是用户故事。 开发人员进行估算：首先客户按优先级将用户故事分成必须要有、希望有、如果有更好三类，然后开发人员对每个用户故事进行估算，先从高优先级开始估算。如果在估算的时候，感到有一些故事太大，不容易进行估算，或者是估算的结果超过 2人/周，那么就应该对其进行分解，拆成 2 个或者多个小故事。 确定迭代的周期：接下来就是确定本次迭代的时间周期，这可以根据实际的情况进行确定，不过最佳的迭代周期是 2~3 周。有了迭代的时间之后，再结合参与的开发人数，算出可以完成的工作量总数。然后根据估算的结果，与客户协商，挑出时间上够、优先级合适的用户故事组合，形成计划。 小型发布XP 方法论秉承的是“持续集成，小步快走”的哲学，也就是说每一次发布的版本应该尽可能的小，当然前提条件是每个版本有足够的商业价值，值得发布。 由于小型发布可以使得集成更频繁，客户获得的中间结果也越频繁，反馈也就越频繁，客户就能够实时地了解项目的进展情况，从而提出更多的意见，以便在下一次迭代中计划进去。以实现更高的客户满意度。 隐喻相对而言，隐喻这一个最佳实践是最令人费解的。什么是隐喻呢？根据词典中的解释是：“一种语言的表达手段，它用来暗示字面意义不相似的事物之间的相似之处”。那么这在软件开发中又有什么用呢？总结而言，常常用于四个方面。 寻求共识：也就是鼓励开发人员在寻求问题共识时，可以借用一些沟通双方都比较熟悉的事物来做类比，从而帮助大家更好地理解解决方案的关键结构，也就是更好地理解系统是什么、能做什么。 发明共享词汇：通过隐喻，有助于提出一个用来表示对象、对象间的关系通用名称。例如，策略模式（用来表示可以实现多种不同策略的设计模式）、工厂模式（用来表示可以按需“生产”出所需类得设计模式）等。 创新的武器：有的时候，可以借助其他东西来找到解决问题的新途径。例如：“我们可以将工作流看做一个生产线”。 描述体系结构：体系结构是比较抽象的，引入隐喻能够大大减轻理解的复杂度。例如管道体系结构就是指两个构件之间通过一条传递消息的“管道”进行通信。 当然，如果能够找到合适的隐喻是十分快乐的，但并不是每种情况都可以找到恰当的隐喻，你也没有必要强求 简单设计强调简单设计的价值观，引出了简单性假设原则，落到实处就是“简单设计”实践。这个实践看上去似乎很容易理解，但却又经常被误解，许多批评者就指责 XP 忽略设计是不正确的。其实，XP 的简单设计实践并不是要忽略设计，而且认为设计不应该在编码之前一次性完成，因为那样只能建立在“情况不会发生变化”或者“我们可以预见所有的变化”之类的谎言的基础上的。 Kent Beck 概念中简单设计是这样的： 能够通过所有的测试程序。 没有包括任何重复的代码。 清楚地表现了程序员赋予的所有意图。 包括尽可能少的类和方法 他认为要想保持设计简单的系统，需要具备简单思考的能力，拥有理解代码和修改的勇气，以及为了消除代码的“坏味道”而定期重构的习惯。 那么如何开始进行简单的设计呢？XP 实践者们也总结也一些具体的、可操作的思考方法。 首先写测试代码：具体将在后面详细描述。 保持每个类只负责一件事：SRP（单一职责原则）是面向对象设计的基础原则之一。 使用 Demeter（迪米特）法则：迪米特法则，也称为 LoD 法则、最少知识原则。也就是指一个对象应当对其他对象尽可能少地了解。用隐喻的方法来解释的话就是“只与你直接的朋友通信”、“不要和陌生人说话”。 使用 CRC 卡片进行探索。 测试先行／测试驱动开发当我第一次看到“测试先行”这个概念的时候，我的第一感觉就是不解，陷入了“程序都还没有写出来，测试什么呀？”的迷思。我开始天马行空地寻求相关的隐喻，终于找到了能够启发我的工匠，首先，我们来看看两个不同的工匠是如何工作的吧。 工匠一：先拉上一根水平线，砌每一块砖时，都与这跟水平线进行比较，使得每一块砖都保持水平。 工匠二：先将一排砖都砌完，然后再拉上一根水平线，看看哪些砖有问题，对有问题的砖进行适当的调整。 你会选择哪种工作方法呢？你一定会骂工匠二笨吧！这样多浪费时间呀！然而你自己想想，你平时在编写程序的时候又是怎么做的呢？我们就是按工匠二的方法在工作呀！甚至有时候比工匠二还笨，是整面墙都砌完了，直接进行“集成测试”，经常让整面的墙倒塌。看到这里，你还会觉得自己的方法高明吗？这个连工匠都明白的道理，自己却画地为牢呀。 不仅我们没有采用工匠一的工作方法，甚至有的时候程序员会以“开发工作太紧张”为理由，而忽略测试工作。但这样却导致了一个恶性循环，越是没有空编写测试程序，代码的效率与质量越差，花在找 Bug、解决 Bug 的时间也越来越多，实际产能大打降低。由于产能降低了，因此时间更紧张，压力更大。你想想，为什么不拉上一根水平线呢？难道，我们不能够将后面浪费的时间花在单元测试上，使得我们的程序一开始就更健壮，更加易于修改吗？不过，编写测试程序当然要比拉一条水平线难道多，所以我们需要引入“自动化测试工具”，免费的 xUnit 测试框架就是你最佳的选择。 为了鼓励程序员原意甚至喜欢在编写程序之前编写测试代码，XP 方法论还提供了许多有说服力的理由。 如果你已经保持了简单的设计，那么编写测试代码根本不难。 如果你在结对编程，那么如果你想出一个好的测试代码，那么你的伙伴一定行。 当所有的测试都通过的时候，你再也不会担心所写的代码今后会“暗箭伤人”，那种感觉是相当棒的。 当你的客户看到所有的测试都通过的时候，会对程序充满前所未有的信心。 当你需要进行重构时，测试代码会给你带来更大的勇气，因为你要测试是否重构成功只需要一个按钮。 测试先行是 XP 方法论中一个十分重要的最佳实践，并且其中所蕴含的知识与方法也十分丰富。 重构重构时一种对代码进行改进而不影响功能实现的技术，XP 需要开发人员在闻到代码的坏味道时，有重构代码的勇气。重构的目的是降低变化引发的风险，使得代码优化更加容易。通常重构发生在两种情况之下。 实现某个特性之前：尝试改变现有的代码结构，以使得实现新的特性更加容易。 实现某个特性之后：检查刚刚写完的代码后，认真检查一下，看是否能够进行简化。 在《重构》一书中，作者 Martin Fowler 提示我们：在考虑重构时，应该要养成编写并经常运行测试代码的习惯；要先编写代码，再进行重构；把每一次增加功能都当做一次重构的好时机；将每一个纠正错误当做一次重构的重要时机。同时，该书中也列出大量需要重构的情况和重构方法。 最后类似地，给还没有足够勇气进行重构的程序员打几剂强心针： XP 提倡集体代码所有制，因此你可以大胆地在任何需要修改的地方做改动。 由于在 XP 项目组中有完整的编码标准，因此在重构前无须重新定义格式。 在重构中遇到困难，和你结对编程的伙伴能够为你提供有效的帮助。 简单的设计，会给重构带来很大的帮助。 测试先行让你拥有了一个有效的检验器，随时运行一下就知道你重构的工作是否带来了影响。 由于 XP 在持续集成，因此你重构所带来的破坏很快就能够暴露，并且得以解决。 重构技术是对简单性设计的一个良好的补充，也是 XP 中重视“优质工作”的体现，这也是优秀的程序员必备的一项技能。 结对编程“什么！两个人坐在一起写程序？那岂不是对人力的巨大浪费吗？而且我在工作时可不喜欢有一个人坐在边上当检察官。”是的，正如这里列举出来的问题一样，结对编程技术还是被很多人质疑的。 不过，自从 20 世纪 60 年代，就有类似的实践在进行，长期以来的研究结果却给出了另外一番景象，那就是结对编程的效率反而比单独编程更高。一开始虽然会牺牲一些速度，但慢慢的，开发速度会逐渐加快，究其原因，主要是结对编程大打降低了沟通的成本，提供了工作的质量，具体表现在： 所有的设计决策确保不是由一个人做出的。 系统的任何一个部分都肯定至少有 2 个人以上熟悉。 几乎不可能有 2 个人都忽略的测试项或者其他任务 结对组合的动态性，是一个企业知识管理的好途径。 代码总是能够保证被评审过。 而且 XP 方法论集成的其他最佳实践也能够使得结对编程更加容易进行： 编码标准可以消除一些无谓的分歧。 隐喻可以帮助结对伙伴更好地沟通。 简单设计可以使得结对伙伴更了解他们所从事的工作。 结对编程技术被誉为 XP 保持工作质量、强调人文主义的一个典型的实践，应用得当还能够使得开发团队之前的协作更加流畅、知识交流与共享更加频繁，团队的稳定性也会更加稳固。 集体代码所有制由于 XP 方法论鼓励团队进行结对编程，而且认为结对编程的组合应该动态地搭配，根据任务的不同、专业技能的不同进行最优组合。由于每个人都肯定会遇到不同的代码，所以代码的所有制就不再适合于私有，因为那样会给修改工作带来巨大的不便。 也就是说，团队中的每个成员都拥有对代码进行改进的权利，每个人都拥有全部代码，也都需要对全部代码负责。同时，XP 强调代码是谁破坏的（也就是修改后发生问题），就应该由谁来修复。 由于在 XP 中，有一些与之匹配的最佳实践，因此你并无须担心采用集体代码所有制会让你的代码变得越来越乱： 由于在 XP 项目中，集成工作是一件经常性得工作，因此当有人修改代码而带来了集成的问题，会在很快的时间内被发现。 由于每一个类都会有一个测试代码，因此不论谁修改了代码，都需要运行这个测试代码，这样偶然性的破坏发生的概率将很小。 由于每一个代码的修改就是通过了结对的两个程序员共同思考，因此通常做出的修改都是对系统有益的。 由于大家都坚持了相同的编码标准，因此代码的可读性、可修改性都会比较好，而且还能够避免由于命名法、缩进等小问题引发经常性得代码修改。 集成代码所有制是 XP 与其他敏捷方法的一个较大不同，也是从另一个侧面体现了 XP 中蕴含的很深厚的编码情节。 持续集成在前面谈到小型发布、重构、结对编程、集体代码所有制等最佳实践的时候，我们多次看到“持续集成”的身影，可以说持续集成是对这些最佳实践的基本支撑条件。 可能大家会对持续集成与小型发布代表的意思混淆不清，其实小型发布是指在开发周期经常发布中间版本，而持续集成的含义则是要求 XP 团队每天尽可能多次地做代码集成，每次都在确保系统运行的单元测试通过之后进行。 这样，就可以及早地暴露、消除由于重构、集体代码所有制所引入的错误，从而减少解决问题的痛苦 要在开发过程中做到持续集成并不容易，首先需要养成这个习惯。而且集成工作往往是十分枯燥、烦琐的，因此适当地引入每日集成工具是十分必要的。XP 建议大家首先使用配置管理服务器将代码管理起来，然后使用 Ant 或 Nant 等 XP 工具，编写集成脚本，调用 xUint 等测试框架，这样就可以实现每当程序员将代码 Check in 到配置服务器上时，Ant 就会自动完成编译和集成，并调用测试代码完成相应的测试工作。 每周工作 40 小时／可持续的速度这是最让开发人员开心的、管理者反对的一个最佳实践了，加班、再加班早已成为开发人员的家常便饭，也是管理者最常使用的一种策略，而 XP 方法论认为，加班最终会扼杀团队的积极性，最终导致项目失败，这也充分体现了 XP 方法关注人的因素比关注过程的因素更多一些。 Kent Beck 认为开发人员即使能够工作更长的时间，他们也不该这样做，因为这样做会使他们更容易厌倦编程工作，从而产生一些影响他们效能的其他问题。因此，每周工作 40 小时是一种顺势行为，是一种规律。其实对于开发人员和管理者来说，违反这种规律是不值得的。 开发人员：如果不懂得休息，那么就无法将自己的节奏调整到最佳状态，那么就会带来很大的负面影响。而且在精神不集中的状态下，开发质量也得不到保证。 管理者：也许这可以称得上“第二种人月神话”，那就是你不得不通过延长每天的工作时间来获得更多的人月。这是因为，每个开发人员的工作精力是有限的，不可能无限增长，在精力不足的时候，不仅写出来的代码质量没有保障，而且还可能为项目带来退步的效果。因此采用加班的方式并不是一个理性的方式，是得不偿失的。 不过有一点是需要解释的，“每周工作 40 小时”中的 40 不是一个绝对数，它所代表的意思是团队应该保证按照“正常的时间”进行工作。那么如何做到这一点呢？ 首先，定义符合你团队情况的“正常工作时间”。 其次，逐步将工作时间调整到“正常工作时间”。 再次，除非你的时间计划一团糟，否则不应该在时间妥协。 最后，鼓起勇气，制定一个合情合理的时间表。 正如米卢说过的“享受足球”一样，同样地，每一个开发人员应该做到“享受编程”，那么“每周工作 40 小时”就是你的起点。 团队只有持久才有获胜的希望。他们以能够长期维持的速度努力工作，他们保存精力，他们把项目看作是马拉松长跑，而不是全速短跑。 现场客户为了保证开发出来的结果与客户的预想接近，XP 方法论认为最重要的需要将客户请到开发现场。就像计划游戏中提到过的，在 XP 项目中，应该时刻保证客户负责业务决策，开发团队负责技术决策。因此，在项目中有客户在现场明确用户故事，并做出相应的业务决策，对于 XP 项目而言有着十分重要的意义。 也许有人会问，客户提交了用户故事之后不就完成工作了吗？其实很多尝试过用户故事的团队都会发现其太过简单，包含的信息量极少，XP方法论不会不了解，因此，不会把用户故事当做开发人员交付代码的唯一指示。用户故事只是一个起点，后面的细节还需要开发人员与客户之间建立起来的良好沟通来补充。 作为一名有经验的开发人员，绝对不会对现场客户的价值产生任何怀疑，但是都会觉得想要实现现场客户十分困难。要实现这一点，需要对客户进行沟通，让其明白，想对于开发团队，项目成功对于客户而言更为重要。而现场客户则是保障项目成功的一个重要措施，想想在你装修房子的时候，你是不是常常在充当现场客户的角色呢？其实这隐喻就是让客户理解现场客户重要性最好的突破口。 其实现场客户在具体实施时，也不是一定需要客户一直和开发团队在一起，而是在开发团队应该和客户能够随时沟通，可以是面谈，可以是在线聊天，可以是电话，当然面谈是必不可少的。其中的关键是当开发人员需要客户做出业务决策是，需要进一步了解业务细节时能够随时找到相应的客户。 不过，也有一些项目是可以不要现场客户参与的： 当开发组织中已经有相关的领域专家时。 当做一些探索性工作，而且客户也不知道他想要什么时（例如新产品、新解决方案的研究与开发）。 去尝试吧，现场客户不仅可以争取得到，而且还能使得团队焕然一新，与客户建立起良好的合作与信任。 编码标准编码标准是一个“雅俗共享”的最佳实践，不管是代表重型方法论的 RUP，PSP，还是代表敏捷方法论的 XP，都认为开发团队应该拥有一个编码标准。XP 方法论认为拥有编码标准可以避免团队在一些与开发进度无关的细节问题上发生争论，而且会给重构、结对编程带来很大麻烦。试想如果有人将你上次写的代码的变量命名法做了修改，下次你需要再改这部分代码时，会是一种什么感觉呢？ 不过，XP 方法论的编码标准的目的不是创建一个事无巨细的规则表，而是只要能够提供一个确保代码清晰，便于交流的指导方针。 如果你的团队已经拥有编码标准，就可以直接使用它，并在过程中进行完善。如果还没有，那么大家可以先进行编码，然后在过程中逐步总结出编码规则，边做边形成。当然除了这种文字规范以外，还可以采用一些如自动格式化代码工具之类的方法进行代码规范。，事实上，你只需要很好地贯彻执行其他的实践并且进行沟通，编码标准会很容易地浮现出来。 配合是关键有句经典名言“1+1 &gt; 2 ”最适合表达 XP 的观点，Kent Beck 认为 XP 方法论的最大价值在于在项目中融会贯通地运用12个最佳实践，而非单独地使用。你当然可以使用其中的一些实践，但这并不意味着你就运用了 XP 方法论。XP 方法论真正能够发挥其效能，就必须完整地运用12个实践。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发]]></title>
    <url>%2F2013%2F03%2F14%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay54_%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%2F01.%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[了解敏捷开发三分钟了解敏捷开发小灰经过千辛万苦，终于拿到了心仪的 offer，今天小灰上班的第一天 …… 下班后，小灰找到同学大黄来请教 …… 场景一：小灰在餐厅 场景二：无奈的项目经理 什么是敏捷开发？敏捷开发（Agile）是一种以人为核心、迭代、循序渐进的开发方法。 在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。 简单地来说，敏捷开发并不追求前期完美的设计、完美编码，而是力求在很短的周期内开发出产品的核心功能，尽早发布出可用的版本。然后在后续的生产周期内，按照新需求不断迭代升级，完善产品。 这一切正如某人的名言： 是谁这么厉害，提出了敏捷开发思想？是一位名叫 Martin Fowler 的美国大叔。 大叔不但是敏捷开发的创始人之一，还在面向对象开发、设计模式、UML 建模领域做出了重要贡献。目前担任 ThoughtWorks 公司的首席科学家。 敏捷开发模式的分类敏捷开发的实现主要包括 SCRUM、XP（极限编程）、Crystal Methods、FDD（特性驱动开发）等等。其中 SCRUM 与 XP 最为流行。 同样是敏捷开发，XP 极限编程 更侧重于实践，并力求把实践做到极限。这一实践可以是测试先行，也可以是结对编程等，关键要看具体的应用场景。 SCRUM 则是一种开发流程框架，也可以说是一种套路。SCRUM 框架中包含三个角色，三个工件，四个会议，听起来很复杂，其目的是为了有效地完成每一次迭代周期的工作。在这里我们重点讨论的是 SCRUM。 SCRUM 的工作流程学习 Scrum 之前，我们先要了解几个基本术语： Sprint：冲刺周期，通俗的讲就是实现一个“小目标”的周期。一般需要 2-6 周时间。 User Story：用户的外在业务需求。拿银行系统来举例的话，一个 Story 可以是用户的存款行为，或者是查询余额等等。也就是所谓的小目标本身。 Task：由 User Story 拆分成的具体开发任务。 Backlog：需求列表，可以看成是小目标的清单。分为 Sprint Backlog 和 Product Backlog。 Daily meeting：每天的站会，用于监控项目进度。有些公司直接称其为 Scrum。 Sprint Review meeting: 冲刺评审会议，让团队成员们演示成果。 Sprint burn down：冲刺燃尽图，说白了就是记录当前周期的需求完成情况。 Release：开发周期完成，项目发布新的可用版本。 如上图所示，在项目启动之前，会由团队的产品负责人（Product owner）按照需求优先级来明确出一份 Product Backlog，为项目做出整体排期。 随后在每一个小的迭代周期里，团队会根据计划（Sprint Plan Meeting）确定本周期的 Sprint Backlog，再细化成一个个 Task，分配给团队成员，进行具体开发工作。每一天，团队成员都会进行 Daily meeting，根据情况更新自己的 Task 状态，整个团队更新 Sprint burn down chart。 当这一周期的 Sprint backlog 全部完成，团队会进行 Spring review meeting，也就是评审会议。一切顺利的话，会发布出这一版本的 Release，并且进行 Sprint 回顾会议（Sprint Retrospective Meeting）。 那么，现实中的 Scrum 是什么样的情景呢？看看下面的照片就知道了： 敏捷开发与 DevOpsDevOps 是 Development 和 Operations 的合成词，其目标是要加强开发人员、测试人员、运维人员之间的沟通协调。如何实现这一目标呢？需要我们的项目做到持续集成、持续交付、持续部署。 时下流行的 Jenkins、Bamboo，就是两款优秀的持续集成工具。而 Docker 容器则为 DevOps 提供了强大而有效的统一环境。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf]]></title>
    <url>%2F2013%2F03%2F13%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay52_Apache%20Http%20Client%2F02.Thymeleaf%2F</url>
    <content type="text"><![CDATA[ThymeleafSpringMVC 项目引入 Thymeleaf添加依赖1234567891011&lt;!--引入模版引擎thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring4&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 配置属性spring-mvc.xml1234567891011121314151617&lt;!-- 定义视图文件解析 --&gt; &lt;!-- 模板解析器 --&gt; &lt;bean id="templateResolver" class="org.thymeleaf.templateresolver.ServletContextTemplateResolver"&gt; &lt;property name="prefix" value="/WEB-INF/templates/" /&gt; &lt;property name="suffix" value=".html" /&gt; &lt;property name="templateMode" value="HTML5" /&gt; &lt;property name="characterEncoding" value="UTF-8"/&gt; &lt;/bean&gt; &lt;bean id="templateEngine" class="org.thymeleaf.spring4.SpringTemplateEngine"&gt; &lt;property name="templateResolver" ref="templateResolver" /&gt; &lt;/bean&gt; &lt;bean class="org.thymeleaf.spring4.view.ThymeleafViewResolver"&gt; &lt;property name="templateEngine" ref="templateEngine" /&gt; &lt;property name="characterEncoding" value="UTF-8" /&gt; &lt;/bean&gt; 页面引入xmlns12&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;/html&gt; Thymeleaf 一般用法th属性常用th属性解读html有的属性，Thymeleaf基本都有，而常用的属性大概有七八个。其中th属性执行的优先级从1~8，数字越低优先级越高。 一、th:text ：设置当前元素的文本内容，相同功能的还有th:utext，两者的区别在于前者不会转义html标签，后者会。优先级不高：order=7 二、th:value：设置当前元素的value值，类似修改指定属性的还有th:src，th:href。优先级不高：order=6 三、th:each：遍历循环元素，和th:text或th:value一起使用。注意该属性修饰的标签位置，详细往后看。优先级很高：order=2 四、th:if：条件判断，类似的还有th:unless，th:switch，th:case。优先级较高：order=3 五、th:insert：代码块引入，类似的还有th:replace，th:include，三者的区别较大，若使用不恰当会破坏html结构，常用于公共代码块提取的场景。优先级最高：order=1 六、th:fragment：定义代码块，方便被th:insert引用。优先级最低：order=8 七、th:object：声明变量，一般和*{}一起配合使用，达到偷懒的效果。优先级一般：order=4 八、th:attr：修改任意属性，实际开发中用的较少，因为有丰富的其他th属性帮忙，类似的还有th:attrappend，th:attrprepend。优先级一般：order=5 常用th属性使用使用Thymeleaf属性需要注意点以下五点： 一、若要使用Thymeleaf语法，首先要声明名称空间： xmlns:th=&quot;http://www.thymeleaf.org&quot; 二、设置文本内容 th:text，设置input的值 th:value，循环输出 th:each，条件判断 th:if，插入代码块 th:insert，定义代码块 th:fragment，声明变量 th:object 三、th:each 的用法需要格外注意，打个比方：如果你要循环一个div中的p标签，则th:each属性必须放在p标签上。若你将th:each属性放在div上，则循环的是将整个div。 四、变量表达式中提供了很多的内置方法，该内置方法是用#开头，请不要与#{}消息表达式弄混。 五、th:insert，th:replace，th:include 三种插入代码块的效果相似，但区别很大。 test.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;!--名称空间--&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Thymeleaf 语法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;ITDragon Thymeleaf 语法&lt;/h2&gt; &lt;!--th:text 设置当前元素的文本内容，常用，优先级不高--&gt; &lt;p th:text="$&#123;thText&#125;" /&gt; &lt;p th:utext="$&#123;thUText&#125;" /&gt; &lt;!--th:value 设置当前元素的value值，常用，优先级仅比th:text高--&gt; &lt;input type="text" th:value="$&#123;thValue&#125;" /&gt; &lt;!--th:each 遍历列表，常用，优先级很高，仅此于代码块的插入--&gt; &lt;!--th:each 修饰在div上，则div层重复出现，若只想p标签遍历，则修饰在p标签上--&gt; &lt;div th:each="message : $&#123;thEach&#125;"&gt; &lt;!-- 遍历整个div-p，不推荐--&gt; &lt;p th:text="$&#123;message&#125;" /&gt; &lt;/div&gt; &lt;div&gt; &lt;!--只遍历p，推荐使用--&gt; &lt;p th:text="$&#123;message&#125;" th:each="message : $&#123;thEach&#125;" /&gt; &lt;/div&gt; &lt;!--th:if 条件判断，类似的有th:switch，th:case，优先级仅次于th:each, 其中#strings是变量表达式的内置方法--&gt; &lt;p th:text="$&#123;thIf&#125;" th:if="$&#123;not #strings.isEmpty(thIf)&#125;"&gt;&lt;/p&gt; &lt;!--th:insert 把代码块插入当前div中，优先级最高，类似的有th:replace，th:include，~&#123;&#125; ：代码块表达式 从common.html 中找到 copy--&gt; &lt;div th:insert="~&#123;common::copy&#125;"&gt;&lt;/div&gt; &lt;!--th:object 声明变量，和*&#123;&#125; 一起使用--&gt; &lt;div th:object="$&#123;user&#125;"&gt; &lt;p&gt;ID: &lt;span th:text="*&#123;name&#125;" /&gt;&lt;/p&gt;&lt;!--th:text="$&#123;user.name&#125;"--&gt; &lt;p&gt;TH: &lt;span th:text="*&#123;age&#125;" /&gt;&lt;/p&gt;&lt;!--$&#123;user.age&#125;--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; common.html 123456&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;footer th:fragment="copy"&gt; &amp;copy; 2018 jackiechan&lt;/footer&gt;&lt;/html&gt; 后台给负责给变量赋值，和跳转页面。 12345678910111213141516171819202122232425import com.itdragon.entities.ThObject;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import java.util.ArrayList;import java.util.Arrays;import java.util.List;@Controllerpublic class ThymeleafController &#123; @RequestMapping("thymeleaf") public String thymeleaf(ModelMap map) &#123; map.put("thText", "th:text 设置文本内容 &lt;b&gt;加粗&lt;/b&gt;"); map.put("thUText", "th:utext 设置文本内容 &lt;b&gt;加粗&lt;/b&gt;"); map.put("thValue", "thValue 设置当前元素的value值"); map.put("thEach", Arrays.asList("th:each", "遍历列表")); map.put("thIf", "msg is not null"); User user = new User(); user.setName("zhangsan"); user.setAge(18); map.put("user", user); return "/test"; &#125;&#125; 标准表达式语法${...} 变量表达式，Variable Expressions @{...} 链接表达式，Link URL Expressions #{...} 消息表达式，Message Expressions ~{...} 代码块表达式，Fragment Expressions *{...} 选择变量表达式，Selection Variable Expressions 变量表达式使用频率最高，其功能也是非常的丰富。所以我们先从简单的代码块表达式开始，然后是消息表达式，再是链接表达式，最后是变量表达式，随带介绍选择变量表达式。 ~{…} 代码块表达式支持两种语法结构推荐：~{templatename::fragmentname} 支持：~{templatename::#id} templatename：模版名，Thymeleaf会根据模版名解析完整路径：/resources/templates/templatename.html，要注意文件的路径。 fragmentname：片段名，Thymeleaf通过th:fragment声明定义代码块，即：th:fragment=&quot;fragmentname&quot; id：HTML的id选择器，使用时要在前面加上#号，不支持class选择器。 代码块表达式的使用代码块表达式需要配合th属性（th:insert，th:replace，th:include）一起使用。 th:insert：将代码块片段整个插入到使用了th:insert的HTML标签中， th:replace：将代码块片段整个替换使用了th:replace的HTML标签中， th:include：将代码块片段包含的内容插入到使用了th:include的HTML标签中， 用一个官方例子来区分三者的不同，第三部分会通过实战再次用到该知识。 123456789101112131415161718192021222324&lt;!--th:fragment定义代码块标识--&gt;&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;!--三种不同的引入方式--&gt;&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;&lt;!--th:insert是在div中插入代码块，即多了一层div--&gt;&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;!--th:replace是将代码块代替当前div，其html结构和之前一致--&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;!--th:include是将代码块footer的内容插入到div中，即少了一层footer--&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; #{…} 消息表达式消息表达式一般用于国际化的场景。结构：th:text=&quot;#{msg}&quot; 。会在第三部分的实战详细介绍。 @{…} 链接表达式链接表达式好处不管是静态资源的引用，form表单的请求，凡是链接都可以用@{...} 。这样可以动态获取项目路径，即便项目名变了，依然可以正常访问 12#修改项目名，链接表达式会自动修改路径，避免资源文件找不到server.context-path=/itdragon 链接表达式结构无参：@{/xxx} 有参：@{/xxx(k1=v1,k2=v2)} 对应url结构：xxx?k1=v1&amp;k2=v2 引入本地资源：@{/项目本地的资源路径} 引入外部资源：@{/webjars/资源在jar包中的路径} 列举：第三部分的实战引用会详细使用该表达式 12345&lt;link th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt;&lt;link th:href="@&#123;/main/css/itdragon.css&#125;" rel="stylesheet"&gt;&lt;form class="form-login" th:action="@&#123;/user/login&#125;" th:method="post" &gt;&lt;a class="btn btn-sm" th:href="@&#123;/login.html(l='zh_CN')&#125;"&gt;中文&lt;/a&gt;&lt;a class="btn btn-sm" th:href="@&#123;/login.html(l='en_US')&#125;"&gt;English&lt;/a&gt; ${…}变量表达式变量表达式有丰富的内置方法，使其更强大，更方便。 变量表达式功能一、可以获取对象的属性和方法 二、可以使用ctx，vars，locale，request，response，session，servletContext内置对象 三、可以使用dates，numbers，strings，objects，arrays，lists，sets，maps等内置方法（重点介绍） 常用的内置对象一、ctx ：上下文对象。 二、vars ：上下文变量。 三、locale：上下文的语言环境。 四、request：（仅在web上下文）的 HttpServletRequest 对象。 五、response：（仅在web上下文）的 HttpServletResponse 对象。 六、session：（仅在web上下文）的 HttpSession 对象。 七、servletContext：（仅在web上下文）的 ServletContext 对象 这里以常用的Session举例，用户刊登成功后，会把用户信息放在Session中，Thymeleaf通过内置对象将值从session中获取。 1234// java 代码将用户名放在session中session.setAttribute("userinfo",username);// Thymeleaf通过内置对象直接获取th:text="$&#123;session.userinfo&#125;" 常用的内置方法一、strings：字符串格式化方法，常用的Java方法它都有。比如：equals，equalsIgnoreCase，length，trim，toUpperCase，toLowerCase，indexOf，substring，replace，startsWith，endsWith，contains，containsIgnoreCase等 二、numbers：数值格式化方法，常用的方法有：formatDecimal等 三、bools：布尔方法，常用的方法有：isTrue，isFalse等 四、arrays：数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等 五、lists，sets：集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等 六、maps：对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等 七、dates：日期方法，常用的方法有：format，year，month，hour，createNow等 文章底部提供了对应的官网链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ITDragon Thymeleaf 内置方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;ITDragon Thymeleaf 内置方法&lt;/h2&gt; &lt;h3&gt;#strings &lt;/h3&gt; &lt;div th:if="$&#123;not #strings.isEmpty(itdragonStr)&#125;" &gt; &lt;p&gt;Old Str : &lt;span th:text="$&#123;itdragonStr&#125;"/&gt;&lt;/p&gt; &lt;p&gt;toUpperCase : &lt;span th:text="$&#123;#strings.toUpperCase(itdragonStr)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;toLowerCase : &lt;span th:text="$&#123;#strings.toLowerCase(itdragonStr)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;equals : &lt;span th:text="$&#123;#strings.equals(itdragonStr, 'itdragonblog')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;equalsIgnoreCase : &lt;span th:text="$&#123;#strings.equalsIgnoreCase(itdragonStr, 'itdragonblog')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;indexOf : &lt;span th:text="$&#123;#strings.indexOf(itdragonStr, 'r')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;substring : &lt;span th:text="$&#123;#strings.substring(itdragonStr, 2, 8)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;replace : &lt;span th:text="$&#123;#strings.replace(itdragonStr, 'it', 'IT')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;startsWith : &lt;span th:text="$&#123;#strings.startsWith(itdragonStr, 'it')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text="$&#123;#strings.contains(itdragonStr, 'IT')&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#numbers &lt;/h3&gt; &lt;div&gt; &lt;p&gt;formatDecimal 整数部分随意，小数点后保留两位，四舍五入: &lt;span th:text="$&#123;#numbers.formatDecimal(itdragonNum, 0, 2)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;formatDecimal 整数部分保留五位数，小数点后保留两位，四舍五入: &lt;span th:text="$&#123;#numbers.formatDecimal(itdragonNum, 5, 2)&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#bools &lt;/h3&gt; &lt;div th:if="$&#123;#bools.isTrue(itdragonBool)&#125;"&gt; &lt;p th:text="$&#123;itdragonBool&#125;"&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#arrays &lt;/h3&gt; &lt;div th:if="$&#123;not #arrays.isEmpty(itdragonArray)&#125;"&gt; &lt;p&gt;length : &lt;span th:text="$&#123;#arrays.length(itdragonArray)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text="$&#123;#arrays.contains(itdragonArray, 5)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;containsAll : &lt;span th:text="$&#123;#arrays.containsAll(itdragonArray, itdragonArray)&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#lists &lt;/h3&gt; &lt;div th:if="$&#123;not #lists.isEmpty(itdragonList)&#125;"&gt; &lt;p&gt;size : &lt;span th:text="$&#123;#lists.size(itdragonList)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text="$&#123;#lists.contains(itdragonList, 0)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;sort : &lt;span th:text="$&#123;#lists.sort(itdragonList)&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#maps &lt;/h3&gt; &lt;div th:if="$&#123;not #maps.isEmpty(itdragonMap)&#125;"&gt; &lt;p&gt;size : &lt;span th:text="$&#123;#maps.size(itdragonMap)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;containsKey : &lt;span th:text="$&#123;#maps.containsKey(itdragonMap, 'thName')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;containsValue : &lt;span th:text="$&#123;#maps.containsValue(itdragonMap, '#maps')&#125;"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#dates &lt;/h3&gt; &lt;div&gt; &lt;p&gt;format : &lt;span th:text="$&#123;#dates.format(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;custom format : &lt;span th:text="$&#123;#dates.format(itdragonDate, 'yyyy-MM-dd HH:mm:ss')&#125;"/&gt;&lt;/p&gt; &lt;p&gt;day : &lt;span th:text="$&#123;#dates.day(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;month : &lt;span th:text="$&#123;#dates.month(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;monthName : &lt;span th:text="$&#123;#dates.monthName(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;year : &lt;span th:text="$&#123;#dates.year(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;dayOfWeekName : &lt;span th:text="$&#123;#dates.dayOfWeekName(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;hour : &lt;span th:text="$&#123;#dates.hour(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;minute : &lt;span th:text="$&#123;#dates.minute(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;second : &lt;span th:text="$&#123;#dates.second(itdragonDate)&#125;"/&gt;&lt;/p&gt; &lt;p&gt;createNow : &lt;span th:text="$&#123;#dates.createNow()&#125;"/&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 后台给负责给变量赋值，和跳转页面。 1234567891011121314@RequestMapping("varexpressions")public String varexpressions(ModelMap map) &#123; map.put("itdragonStr", "itdragonBlog"); map.put("itdragonBool", true); map.put("itdragonArray", new Integer[]&#123;1,2,3,4&#125;); map.put("itdragonList", Arrays.asList(1,3,2,4,0)); Map itdragonMap = new HashMap(); itdragonMap.put("thName", "$&#123;#...&#125;"); itdragonMap.put("desc", "变量表达式内置方法"); map.put("itdragonMap", itdragonMap); map.put("itdragonDate", new Date()); map.put("itdragonNum", 888.888D); return "grammar/varexpressions";&#125; Thymeleaf 高级使用提取公共页面为了统一页面风格，提高页面的复用率，我们一般都会提取公共页面。之前在文章中介绍了SiteMesh的使用，今天用Thymeleaf来实现。 统一规范引入的资源文件 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head th:fragment="common-head"&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="initial-scale=1.0, width=device-width, user-scalable=no" /&gt; &lt;title&gt;ITDragon系统&lt;/title&gt; &lt;link type="image/x-icon" href="images/favicon.ico" rel="shortcut icon"&gt; &lt;link th:href="@&#123;/sb-admin-1.0.4/css/bootstrap.min.css&#125;" rel="stylesheet"&gt; &lt;link th:href="@&#123;/sb-admin-1.0.4/css/sb-admin.css&#125;" rel="stylesheet"&gt; &lt;link th:href="@&#123;/sb-admin-1.0.4/css/plugins/morris.css&#125;" rel="stylesheet"&gt; &lt;link th:href="@&#123;/sb-admin-1.0.4/font-awesome/css/font-awesome.min.css&#125;" rel="stylesheet"&gt; &lt;script th:src="@&#123;/sb-admin-1.0.4/js/jquery.js&#125;"&gt;&lt;/script&gt; &lt;script th:src="@&#123;/sb-admin-1.0.4/js/bootstrap.min.js&#125;"&gt;&lt;/script&gt; &lt;script th:src="@&#123;/sb-admin-1.0.4/js/plugins/morris/raphael.min.js&#125;"&gt;&lt;/script&gt; &lt;script th:src="@&#123;/sb-admin-1.0.4/js/plugins/morris/morris.min.js&#125;"&gt;&lt;/script&gt; &lt;script th:src="@&#123;/sb-admin-1.0.4/js/plugins/morris/morris-data.js&#125;"&gt;&lt;/script&gt; &lt;/head&gt;&lt;/html&gt; 统一左侧菜单栏 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;header id="header" th:fragment="common-header"&gt; &lt;!-- Navigation --&gt; &lt;nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/dashboard"&gt;ITDragon sb-admin-1.0.4&lt;/a&gt; &lt;/div&gt; &lt;!--和知识点没关系的代码，这里就补贴出来了，完整代码请异步github--&gt; &lt;!-- Sidebar Menu Items - These collapse to the responsive navigation menu on small screens --&gt; &lt;div class="collapse navbar-collapse navbar-ex1-collapse"&gt; &lt;ul class="nav navbar-nav side-nav itdragon-nav"&gt; &lt;li th:class="$&#123;activeUrl=='dashboard'?'nav-link active':'nav-link'&#125;"&gt; &lt;a th:href="@&#123;/dashboard&#125;"&gt;&lt;i class="fa fa-fw fa-dashboard"&gt;&lt;/i&gt; Dashboard&lt;/a&gt; &lt;/li&gt; &lt;li th:class="$&#123;activeUrl=='employees'?'nav-link active':'nav-link'&#125;"&gt; &lt;a th:href="@&#123;/employees&#125;"&gt;&lt;i class="fa fa-fw fa-bar-chart-o"&gt;&lt;/i&gt; Employees&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- /.navbar-collapse --&gt; &lt;/nav&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 以上代码用到了三个知识点： 一、使用链接表达式引入本地的资源文件，若引入第三方外部资源文件，可以通过webjars（将资源文件打成jar包放在项目中）方式引入。 二、使用th:fragment标识需要被引用的代码块，也可以用id选择器但不推荐。 三、activeUrl变量是通过代码块表达式在其他页面传入的变量，这也是代码块表达式强大的一个功能。 页面显示和国际化Spring Boot 实现国际化步骤： 第一步：准备好国际化文件，至少三分（系统默认，中文，英文） 第二步：在Spring Boot全局配置文件中，指定国际化文件路径， 第三步：自定义Locale Resolver 第四步：在页面上使用消息表达式输出国际化内容 这里只贴出第四步的代码，前三步以及完整代码请异步github 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head th:replace="~&#123;commons/default::common-head&#125;"&gt; &lt;meta name="viewport" content="initial-scale=1.0, width=device-width, user-scalable=no" /&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,Chrome=1" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=8" /&gt; &lt;title&gt;员工列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="wrapper"&gt; &lt;header th:replace="~&#123;commons/header::common-header(activeUrl='employees')&#125;"&gt;&lt;/header&gt; &lt;div id="page-wrapper"&gt; &lt;div class="container-fluid"&gt; &lt;!-- Page Heading --&gt; &lt;div class="row"&gt; &lt;div class="col-lg-12"&gt; &lt;h1 class="page-header" th:text="#&#123;employees&#125;"&gt;&lt;/h1&gt; &lt;ol class="breadcrumb"&gt; &lt;li&gt;&lt;i class="fa fa-dashboard"&gt;&lt;/i&gt; &lt;a th:href="@&#123;/dashboard&#125;" th:text="#&#123;dashboard&#125;"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class="active"&gt;&lt;i class="fa fa-table"&gt;&lt;/i&gt; &lt;span th:text="#&#123;employees&#125;"&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row" th:if="$&#123;not #strings.isEmpty(message)&#125;"&gt; &lt;div class="col-lg-12"&gt; &lt;div class="alert alert-info alert-dismissable"&gt; &lt;button type="button" class="close" data-dismiss="alert" aria-hidden="true"&gt;&amp;times;&lt;/button&gt; &lt;i class="fa fa-info-circle"&gt;&lt;/i&gt; &lt;strong th:text="$&#123;message&#125;"&gt;&lt;/strong&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /.row --&gt; &lt;div class="row"&gt; &lt;div class="col-lg-12"&gt; &lt;h2 th:text="#&#123;employees&#125;"&gt;&lt;/h2&gt; &lt;div class="table-responsive"&gt; &lt;a class="pull-right btn" th:href="@&#123;/employee&#125;" th:text="#&#123;add.employees&#125;"&gt;&lt;/a&gt; &lt;table class="table table-striped table-sm"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th th:text="#&#123;id&#125;"&gt;&lt;/th&gt; &lt;th th:text="#&#123;last.name&#125;"&gt;&lt;/th&gt; &lt;th th:text="#&#123;email&#125;"&gt;&lt;/th&gt; &lt;th th:text="#&#123;gender&#125;"&gt;&lt;/th&gt; &lt;th th:text="#&#123;department&#125;"&gt;&lt;/th&gt; &lt;th th:text="#&#123;position&#125;"&gt;&lt;/th&gt; &lt;th th:text="#&#123;birth&#125;"&gt;&lt;/th&gt; &lt;th th:text="#&#123;operation&#125;"&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each="emp:$&#123;employees&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?#&#123;female&#125;:#&#123;male&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.position&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-success" th:href="@&#123;/employee/&#125;+$&#123;emp.id&#125;" th:text="#&#123;edit&#125;"&gt;&lt;/a&gt; &lt;a class="btn btn-sm btn-danger deleteBtn" th:href="@&#123;/employee/&#125;+$&#123;emp.id&#125;" th:text="#&#123;delete&#125;"&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /.row --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以上代码用到了知识点： 一、页面通过代码块表达式引入公共代码块，并传入参数给公共代码块文件。 二、页面使用消息表达式输出国际化内容。 三、使用th:if属性条件判断，使用内置方法#strings.isEmpty 判断参数是否为空，使用内置方法#dates.format 格式化参数 四、使用th:each属性循环遍历，注意该属性修改在tr标签上。并使用th:text属性给td标签赋值 总结一、Thymeleaf 是Spring Boot 官方推荐的Java模版引擎框架，其文件扩展名为.html 二、Thymeleaf 几乎支持所有的html属性，用于赋值的th:text和th:value，用于循环遍历的th:each，用于条件判断的th:if 三、Thymeleaf 提供四种标准的表达式，有丰富内置方法的${}，用于国际化的#{}，用于代码插入的~{}，用于处理链接的@{} 四、一定要注意循环遍历的th:each和代码插入的th:insert用法，尽量避免破坏html结构的细节问题]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache HttpClient]]></title>
    <url>%2F2013%2F03%2F12%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay52_Apache%20Http%20Client%2F01.Apache%20HttpClient%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Apache HttpClient简易架构图 Apache HttpClient 简介 HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和 HTMLUnit 都使用了 HttpClient。 HttpClient 相比传统 JDK 自带的 URLConnection，增加了易用性和灵活性，它不仅是客户端发送 HTTP 请求变得容易，而且也方便了开发人员测试接口（基于 HTTP 协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握 HttpClient 是很重要的必修内容，掌握 HttpClient 后，相信对于 HTTP 协议的了解会更加深入。 Apache HttpClient 特性 基于标准、纯净的 Java 语言。实现了 HTTP 1.0 和 HTTP 1.1 以可扩展的面向对象的结构实现了 HTTP 全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。 支持 HTTPS 协议。 通过 HTTP 代理建立透明的连接。 利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。 Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos 认证方案。 插件式的自定义认证方案。 便携可靠的套接字工厂使它更容易的使用第三方解决方案。 连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。 自动处理 Set-Cookie 中的 Cookie。 插件式的自定义 Cookie 策略。 Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。 Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。 在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。 直接获取服务器发送的 response code 和 headers。 设置连接超时的能力。 实验性的支持 HTTP 1.1 response caching。 源代码基于 Apache License 可免费获取。 Apache HttpClient 使用流程使用 HttpClient 发送请求、接收响应很简单，一般需要如下几步即可。 创建 HttpClient 对象。 创建请求方法的实例，并指定请求 URL。如果需要发送 GET 请求，创建 HttpGet 对象；如果需要发送 POST 请求，创建 HttpPost 对象。 如果需要发送请求参数，可调用 HttpGet、HttpPost 共同的 setParams(HttpParams params) 方法来添加请求参数；对于 HttpPost 对象而言，也可调用 setEntity(HttpEntity entity) 方法来设置请求参数。 调用 HttpClient 对象的 execute(HttpUriRequest request) 发送请求，该方法返回一个 HttpResponse。 调用 HttpResponse 的 getAllHeaders()、getHeaders(String name) 等方法可获取服务器的响应头；调用 HttpResponse 的 getEntity() 方法可获取 HttpEntity 对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。 释放连接。无论执行方法是否成功，都必须释放连接 Apache HttpClient 使用实例POMpom.xml 配置如下： 1234567891011121314151617&lt;!-- Apache Http Begin --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;fluent-hc&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpmime&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Apache Http End --&gt; 主要增加了 org.apache.httpcomponents:httpclient、org.apache.httpcomponents:fluent-hc、org.apache.httpcomponents:httpmime 三个依赖 创建 HttpGet 请求案例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.funtl.hello.httpclient;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;public class MyTest &#123; public static void main(String[] args) &#123; get(); &#125; private static void get() &#123; // 创建 HttpClient 客户端 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建 HttpGet 请求 HttpGet httpGet = new HttpGet("http://localhost:8080/content/page?draw=1&amp;start=0&amp;length=10"); // 设置长连接 httpGet.setHeader("Connection", "keep-alive"); // 设置代理（模拟浏览器版本） httpGet.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"); // 设置 Cookie httpGet.setHeader("Cookie", "UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4"); CloseableHttpResponse httpResponse = null; try &#123; // 请求并获得响应结果 httpResponse = httpClient.execute(httpGet); HttpEntity httpEntity = httpResponse.getEntity(); // 输出请求结果 System.out.println(EntityUtils.toString(httpEntity)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 无论如何必须关闭连接 finally &#123; if (httpResponse != null) &#123; try &#123; httpResponse.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (httpClient != null) &#123; try &#123; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 控制台输出结果： 1&#123;"draw":1,"recordsTotal":1,"recordsFiltered":1,"data":[&#123;"id":33,"created":1530542074000,"updated":1530542074000,"title":"ad1","subTitle":"ad1","titleDesc":"ad1","url":"https://sale.jd.com/act/XkCzhoisOMSW.html","pic":"https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg","pic2":"","content":"&lt;p&gt;&lt;br&gt;&lt;/p&gt;","tbContentCategory":&#123;"id":89,"created":null,"updated":null,"parent":null,"isParent":null,"name":"幻灯片","status":null,"sortOrder":null&#125;&#125;],"error":null&#125; 创建 HttpPost 请求案例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.funtl.hello.httpclient;import org.apache.http.HttpEntity;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.List;public class MyTest &#123; public static void main(String[] args) &#123; post(); &#125; private static void post() &#123; // 创建 HttpClient 客户端 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建 HttpPost 请求 HttpPost httpPost = new HttpPost("http://localhost:8080/content/page"); // 设置长连接 httpPost.setHeader("Connection", "keep-alive"); // 设置代理（模拟浏览器版本） httpPost.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"); // 设置 Cookie httpPost.setHeader("Cookie", "UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4"); // 创建 HttpPost 参数 List&lt;BasicNameValuePair&gt; params = new ArrayList&lt;BasicNameValuePair&gt;(); params.add(new BasicNameValuePair("draw", "1")); params.add(new BasicNameValuePair("start", "0")); params.add(new BasicNameValuePair("length", "10")); CloseableHttpResponse httpResponse = null; try &#123; // 设置 HttpPost 参数 httpPost.setEntity(new UrlEncodedFormEntity(params, "UTF-8")); httpResponse = httpClient.execute(httpPost); HttpEntity httpEntity = httpResponse.getEntity(); // 输出请求结果 System.out.println(EntityUtils.toString(httpEntity)); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 无论如何必须关闭连接 finally &#123; try &#123; if (httpResponse != null) &#123; httpResponse.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (httpClient != null) &#123; httpClient.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 控制台输出结果： 1&#123;"draw":1,"recordsTotal":1,"recordsFiltered":1,"data":[&#123;"id":33,"created":1530542074000,"updated":1530542074]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 缓存]]></title>
    <url>%2F2013%2F03%2F11%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay51_MyBatis%E8%BF%9B%E9%98%B6%2F04.MyBatis%20%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[MyBatis 缓存mybatis缓存分析mybatis提供查询缓存，如果缓存中有数据就不用从数据库中获取，用于减轻数据压力，提高系统性能。 ​ 一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。 ​ 二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 ​ Mybatis的缓存，包括一级缓存和二级缓存 一级缓存指的就是sqlsession，在sqlsession中有一个数据区域，是map结构，这个区域就是一级缓存区域。一级缓存中的key是由sql语句、条件、statement等信息组成一个唯一值。一级缓存中的value，就是查询出的结果对象。 二级缓存指的就是同一个namespace下的mapper，二级缓存中，也有一个map结构，这个区域就是二级缓存区域。二级缓存中的key是由sql语句、条件、statement等信息组成一个唯一值。二级缓存中的value，就是查询出的结果对象。 一级缓存是默认使用的。 ​ 二级缓存需要手动开启。 一级缓存原理 ​ 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。 ​ 如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 ​ 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。 ​ Mybatis默认支持一级缓存。 测试1123456789101112@Test public void testOneLevelCache() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库 User user1 = mapper.findUserById(1); System.out.println(user1); // 第二次查询ID为1的用户 User user2 = mapper.findUserById(1); System.out.println(user2); sqlSession.close(); &#125; 测试21234567891011121314151617@Test public void testOneLevelCache() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库 User user1 = mapper.findUserById(1); System.out.println(user1); User user = new User(); user.setUsername("tom"); user.setAddress("北京"); //执行增删改操作，清空缓存 mapper.insertUser(user); // 第二次查询ID为1的用户 User user2 = mapper.findUserById(1); System.out.println(user2); sqlSession.close(); &#125; 应用正式开发，是将mybatis和spring进行整合开发，事务控制在service中。 一个service方法中包括 很多mapper方法调用。 123456789service&#123;//开始执行时，开启事务，创建SqlSession对象//第一次调用mapper的方法findUserById(1)//第二次调用mapper的方法findUserById(1)，从一级缓存中取数据//方法结束，sqlSession关闭&#125; 如果是执行两次service调用查询相同 的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空。 二级缓存原理下图是多个sqlSession请求UserMapper的二级缓存图解。 二级缓存是mapper级别的。 第一次调用mapper下的SQL去查询用户信息。查询到的信息会存到该mapper对应的二级缓存区域内。 第二次调用相同namespace下的mapper映射文件中相同的SQL去查询用户信息。会去对应的二级缓存内取结果。 如果调用相同namespace下的mapper映射文件中的增删改SQL，并执行了commit操作。此时会清空该namespace下的二级缓存。 开启二级缓存Mybatis默认是没有开启二级缓存 1、 在核心配置文件SqlMapConfig.xml中加入以下内容（开启二级缓存总开关）： 在settings标签中添加以下内容： 12&lt;!-- 开启二级缓存总开关 --&gt;&lt;setting name="cacheEnabled" value="true"/&gt; 2、 在UserMapper映射文件中，加入以下内容，开启二级缓存： 12&lt;!-- 开启本mapper下的namespace的二级缓存，默认使用的是mybatis提供的PerpetualCache --&gt;&lt;cache&gt;&lt;/cache&gt; 实现序列化由于二级缓存的数据不一定都是存储到内存中，它的存储介质多种多样，所以需要给缓存的对象执行序列化。 如果该类存在父类，那么父类也要实现序列化。 测试11234567891011121314151617181920@Test public void testTwoLevelCache() &#123; SqlSession sqlSession1 = sqlSessionFactory.openSession(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); SqlSession sqlSession3 = sqlSessionFactory.openSession(); UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); UserMapper mapper3 = sqlSession3.getMapper(UserMapper.class); // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库 User user1 = mapper1.findUserById(1); System.out.println(user1); // 关闭SqlSession1 sqlSession1.close(); // 第二次查询ID为1的用户 User user2 = mapper2.findUserById(1); System.out.println(user2); // 关闭SqlSession2 sqlSession2.close(); &#125; Cache Hit Radio ： 缓存命中率 第一次缓存中没有记录，则命中率0.0； 第二次缓存中有记录，则命中率0.5（访问两次，有一次命中） 测试21234567891011121314151617181920212223242526272829@Test public void testTwoLevelCache() &#123; SqlSession sqlSession1 = sqlSessionFactory.openSession(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); SqlSession sqlSession3 = sqlSessionFactory.openSession(); UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); UserMapper mapper3 = sqlSession3.getMapper(UserMapper.class); // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库 User user1 = mapper1.findUserById(1); System.out.println(user1); // 关闭SqlSession1 sqlSession1.close(); //修改查询出来的user1对象，作为插入语句的参数 user1.setUsername("tom"); user1.setAddress("北京"); mapper3.insertUser(user1); // 提交事务 sqlSession3.commit(); // 关闭SqlSession3 sqlSession3.close(); // 第二次查询ID为1的用户 User user2 = mapper2.findUserById(1); System.out.println(user2); // 关闭SqlSession2 sqlSession2.close(); &#125; 根据SQL分析，确实是清空了二级缓存了。 禁用二级缓存该statement中设置useCache=false，可以禁用当前select语句的二级缓存，即每次查询都是去数据库中查询，默认情况下是true，即该statement使用二级缓存。 1234&lt;select id="findUserById" parameterType="int" resultType="com.qf.mybatis.po.User" useCache="true"&gt; SELECT * FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; 刷新二级缓存该statement中设置flushCache=true可以刷新当前的二级缓存，默认情况下如果是select语句，那么flushCache是false。如果是insert、update、delete语句，那么flushCache是true。 如果查询语句设置成true，那么每次查询都是去数据库查询，即意味着该查询的二级缓存失效。 如果查询语句设置成false，即使用二级缓存，那么如果在数据库中修改了数据，而缓存数据还是原来的，这个时候就会出现脏读。 flushCache设置如下： 1234&lt;select id="findUserById" parameterType="int" resultType="com.qf.mybatis.po.User" useCache="true" flushCache="true"&gt; SELECT * FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; ​ 整合ehcache（了解）​ Ehcache是一个分布式缓存。 分布式缓存​ 系统为了提高性能，通常会对系统采用分布式部署（集群部署方式） ​ 不使用分布式缓存，缓存的数据在各个服务单独存储，不方便开发。所以要使用分布式缓存对缓存数据进行集中式管理。 ​ Mybatis自身无法实现分布式缓存，需要和其它分布式缓存框架进行整合。 整合思路（重点）​ Mybatis提供了一个cache接口，同时它自己有一个默认的实现类 PerpetualCache。 ​ 通过实现cache接口可以实现mybatis缓存数据通过其他缓存数据库整合，mybatis的特长是sql，缓存数据管理不是mybatis的特长，为了提高mybatis的性能，所以需要mybatis和第三方缓存数据库整合，比如ehcache、memcache、redis等 ​ Mybatis提供接口如下： ​ Mybatis的默认实现类： 整合ehcache的步骤 引入ehcache的jar包； 在mapper映射文件中，配置cache标签的type为ehcache对cache接口的实现类类型。 加入ehcache的配置文件 第一步：引入ehcache的依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 第二步：配置cache的type属性12&lt;!-- 使用默认二级缓存 --&gt;&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache" /&gt; 第三步：添加ehcache的配置文件在classpath下添加ehcache.xml 123456789101112131415161718192021&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../config/ehcache.xsd"&gt; &lt;!-- 缓存数据要存放的磁盘地址 --&gt; &lt;diskStore path="F:\develop\ehcache" /&gt; &lt;!-- diskStore：指定数据在磁盘中的存储位置。  defaultCache：当借助CacheManager.add("demoCache")创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略 以下属性是必须的：  maxElementsInMemory - 在内存中缓存的element的最大数目  maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大  eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断  overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 以下属性是可选的：  timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大  timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.  diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。  diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作  memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt; &lt;defaultCache maxElementsInMemory="1000" maxElementsOnDisk="10000000" eternal="false" overflowToDisk="false" timeToIdleSeconds="120" timeToLiveSeconds="120" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 应用场景​ 使用场景：对于访问响应速度要求高，但是实时性不高的查询，可以采用二级缓存技术。 ​ 注意：在使用二级缓存的时候，要设置一下刷新间隔（cache标签中有一个flashInterval属性）来定时刷新二级缓存，这个刷新间隔根据具体需求来设置，比如设置30分钟、60分钟等，单位为毫秒。 局限性​ Mybatis二级缓存对细粒度的数据级别的缓存实现不好。 ​ 场景：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次查询都是最新的商品信息，此时如果使用二级缓存，就无法实现当一个商品发生变化只刷新该商品的缓存信息而不刷新其他商品缓存信息，因为二级缓存是mapper级别的，当一个商品的信息发送更新，所有的商品信息缓存数据都会清空。 ​ 解决此类问题，需要在业务层根据需要对数据有针对性的缓存。比如可以对经常变化的 数据操作单独放到另一个namespace的mapper中。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 延迟加载]]></title>
    <url>%2F2013%2F03%2F10%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay51_MyBatis%E8%BF%9B%E9%98%B6%2F03.MyBatis%20%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[MyBatis 延迟加载什么是延迟加载​ resultMap中的association和collection标签具有延迟加载的功能。 ​ 延迟加载的意思是说，在关联查询时，利用延迟加载，先加载主信息。需要关联信息时再去按需加载关联信息。这样会大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 设置延迟加载​ Mybatis默认是不开启延迟加载功能的，我们需要手动开启。 ​ 需要在SqlMapConfig.xml文件中，在标签中开启延迟加载功能。 ​ lazyLoadingEnabled、aggressiveLazyLoading 设置项 描述 允许值 默认值 lazyLoadingEnabled 全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。 true \ false true aggressiveLazyLoading 当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。 true \ false true 使用association进行延迟加载需求​ 查询订单并且关联查询用户信息（对用户信息的加载要求是按需加载） 编写映射文件​ 需要定义两个mapper的方法对应的statement。 1、只查询订单信息 ​ SELECT * FROM orders ​ 在查询订单的statement中使用association去延迟加载（执行）下边的satatement(关联查询用户信息) 12345678910111213141516171819&lt;!-- 定义OrdersUserLazyLoadingRstMap --&gt;&lt;resultMap type="com.qf.mybatis.po.Orders" id="OrdersUserLazyLoadingRstMap"&gt; &lt;id column="id" property="id" /&gt; &lt;result column="user_id" property="userId" /&gt; &lt;result column="number" property="number" /&gt; &lt;result column="createtime" property="createtime" /&gt; &lt;result column="note" property="note" /&gt; &lt;!-- 延迟加载用户信息 --&gt; &lt;!-- select：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement） 我们使用UserMapper.xml中的findUserById完成根据用户ID（user_id）查询用户信 如果findUserById不在本mapper中，前边需要加namespace --&gt; &lt;!-- column：主信息表中需要关联查询的列，此处是user_id --&gt; &lt;association property="user" select="com.qf.mybatis.mapper.UserMapper.findUserById" column="user_id"&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;!-- 查询订单信息，延迟加载关联查询的用户信息 --&gt;&lt;select id="findOrdersUserLazyLoading" resultMap="OrdersUserLazyLoadingRstMap"&gt; SELECT * FROM orders&lt;/select&gt; 2、关联查询用户信息 ​ 通过上边查询到的订单信息中user_id去关联查询用户信息 ​ 使用UserMapper.xml中的findUserById 1234&lt;select id="findUserById" parameterType="int" resultType="com.qf.mybatis.po.User"&gt; SELECT * FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; ​ 上边先去执行findOrdersUserLazyLoading，当需要去查询用户的时候再去执行findUserById，通过resultMap的定义将延迟加载执行配置起来。 加载映射文件 &lt;package name=”com.qf.mybatis.mapper”/&gt; 编写mapper接口// 查询订单信息，延迟加载关联查询的用户信息 public List findOrdersUserLazyLoading(); 编写测试代码思路： 1、执行上边mapper方法（findOrdersUserLazyLoading），内部去调用com.qf.mybatis.mapper.OrdersMapper中的findOrdersUserLazyLoading只查询orders信息（单表）。 2、在程序中去遍历上一步骤查询出的List，当我们调用Orders中的getUser方法时，开始进行延迟加载。 3、执行延迟加载，去调用UserMapper.xml中findUserbyId这个方法获取用户信息。 1234567891011121314@Testpublic void testFindOrdersUserLazyLoading() &#123; // 创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession构造usermapper的代理对象 OrdersMapper ordersMapper = sqlSession.getMapper(OrdersMapper.class); // 调用usermapper的方法 List&lt;Orders&gt; list = ordersMapper.findOrdersUserLazyLoading(); for(Orders orders : list)&#123; System.out.println(orders.getUser()); &#125; // 释放SqlSession sqlSession.close();&#125; 延迟加载思考不使用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载？？ 实现方法如下： 定义两个mapper方法： 1、查询订单列表 2、根据用户id查询用户信息 实现思路： 先去查询第一个mapper方法，获取订单信息列表 在程序中（service），按需去调用第二个mapper方法去查询用户信息。 总之： 使用延迟加载方法，先去查询简单的sql（最好单表，也可以关联查询），再去按需要加载关联查询的其它信息。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 关系映射]]></title>
    <url>%2F2013%2F03%2F09%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay51_MyBatis%E8%BF%9B%E9%98%B6%2F02.MyBatis%20%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[MyBatis关联映射主键映射主键映射作用 当数据插入操作不关心插入后数据的主键（唯一标识），那么建议使用 不返回自增主键值 的方式来配置插入语句，这样可以避免额外的SQL开销. 当执行插入操作后需要立即获取插入的自增主键值，比如一次操作中保存一对多这种关系的数据，那么就要使用 插入后获取自增主键值 的方式配置. ​ mybatis进行插入操作时，如果表的主键是自增的，针对不同的数据库相应的操作也不同。基本上经常会遇到的就是Oracle Sequece 和 Mysql 自增主键，解释如下。 自动递增​ 一对多的那种表结构，在插入多端数据时，需要获取刚刚保存了的一段的主键。那么这个时候，上述的配置就无法满足需要了。为此我们需要使用mybatis提供useGeneratedKeys和keyProperty来单独配置针对自增逐渐的处理。 Mysql自增主键配置针对于Mysql这种自己维护主键的数据库，可以直接使用以下配置在插入后获取插入主键， 12345678910111213141516171819 &lt;insert id="insert" useGeneratedKeys="true" keyProperty="id"&gt;INSERT INTO tb_user ( username, password, phone, email, created, updated ) VALUES ( #&#123;username&#125;, #&#123;password&#125;, #&#123;phone&#125;, #&#123;email&#125;, #&#123;created&#125;, #&#123;update&#125; ) &lt;/insert&gt; 关联映射关联映射作用​ 在现实的项目中进行数据库建模时，我们要遵循数据库设计范式的要求，会对现实中的业务模型进行拆分，封装在不同的数据表中，表与表之间存在着一对多或是多对多的对应关系。进而，我们对数据库的增删改查操作的主体，也就从单表变成了多表。那么Mybatis中是如何实现这种多表关系的映射呢？ 查询结果集ResultMap ​ resultMap 元素是 MyBatis 中最重要最强大的元素。它就是让你远离 90%的需要从结果 集中取出数据的 JDBC 代码的那个东西，而且在一些情形下允许你做一些 JDBC 不支持的事 情。 事实上, 编写相似于对复杂语句联合映射这些等同的代码，也许可以跨过上千行的代码。 ​ 有朋友会问，之前的示例中我们没有用到结果集，不是也可以正确地将数据表中的数据映射到Java对象的属性中吗？是的。这正是resultMap元素设计的初衷，就是简单语句不需要明确的结果映射，而很多复杂语句确实需要描述它们的关系。 resultMap元素中，允许有以下直接子元素： constructor － 类在实例化时，用来注入结果到构造方法中（本文中暂不讲解） id － 作用与result相同，同时可以标识出用这个字段值可以区分其他对象实例。可以理解为数据表中的主键，可以定位数据表中唯一一笔记录 result － 将数据表中的字段注入到Java对象属性中 association － 关联，简单的讲，就是“有一个”关系，如“用户”有一个“帐号” collection － 集合，顾名思议，就是“有很多”关系，如“客户”有很多“订单” discriminator － 使用结果集决定使用哪个个结果映射（暂不涉及） 每个元素的用法及属性我会在下面结合使用进行讲解。 我们在数据库中额外创建三张数据表，分别表示销售人员、客户，以及销售和客户多对多的对应关系。每个销售、客户都有一个登录帐号。 123456789101112131415161718192021222324252627282930313233343536CREATE TABLE `customer` ( `customer_id` int(10) NOT NULL AUTO_INCREMENT, `customer_name` varchar(200) NOT NULL, `user_id` int(10) DEFAULT NULL, `is_valid` tinyint(4) NOT NULL DEFAULT '1', `created_time` datetime NOT NULL, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`customer_id`), KEY `customer_name` (`customer_name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;CREATE TABLE `salesman` ( `sales_id` int(10) NOT NULL AUTO_INCREMENT, `sales_name` varchar(64) NOT NULL, `sales_phone` varchar(32) DEFAULT NULL, `sales_fax` varchar(32) DEFAULT NULL, `sales_email` varchar(100) DEFAULT NULL, `user_id` int(10) DEFAULT NULL, `report_to` int(10) DEFAULT '0', `is_valid` tinyint(4) NOT NULL DEFAULT '1', `created_time` datetime DEFAULT NULL, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`sales_id`), KEY `sales_name` (`sales_name`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;CREATE TABLE `customer_sales` ( `id` int(10) NOT NULL AUTO_INCREMENT, `customer_id` int(10) NOT NULL, `sales_id` int(10) NOT NULL, `created_time` datetime NOT NULL, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `customer_id` (`customer_id`,`sales_id`) USING BTREE, KEY `sales_id` (`sales_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; ​ 实现销售与登录用户一对一关系 ​ 这里采用Mybatis的接口式编程。无论是对单表进行映射，还是对多表映射，步骤都是相同的，唯一的不同就在映射文件的编写上。 首先，我们需要销售创建一个Java类，其中的userInfo属性对应销售的登录用户信息的。 12345678910public class Sales &#123; private int salesId; private String salesName; private String phone; private String fax; private String email; private int isValid; private Timestamp createdTime; private Timestamp updateTime; private User userInfo; 第二步，编写Mybatis映射文件，需要注意的是映射文件的名称空间，要与我们编写的接品的全限定名一致（包名＋接口名） 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.qf.dao.ISalesDao"&gt; &lt;resultMap id="salesResultMap" type="com.qf.pojo.Sales"&gt; &lt;id property="salesId" column="sales_id" /&gt; &lt;result property="salesName" column="sales_name" /&gt; &lt;result property="phone" column="sales_phone" /&gt; &lt;result property="fax" column="sales_fax" /&gt; &lt;result property="email" column="sales_email" /&gt; &lt;!-- 定义多对一关联信息（每个销售人员对应一个登录帐号） --&gt; &lt;association property="userInfo" column="user_id" javaType="User" select="selectUser"&gt; &lt;id property="userId" column="userId" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPassword" column="user_password" /&gt; &lt;result property="nickName" column="nick_name" /&gt; &lt;result property="email" column="email" /&gt; &lt;result property="isValid" column="is_valid" /&gt; &lt;result property="createdTime" column="created_time" /&gt; &lt;result property="updateTime" column="update_time" /&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectUser" resultType="User"&gt; SELECT user_id, user_name, user_password, nick_name, email, is_valid, created_time FROM sys_user WHERE user_id = #&#123;id&#125; &lt;/select&gt; &lt;select id="getById" parameterType="int" resultMap="salesResultMap" &gt; SELECT sales_id, sales_name, sales_phone, sales_fax, sales_email, user_id, is_valid, created_time, update_time FROM salesman WHERE sales_id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 第三步，将映射文件注册到Mybatis中。 1234&lt;mappers&gt; &lt;mapper resource="com/qf/mapping/User.xml" /&gt; &lt;mapper resource="com/qf/mapping/Sales.xml" /&gt;&lt;/mappers&gt; 第四步，编写接口 123public interface ISalesDao &#123; public Sales getById(int id); &#125; 第五步，编写测试用例 123456789101112131415161718192021222324252627282930313233public class SalesDaoTest &#123; private Reader reader; private SqlSessionFactory sqlSessionFactory; @Before public void setUp() throws Exception &#123; try &#123; reader = Resources.getResourceAsReader("mybatis.xml"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; @After public void tearDown() throws Exception &#123; &#125; @Test public void getById() &#123; SqlSession session = sqlSessionFactory.openSession(); try &#123; ISalesDao sd = session.getMapper(ISalesDao.class); Sales sales = sd.getById(2); assertNotNull(sales); System.out.println(sales); &#125; finally &#123; session.close(); &#125; &#125;&#125; 下面我们就针对第二步，映射文件中的resultMap编写进行详细讲解。 12345678910111213141516171819202122&lt;resultMap id="salesResultMap" type="com.qf.pojo.Sales"&gt; &lt;id property="salesId" column="sales_id" /&gt; &lt;result property="salesName" column="sales_name" /&gt; &lt;result property="phone" column="sales_phone" /&gt; &lt;result property="fax" column="sales_fax" /&gt; &lt;result property="email" column="sales_email" /&gt; &lt;result property="isValid" column="is_valid" /&gt; &lt;result property="createdTime" column="createdTime" /&gt; &lt;result property="updateTime" column="update_time" /&gt; &lt;!-- 定义多对一关联信息（每个销售人员对应一个登录帐号） --&gt; &lt;association property="userInfo" column="user_id" javaType="User" select="selectUser"&gt; &lt;id property="userId" column="userId" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPassword" column="user_password" /&gt; &lt;result property="nickName" column="nick_name" /&gt; &lt;result property="email" column="email" /&gt; &lt;result property="isValid" column="is_valid" /&gt; &lt;result property="createdTime" column="created_time" /&gt; &lt;result property="updateTime" column="update_time" /&gt; &lt;/association&gt;&lt;/resultMap&gt; ​ 和其他元素一样，我们都需要为其取一个唯一的id，并指定其在Java中对应的类型，由于我没有在Mybatis配置文件中为Sales类指定别名，所以这里使用的是全限定名。 1&lt;resultMap id="salesResultMap" type="com.qf.pojo.Sales"&gt; ​ 使用id和result元素指定数据表中字段与Java类中属性的映射关系，除了我phone、fax和email三行映射代码，其余的全部可以省去不写。为什么？这个就像前面示例中使用到的User类一样，Mybatis会自动帮助我们完成映射工作，不需要我们额外编写代码。那么为什么phone、fax和email这三个字段的映射关系不能省略呢？这是因为我在编写Sales类的时候埋下了伏笔，我故意不按照按驼峰规则对这三个属性进行命名，同时也不与数据表中的字段名相同，为了确保可以正确的将字段映射到属性上，我们必须手工编写映射在代码，明确地告诉Mybatis我们的映射规则。 12345&lt;resultMap id="salesResultMap" type="com.qf.pojo.Sales"&gt; &lt;result property="phone" column="sales_phone" /&gt; &lt;result property="fax" column="sales_fax" /&gt; &lt;result property="email" column="sales_email" /&gt;&lt;/resultMap&gt; ​ 下面重点来了，association元素来帮助我们完成销售与登录用户对应关系的映射。她实现了“有一个”的关系映射，我们需要做的只是告诉Mybatis，这个关系是通过哪一个字段来建立关联的，被关联的对象类型是什么，以及将关联对象映射到哪个属性上面。如果被关联对象的数据结构比较简单，就如本文中的登录用户表这样，那么可以有更简单的写法。 1&lt;association property="userInfo" column="user_id" javaType="User" select="selectUser" /&gt; 我们还需要告诉Mybatis，加载关联的方式。MyBatis 在这方面会有两种不同的方式: 嵌套查询:通过执行另外一个 SQL 映射语句来返回预期的复杂类型。 嵌套结果:使用嵌套结果映射来处理重复的联合结果的子集。 嵌套查询映射我们在这里先使用嵌套查询来实现。使用属性select指定了关联数据的查询语句。 1234&lt;select id="selectUser" resultType="User"&gt; SELECT user_id, user_name, user_password, nick_name, email, is_valid, created_time FROM sys_user WHERE user_id = #&#123;id&#125; &lt;/select&gt; 当对Sales进行映射的时候，Mybatis会使用这个名为selectUser的查询语句去获取相关联的数据信息。这种方法使用起来很简单。但是简单，不代表最好。对于大型数据集合和列表这种方式将会有性能上的问题，就是我们熟知的 “N+1 查询问题”。概括地讲,N+1 查询问题可以是这样引起的: 你执行了一个单独的 SQL 语句来获取结果列表(就是“+1”)。 对返回的每条记录,你执行了一个查询语句来为每个加载细节(就是“N”)。 这个问题会导致成百上千的 SQL 语句被执行。这通常不是期望的。 MyBatis 能延迟加载这样的查询就是一个好处,因此你可以分散这些语句同时运行的消耗。然而,如果你加载一个列表,之后迅速迭代来访问嵌套的数据,你会调用所有的延迟加载,这样的行为可能是很糟糕的。 嵌套结果映射下面我们就来讲一下另一种实式方式：嵌套结果。使用这种方式，就可以有效地避免了N+1问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.qf.dao.ISalesDao"&gt; &lt;resultMap id="salesResultMap" type="com.qf.pojo.Sales"&gt; &lt;id property="salesId" column="sales_id" /&gt; &lt;result property="salesName" column="sales_name" /&gt; &lt;result property="phone" column="sales_phone" /&gt; &lt;result property="fax" column="sales_fax" /&gt; &lt;result property="email" column="sales_email" /&gt; &lt;result property="isValid" column="is_valid" /&gt; &lt;result property="createdTime" column="created_time" /&gt; &lt;result property="updateTime" column="update_time" jdbcType="TIMESTAMP" /&gt; &lt;!-- 定义多对一关联信息（嵌套结果方式） --&gt; &lt;association property="userInfo" resultMap="userResult" /&gt; &lt;/resultMap&gt; &lt;resultMap id="userResult" type="User"&gt; &lt;id property="userId" column="user_id" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPassword" column="user_password" /&gt; &lt;result property="nickName" column="nick_name" /&gt; &lt;result property="email" column="user_email" /&gt; &lt;result property="isValid" column="user_is_valid" /&gt; &lt;result property="createdTime" column="user_created_time" /&gt; &lt;result property="updateTime" column="user_update_time" /&gt; &lt;/resultMap&gt; &lt;select id="getById" parameterType="int" resultMap="salesResultMap"&gt; SELECT sales_id, sales_name, sales_phone, sales_fax, sales_email, salesman.is_valid, salesman.created_time, salesman.update_time, sys_user.user_id as user_id, user_name, user_password, nick_name, email as user_email, sys_user.is_valid as user_is_valid, sys_user.created_time as user_created_time, sys_user.update_time as user_update_time FROM salesman left outer join sys_user using(user_id) WHERE sales_id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 和嵌套查询相比，使用嵌套结果方式，在映射文件上主要有以下三处修改： 一、修改association元素，无需指定column，另外将resultType改为使用resultMap。为什么？这是因为后面我们会把select语句改为多表关联查询，这样就会有些字段名是冲突的，我们不得不使用别名。这一点对于Mybatis而言，就相当于字段名发生了变化，那么就需要我们手工来维护映射关系。另外，我们也无需指定javaType属性了，因为在resultMap中，已经指定了对应的Java实体类，这里就可以省略了。 1&lt;association property="userInfo" resultMap="userResult" /&gt; 二、为关联结果集编写映射关系，大家可以看到，好多字段名称已经发生了变化，如is_valid这个字段由于salesman和sys_user表中都存在这个字段，所以我们不得不为其起了一个别名user_is_valid。 12345678910&lt;resultMap id="userResult" type="User"&gt; &lt;id property="userId" column="user_id" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPassword" column="user_password" /&gt; &lt;result property="nickName" column="nick_name" /&gt; &lt;result property="email" column="user_email" /&gt; &lt;result property="isValid" column="user_is_valid" /&gt; &lt;result property="createdTime" column="user_created_time" /&gt; &lt;result property="updateTime" column="user_update_time" /&gt; &lt;/resultMap&gt; 三、修改查询语句，由单表查询改表多表关联查询 1234567891011&lt;select id="getById" parameterType="int" resultMap="salesResultMap"&gt; SELECT sales_id, sales_name, sales_phone, sales_fax, sales_email, salesman.is_valid, salesman.created_time, salesman.update_time, sys_user.user_id as user_id, user_name, user_password, nick_name, email as user_email, sys_user.is_valid as user_is_valid, sys_user.created_time as user_created_time, sys_user.update_time as user_update_time FROM salesman left outer join sys_user using(user_id) WHERE sales_id=#&#123;id&#125; &lt;/select&gt; 至此，关联映射已讲解完了。还有集合映射没有讲，哇咔咔，内空实在是太多了〜〜〜〜今晚通宵也未必能写得完了。暂时先写到这儿吧，下回再继续讲解如何实现多对多的集合映射。 集合映射集合映射作用集合映射，实现销售与客户的多对多关系 第一步，在动手编写映射文件之前，我们需要对Sales类增加一个List属性，用以保存销售员对应的客户列表。 12345678910111213141516171819202122232425262728293031323334package com.qf.mybatis.entity;import java.util.List;public class Customer &#123; private Long customerId; private String customerName; private List&lt;Salesman&gt; salesmanList; public Long getCustomerId() &#123; return customerId; &#125; public void setCustomerId(Long customerId) &#123; this.customerId = customerId; &#125; public String getCustomerName() &#123; return customerName; &#125; public void setCustomerName(String customerName) &#123; this.customerName = customerName; &#125; public List&lt;Salesman&gt; getSalesmanList() &#123; return salesmanList; &#125; public void setSalesmanList(List&lt;Salesman&gt; salesmanList) &#123; this.salesmanList = salesmanList; &#125;&#125; 同时增加一个客户类。 1234567891011121314151617181920212223242526272829303132333435363738package com.qf.mybatis.entity;import java.util.List;/** * Created by jie on 2019/7/16. */public class Salesman &#123; private Long salesId; private String salesName; private List&lt;Customer&gt; customerList; public Long getSalesId() &#123; return salesId; &#125; public void setSalesId(Long salesId) &#123; this.salesId = salesId; &#125; public String getSalesName() &#123; return salesName; &#125; public void setSalesName(String salesName) &#123; this.salesName = salesName; &#125; public List&lt;Customer&gt; getCustomerList() &#123; return customerList; &#125; public void setCustomerList(List&lt;Customer&gt; customerList) &#123; this.customerList = customerList; &#125;&#125; 第二步，修改映射文件。我们先使用嵌套查询方式来实现为销售加载客户列表。首先在resultMap中增加客户集合映射的定义。 嵌套查询映射123&lt;!-- 定义一对多集合信息（每个销售人员对应多个客户） --&gt;&lt;collection property="salesmanList" column="customer_id" javaType="list" ofType="com.qf.mybatis.entity.Salesman" select="getSalesForCustomer"&gt;&lt;/collection&gt; 集合映射的定义与关联映射定义很相似，除了关键字不同外，还多了两个属性JavaType和ofType。 property用于指定在Java实体类是保存集合关系的属性名称 JavaType用于指定在Java实体类中使用什么类型来保存集合数据，多数情况下这个属性可以省略的。 column用于指定数据表中的外键字段名称。 ofType用于指定集合中包含的类型。 select用于指定查询语句。 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.qf.mybatis.dao.CustomerDao"&gt; &lt;resultMap id="CustomerResultMapper" type="com.qf.mybatis.entity.Customer"&gt; &lt;id property="customerId" column="customer_id"/&gt; &lt;result property="customerName" column="customer_name"/&gt; &lt;collection property="salesmanList" column="customer_id" javaType="list" ofType="com.qf.mybatis.entity.Salesman" select="getSalesForCustomer"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="getById" resultMap="CustomerResultMapper"&gt; SELECT * FROM customer ti WHERE ti.customer_id=#&#123;customerId&#125; &lt;/select&gt; &lt;select id="getSalesForCustomer" resultType="com.qf.mybatis.entity.Salesman"&gt; SELECT * FROM salesman ti INNER JOIN customer_sales cs ON ti.sales_id=cs.sales_id WHERE cs.sales_id=#&#123;salesId&#125; &lt;/select&gt;&lt;/mapper&gt; 嵌套结果映射1234567891011121314151617181920212223242526&lt;resultMap id="salesResultMap" type="com.qf.pojo.Sales"&gt; &lt;id property="salesId" column="sales_id" /&gt; &lt;result property="salesName" column="sales_name" /&gt; &lt;result property="phone" column="sales_phone" /&gt; &lt;result property="fax" column="sales_fax" /&gt; &lt;result property="email" column="sales_email" /&gt; &lt;result property="isValid" column="is_valid" /&gt; &lt;result property="createdTime" column="created_time" /&gt; &lt;result property="updateTime" column="update_time" /&gt; &lt;!-- 定义多对一关联信息（嵌套结果方式） --&gt; &lt;association property="userInfo" resultMap="userResult" /&gt; &lt;!-- 定义一对多集合信息（每个销售人员对应多个客户） --&gt; &lt;!-- &lt;collection property="customers" column="sales_id" select="getCustomerForSales" /&gt; --&gt; &lt;collection property="customers" ofType="com.qf.pojo.Customer"&gt; &lt;id property="customerId" column="customer_id" /&gt; &lt;result property="customerName" column="customer_name" /&gt; &lt;result property="isValid" column="is_valid" /&gt; &lt;result property="createdTime" column="created_time" /&gt; &lt;result property="updateTime" column="update_time" /&gt; &lt;!-- 映射客户与登录用户的关联关系，请注意columnPrefix属性 --&gt; &lt;association property="userInfo" resultMap="userResult" columnPrefix="cu_" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 这里将客户的映射关系直接写在了销售的resultMap中。上述代码与关联映射十分相似，只是有一点需要朋友们留心，那就是在对客户数据进行映射的时候，我们使用了association元素的一个新的属性columnPrefix。这个属性是做什么用的呢？从名字上理解，就是给每个栏位之前加上前缀。Bingo！答对了，那么什么情况下会使用到这个属性呢？后面我们会结合着修改后的查询语句来说明这个属性的使用场景。请耐心的往下看。：） 映射结果修改好了，紧接着我们就要修改查询语句了。 12345678910111213141516171819202122&lt;select id="getById" parameterType="int" resultMap="salesResultMap"&gt; SELECT s.sales_id, s.sales_name, s.sales_phone, s.sales_fax, s.sales_email, s.is_valid, s.created_time, s.update_time, su.user_id as user_id, su.user_name, su.user_password, su.nick_name, su.email as user_email, su.is_valid as user_is_valid, su.created_time as user_created_time, su.update_time as user_update_time, c.customer_id, c.customer_name, c.is_valid as customer_is_valid, c.created_time as customer_created_time, c.update_time as customer_update_time, cu.user_id as cu_user_id, cu.user_name as cu_user_name, cu.user_password as cu_user_password, cu.nick_name as cu_nick_name, cu.email as cu_user_email, cu.is_valid as cu_user_is_valid, cu.created_time as cu_user_created_time, cu.update_time as cu_user_update_time FROM salesman s LEFT OUTER JOIN sys_user su ON s.user_id = su.user_id INNER JOIN customer_sales cs USING(sales_id) LEFT OUTER JOIN customer c USING(customer_id) LEFT OUTER JOIN sys_user cu ON c.user_id = cu.user_id WHERE sales_id=#&#123;id&#125; &lt;/select&gt; 这个语句乍看起来有些复杂，其实很容易理解。这里用到了四张数据表，销售、客户、客房销售关系表和登录用户表。具体的字段我就不说了，主要说一下这个登录用户表。这张数据表在查询语句中出现了两次，为什么呢？因为销售与登录用户有关联关系，同样地，客户也与登录用户表有关联关系，所以我们需要对用户表进行两次Join操作。 那么问题来了，销售要用户有关联，客户也要与用户有关联，这种映射语句应该如何写呢？难道要对用户表写两次映射？聪明的朋友一定会说，我们可以复用之前写过的用户映射结果集呀！答案是肯定的。我们不妨在这里再次贴出这段代码，一起回忆一下。 12345678910&lt;resultMap id="userResult" type="User"&gt; &lt;id property="userId" column="user_id" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPassword" column="user_password" /&gt; &lt;result property="nickName" column="nick_name" /&gt; &lt;result property="email" column="user_email" /&gt; &lt;result property="isValid" column="user_is_valid" /&gt; &lt;result property="createdTime" column="user_created_time" /&gt; &lt;result property="updateTime" column="user_update_time" /&gt; &lt;/resultMap&gt; 数据表中的字段与Java实体类中的属性的映射关系是一一对应的，Mybatis会根据我们定义的映射关系，将数据表中字段的映射到Java实体类属性上。 可是我们的查询语句中对用户表进行了两次Join操作，第一次是销售与用户的Join，第二次是客户与用户的Join。而SQL语句是不允许在同一条查询语句中出现相同字段名的（虽然我们有时候会这样写，但是数据库会自动帮我们为重名的字段名起个别名的，比如在字段名后添加数字）。如果我们为第二次Join进来的用户表中的字段使用别名方式，那么就会导致映射的到客户类中的用户信息缺失，因为字段名与我们在映射文件中的定义不一致。如何解决这个问题呢？这时候该columnPrefix属性出场了。 Mybatis也考虑到这种情况的出现，她允许我们在重复出现的字段名前加上一个统一的字符前缀，这样就可以有效的避免字段重名，又可以复用之前定义的映射结果集。 在上述的查询语句中，我们为第二次Join进来的用户表中的字段都加上了“cu_”做为区分重名字段的前缀，同时使用columnPrefix属性告诉Mybatis在第二次对用户表映射的时候，将字段名是以“cu_”打头的字段值映射到Java实体类属性当中。这样就可以正确的把客户与用户的关联信息映射到Customer对象当中了。 1&lt;association property=&quot;userInfo&quot; resultMap=&quot;userResult&quot; columnPrefix=&quot;cu_&quot; /&gt; 我们之前在User.xml文件中定义过用户表的映射结果集，现在在Sales.xml中也需要使用到同样的结果集，是否可以直接跨文件引用呢？答案是肯定的了，不然对于同一个映射结果集，我们要多处编写，多处维护，这样不仅工作量大，对日后的维护也带来了一定的麻烦。我们只需要在引用处使用结果集的全限定名就可以了。 123456789101112131415161718192021222324252627282930&lt;resultMap id="salesResultMap" type="com.qf.pojo.Sales"&gt; &lt;id property="salesId" column="sales_id" /&gt; &lt;result property="salesName" column="sales_name" /&gt; &lt;result property="phone" column="sales_phone" /&gt; &lt;result property="fax" column="sales_fax" /&gt; &lt;result property="email" column="sales_email" /&gt; &lt;result property="isValid" column="is_valid" /&gt; &lt;result property="createdTime" column="created_time" /&gt; &lt;result property="updateTime" column="update_time" /&gt; &lt;!-- 定义多对一关联信息（嵌套查询方式） --&gt; &lt;!-- &lt;association property="userInfo" column="user_id" javaType="User" select="selectUser" fetchType="lazy"&gt; &lt;/association&gt; --&gt; &lt;!-- 定义多对一关联信息（嵌套结果方式） --&gt; &lt;association property="userInfo" resultMap="com.qf.xml.user.userResult" /&gt; &lt;!-- 定义一对多集合信息（每个销售人员对应多个客户） --&gt; &lt;!-- &lt;collection property="customers" column="sales_id" select="getCustomerForSales" /&gt; --&gt; &lt;collection property="customers" ofType="com.qf.pojo.Customer"&gt; &lt;id property="customerId" column="customer_id" /&gt; &lt;result property="customerName" column="customer_name" /&gt; &lt;result property="isValid" column="is_valid" /&gt; &lt;result property="createdTime" column="created_time" /&gt; &lt;result property="updateTime" column="update_time" /&gt; &lt;association property="userInfo" resultMap="com.qf.xml.user.userResult" columnPrefix="cu_" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 鉴别器鉴别器的作用​ 鉴别器在于确定使用那个ResultMap来映射SQL查询语句，在实现中我们往往有一个基类，然后可以派生一些类。比如我们要选择一群人可以用List，然而Person里面有个性别sex，根据它还可以分为Male或者Female。鉴别器就要根据sex决定用Male还是用Female相关的Mapper进行映射。 ​ 这些话还是很抽象，不过说起鉴别器，语言真的不好用描述，不过不要紧，我们来看一个实例就豁然开朗了，我们知道在上篇中我们已经有了一个员工的POJO，然后继承这个POJO分成一个男性，一个女性的POJO。 鉴别器的使用​ 当我们查询一批员工的时候，我们希望的是返回一个List,而里面的元素根据性别(sex)自动匹配是MaleEmployee或者是FemaleEmployee，于是我们需要根据sex的值去决定使用MaleEmployee或者是FemaleEmployee的resultMap去映射，这便是鉴别器。 ​ 让我们来定义employ的mapper,xml代码如下： 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.qf.mapper.EmployeeMapper"&gt; &lt;resultMap id="employeeMap" type="com.qf.pojo.Employee"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="empName" column="emp_name" /&gt; &lt;result property="sex" column="sex" /&gt; &lt;association property="employeeCard" column="id" select="com.qf.mapper.EmployeeCardMapper.getEmployeeCardByEmpId" /&gt; &lt;collection property="projectList" column="id" select="com.qf.mapper.ProjectMapper.findProjectByEmpId" /&gt; &lt;discriminator javaType="int" column="sex"&gt; &lt;case value="1" resultMap="maleEmployeeMap" /&gt; &lt;case value="2" resultMap="femaleEmployeeMap" /&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;select id="getEmployee" parameterType="int" resultMap="employeeMap"&gt; select id, emp_name as empName, sex from t_employee where id =#&#123;id&#125; &lt;/select&gt; &lt;resultMap id="maleEmployeeMap" type="com.qf.pojo.MaleEmployee" extends="employeeMap"&gt; &lt;collection property="prostateList" select="com.qf.mapper.MaleEmployeeMapper.findProstateList" column="id" /&gt; &lt;/resultMap&gt; &lt;resultMap id="femaleEmployeeMap" type="com.qf.pojo.FemaleEmployee" extends="employeeMap"&gt; &lt;collection property="uterusList" select="com.qf.mapper.FemaleEmployeeMapper.findUterusList" column="id" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 我们这里定义了employee的resultMap，它除了级联其他的和平时我们定义的没什么不一样。这里先不看别的级联，先看看鉴别器：元素，我们定义了用javaType说明它用的是整数作为参数，而column指的是SQL对应的列为sex。 那么定义的是你的条件分支： 当sex=1时候，采用maleEmployeeMap； 当sex=2时，采用femaleEmployeeMap。 maleEmployeeMap和femaleEmployeeMap都继承了employeeMap,并且扩展了一个属性，它们用select属性，来定义如何取对应的属性数据。要记住下面这句话，后面我们还将讨论它：*这里使用了全限定路径，其次用column=”id”作为参数传递，如果是多个参数的，需要用逗号分隔。 3、关联Mapper： 上面我们看到了我们使用了select关联其他的sql语句，而select里面给的就是一个全限定的路径。分别是： com.qf.mapper.MaleEmployeeMapper.findProstateList 和 com.qf.mapper.FemaleEmployeeMapper.findUterusList 现在让我们看看这两个Mapper是怎么样的： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="comqf.mapper.MaleEmployeeMapper"&gt; &lt;select id="findProstateList" parameterType="int" resultType="string"&gt; select prostate from t_healthy_male where emp_id = #&#123;emp_id&#125; &lt;/select&gt;&lt;/mapper&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="comqf.mapper.FemaleEmployeeMapper"&gt; &lt;select id="findUterusList" parameterType="int" resultType="string"&gt; select uterus from t_healthy_female where emp_id = #&#123;emp_id&#125; &lt;/select&gt;&lt;/mapper&gt; 显然他们都比较简单，和我们定义的普通Mapper没什么区别。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 动态SQL]]></title>
    <url>%2F2013%2F03%2F08%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay51_MyBatis%E8%BF%9B%E9%98%B6%2F01.Mybatis%20%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[MyBatis动态SQL动态SQL简介​ MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 ​ 通常使用动态 SQL 不可能是独立的一部分,MyBatis 当然使用一种强大的动态 SQL 语言来改进这种情形,这种语言可以被用在任意的 SQL 映射语句中。 ​ 动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就可以了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。 ​ mybatis 的动态sql语句是基于OGNL表达式的。可以方便的在 sql 语句中实现某些逻辑. 总体说来mybatis 动态SQL 语句主要有以下几类: if 语句 (简单的条件判断) choose (when,otherwize) ,相当于java 语言中的 switch ,与 jstl 中的choose 很类似. trim (对包含的内容加上 prefix,或者 suffix 等，前缀，后缀) where (主要是用来简化sql语句中where条件判断的，能智能的处理 and or ,不必担心多余导致语法错误) set (主要用于更新时) foreach (在实现 mybatis in 语句查询时特别有用) 进行判断if元素​ 动态 SQL 通常要做的事情是有条件地包含 where 子句的一部分。比如: 12345678&lt;select id="findActiveBlogWithTitleLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; ​ 这条语句提供了一个可选的文本查找类型的功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的BLOG都会返回；反之若传入了“title”，那么就会把模糊查找“title”内容的BLOG结果返回(就这个例子而言，细心的读者会发现其中的参数值是可以包含一些掩码或通配符的)。 ​ 如果想可选地通过“title”和“author”两个条件搜索该怎么办呢？首先，改变语句的名称让它更具实际意义；然后只要加入另一个条件即可。 12345678910&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; ​ Mybatis if 标签可用在许多类型的 SQL 语句中，我们以查询为例。首先看一个很普通的查询： 12345&lt;!-- 查询用户列表，like用户名称 --&gt; &lt;select id="getUserListLikeName" parameterType="User" resultMap="userResultMap"&gt; SELECT * from user u WHERE u.username LIKE CONCAT(CONCAT('%', #&#123;username&#125;),'%') &lt;/select&gt; ​ 但是当 username 或 sex 为 null 时，此语句很可能报错或查询结果为空。此时我们使用 if 动态 sql 语句先进行判断，如果值为 null 或等于空字符串，我们就不进行此条件的判断，增加灵活性。 ​ 参数为实体类：User。将实体类中所有的属性均进行判断，如果不为空则执行判断条件。 12345678910111213141516171819202122232425&lt;!-- 添加 if(判断参数) - 将实体类 User 不为空的属性作为 where 条件 --&gt; &lt;select id="getUserList" resultMap="resultMap_User" parameterType="com.qf.pojo.User"&gt; SELECT u.username, u.password, u.sex, u.birthday, u.photo, u.score, u.sign FROM user u WHERE &lt;if test="username !=null "&gt; u.username LIKE CONCAT(CONCAT('%', #&#123;username, jdbcType=VARCHAR&#125;),'%') &lt;/if&gt; &lt;if test="sex!= null and sex != '' "&gt; AND u.sex = #&#123;Sex, jdbcType=INTEGER&#125; &lt;/if&gt; &lt;if test="birthday != null "&gt; AND u.birthday = #&#123;birthday, jdbcType=DATE&#125; &lt;/if&gt; &lt;if test="userId != null and userId != '' "&gt; AND id.user_id = #&#123;userId, jdbcType=VARCHAR&#125; &lt;/if&gt; &lt;/select&gt; ​ 使用时比较灵活，创建新的一个这样的实体类，我们需要限制那个条件，只需要附上相应的值就会 where 这个条件，相反不去赋值就可以不在 where 中判断。 12345678910public void select_by_if() &#123; User user = new User(); user.setUsername(""); user.setSex(1); user.setBirthday(DateUtil.parse("1990-08-18")); List&lt;User&gt; userList = this.dynamicSqlMapper.getUserList_if(user); for (user u : userList) &#123; System.out.println(u.toString()); &#125; &#125; 我们再看看一下另一个示例，先来看看下面的代码： 123456789101112&lt;select id="dynamicIfTest" parameterType="Blog" resultType="Blog"&gt; select * from t_blog where 1 = 1 &lt;if test="title != null"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test="content != null"&gt; and content = #&#123;content&#125; &lt;/if&gt; &lt;if test="owner != null"&gt; and owner = #&#123;owner&#125; &lt;/if&gt; &lt;/select&gt; ​ 这条语句的意思非常简单，如果提供了 title 参数，那么就要满足 title=#{title}，同样如果提供了 Content 和 Owner 的时候，它们也需要满足相应的条件，之后就是返回满足这些条件的所有 Blog，这是非常有用的一个功能，以往我们使用其他类型框架或者直接使用 JDBC的时候， 如果我们要达到同样的选择效果的时候，我们就需要拼 SQL 语句，这是极其麻烦的，比起来，上述的动态SQL就比较简单了。 choose元素​ 有时候我们并不想应用所有的条件，而只是想从多个选项中选择一个。而使用if标签时，只要test中的表达式为 true，就会执行 if 标签中的条件。MyBatis 提供了 choose 元素。if标签是与(and)的关系，而 choose 是或(or)的关系。 ​ choose标签是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when 的条件都不满则时，则执行 otherwise 中的sql。类似于Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。 ​ 例如下面例子，同样把所有可以限制的条件都写上，方面使用。choose会从上到下选择一个when标签的test为true的sql执行。安全考虑，我们使用where将choose包起来，放置关键字多于错误。 1234567891011121314151617181920&lt;!-- choose(判断参数) - 按顺序将实体类 User 第一个不为空的属性作为：where条件 --&gt; &lt;select id="getUserList_choose" resultMap="resultMap_user" parameterType="com.qf.pojo.User"&gt; SELECT * FROM User u &lt;where&gt; &lt;choose&gt; &lt;when test="username !=null "&gt; u.username LIKE CONCAT(CONCAT('%', #&#123;username, jdbcType=VARCHAR&#125;),'%') &lt;/when &gt; &lt;when test="sex != null and sex != '' "&gt; AND u.sex = #&#123;sex, jdbcType=INTEGER&#125; &lt;/when &gt; &lt;when test="birthday != null "&gt; AND u.birthday = #&#123;birthday, jdbcType=DATE&#125; &lt;/when &gt; &lt;otherwise&gt; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; ​ choose (when,otherwize) ,相当于java 语言中的 switch ,与 jstl 中 的 choose 很类似。 1234567891011121314&lt;select id="dynamicChooseTest" parameterType="Blog" resultType="Blog"&gt; select * from t_blog where 1 = 1 &lt;choose&gt; &lt;when test="title != null"&gt; and title = #&#123;title&#125; &lt;/when&gt; &lt;when test="content != null"&gt; and content = #&#123;content&#125; &lt;/when&gt; &lt;otherwise&gt; and owner = "owner1" &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; ​ when元素表示当 when 中的条件满足的时候就输出其中的内容，跟 JAVA 中的 switch 效果差不多的是按照条件的顺序，当 when 中有条件满足的时候，就会跳出 choose，即所有的 when 和 otherwise 条件中，只有一个会输出，当所有的我很条件都不满足的时候就输出 otherwise 中的内容。所以上述语句的意思非常简单， 当 title!=null 的时候就输出 and titlte = #{title}，不再往下判断条件，当title为空且 content!=null 的时候就输出 and content = #{content}，当所有条件都不满足的时候就输出 otherwise 中的内容。 拼关键字where元素​ 当 where 中的条件使用的 if 标签较多时，这样的组合可能会导致错误。当 java 代码按如下方法调用时： 12345678910@Test public void select_test_where() &#123; User user = new User(); user.setUsername(null); user.setSex(1); List&lt;User&gt; userList = this.dynamicSqlMapper.getUsertList_where(user); for (User u : userList ) &#123; System.out.println(u.toString()); &#125; &#125; ​ 如果上面例子，参数 username 为 null，将不会进行列 username 的判断，则会直接导“WHERE AND”关键字多余的错误 SQL。 ​ 这时可以使用 where 动态语句来解决。“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以 AND 或OR 开头的，则它会剔除掉。 ​ 上面例子修改为： 123456789101112131415161718&lt;select id="getUserList_whereIf" resultMap="resultMap_User" parameterType="com.qf.pojo.User"&gt; SELECT u.user_id, u.username, u.sex, u.birthday FROM User u &lt;where&gt; &lt;if test="username !=null "&gt; u.username LIKE CONCAT(CONCAT('%', #&#123;username, jdbcType=VARCHAR&#125;),'%') &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; AND u.sex = #&#123;sex, jdbcType=INTEGER&#125; &lt;/if&gt; &lt;if test="birthday != null "&gt; AND u.birthday = #&#123;birthday, jdbcType=DATE&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; ​ where 主要是用来简化 sql 语句中 where 条件判断，自动地处理 AND/OR 条件。 1234567891011121314&lt;select id="dynamicWhereTest" parameterType="Blog" resultType="Blog"&gt; select * from t_blog &lt;where&gt; &lt;if test="title != null"&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test="content != null"&gt; and content = #&#123;content&#125; &lt;/if&gt; &lt;if test="owner != null"&gt; and owner = #&#123;owner&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; ​ where 元素的作用是会在写入 where 元素的地方输出一个 where，另外一个好处是你不需要考虑 where 元素里面的条件输出是什么样子的，MyBatis 会智能的帮处理，如果所有的条件都不满足那么 MyBatis 就会查出所有的记录，如果输出后是 and 开头的，MyBatis 会把第一个and忽略，当然如果是 or 开头的，MyBatis 也会把它忽略；此外，在 where 元素中你不需要考虑空格的问题，MyBatis 会智能的帮你加上。像上述例子中，如果 title=null， 而 content != null，那么输出的整个语句会是 select from t_blog where content = #{content}，而不是 select from t_blog where and content = #{content}，因为 MyBatis 会自动地把首个 and / or 给忽略。 set元素​ 当 update 语句中没有使用 if 标签时，如果有一个参数为 null，都会导致错误。 ​ 当在 update 语句中使用if标签时，如果前面的if没有执行，则或导致逗号多余错误。使用set标签可以将动态的配置 SET 关键字，并剔除追加到条件末尾的任何不相关的逗号。使用 if+set 标签修改后，如果某项为 null 则不进行更新，而是保持数据库原值。如下示例： 12345678910111213141516&lt;!-- if/set(判断参数) - 将实体 User类不为空的属性更新 --&gt; &lt;update id="updateUser_if_set" parameterType="com.pojo.User"&gt; UPDATE user &lt;set&gt; &lt;if test="username!= null and username != '' "&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test="sex!= null and sex!= '' "&gt; sex = #&#123;sex&#125;, &lt;/if&gt; &lt;if test="birthday != null "&gt; birthday = #&#123;birthday&#125;, &lt;/if&gt; &lt;/set&gt; WHERE user_id = #&#123;userid&#125;; &lt;/update&gt; ​ 再看看下面的一个示例： 123456789101112131415&lt;update id="dynamicSetTest" parameterType="Blog"&gt; update t_blog &lt;set&gt; &lt;if test="title != null"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test="content != null"&gt; content = #&#123;content&#125;, &lt;/if&gt; &lt;if test="owner != null"&gt; owner = #&#123;owner&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; ​ set 标签元素主要是用在更新操作的时候，它的主要功能和 where 标签元素其实是差不多的，主要是在包含的语句前输出一个 set，然后如果包含的语句是以逗号结束的话将会把该逗号忽略，如果 set 包含的内容为空的话则会出错。有了 set 元素就可以动态的更新那些修改了的字段。 trim元素​ trim 是更灵活用来去处多余关键字的标签，它可以用来实现 where 和 set 的效果。 12345678910111213141516&lt;!-- 使用 if/trim 代替 where(判断参数) - 将 User 类不为空的属性作为 where 条件 --&gt; &lt;select id="getUsertList_if_trim" resultMap="resultMap_User"&gt; SELECT * FROM user u &lt;trim prefix="WHERE" prefixOverrides="AND|OR"&gt; &lt;if test="username !=null "&gt; u.username LIKE CONCAT(CONCAT('%', #&#123;username, jdbcType=VARCHAR&#125;),'%') &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; AND u.sex = #&#123;sex, jdbcType=INTEGER&#125; &lt;/if&gt; &lt;if test="birthday != null "&gt; AND u.birthday = #&#123;birthday, jdbcType=DATE&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; ​ trim 代替 set 1234567891011121314151617&lt;!-- if/trim代替set(判断参数) - 将 User 类不为空的属性更新 --&gt; &lt;update id="updateUser_if_trim" parameterType="com.qf.pojo.User"&gt; UPDATE user &lt;trim prefix="SET" suffixOverrides=","&gt; &lt;if test="username != null and username != '' "&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; sex = #&#123;sex&#125;, &lt;/if&gt; &lt;if test="birthday != null "&gt; birthday = #&#123;birthday&#125;, &lt;/if&gt; &lt;/trim&gt; WHERE user_id = #&#123;user_id&#125; &lt;/update&gt; trim (对包含的内容加上 prefix,或者 suffix 等，前缀，后缀) 1234567891011121314&lt;select id="dynamicTrimTest" parameterType="Blog" resultType="Blog"&gt; select * from t_blog &lt;trim prefix="where" prefixOverrides="and |or"&gt; &lt;if test="title != null"&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test="content != null"&gt; and content = #&#123;content&#125; &lt;/if&gt; &lt;if test="owner != null"&gt; or owner = #&#123;owner&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; ​ trim 元素的主要功能是可以在自己包含的内容前加上某些前缀，也可以在其后加上某些后缀，与之对应的属性是 prefix 和 suffix；可以把包含内容的首部某些内容覆盖，即忽略，也可以把尾部的某些内容覆盖，对应的属性是 prefixOverrides 和 suffixOverrides；正因为 trim 有这样的功能，所以我们也可以非常简单的利用 trim 来代替 where 元素的功能。 进行循环foreach元素​ foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。​ foreach元素的属性主要有 item，index，collection，open，separator，close。 ​ item表示集合中每一个元素进行迭代时的别名， ​ index指 定一个名字，用于表示在迭代过程中，每次迭代到的位置， ​ open表示该语句以什么开始， ​ separator表示在每次进行迭代之间以什么符号作为分隔 符， ​ close表示以什么结束。 在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况 下，该属性的值是不一样的，主要有一下3种情况：​ 1. 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list​ 2. 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array ​ 3.如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在breast里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key 下面分别来看看上述三种情况的示例代码： 单参数List的类型123456&lt;select id="dynamicForeachTest" resultType="Blog"&gt; select * from t_blog where id in &lt;foreach collection="list" index="index" item="item" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/select&gt; ​ 上述collection的值为list，对应的Mapper是这样的​ public List dynamicForeachTest(List ids);​ 测试代码： 12345678910111213@Test public void dynamicForeachTest() &#123; SqlSession session = Util.getSqlSessionFactory().openSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); List ids = new ArrayList(); ids.add(1); ids.add(3); ids.add(6); List blogs = blogMapper.dynamicForeachTest(ids); for (Blog blog : blogs) System.out.println(blog); session.close(); &#125; 单参数array数组的类型123456&lt;select id="dynamicForeach2Test" resultType="Blog"&gt; select * from t_blog where id in &lt;foreach collection="array" index="index" item="item" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; ​ 上述collection为array，对应的Mapper代码： ​ public List dynamicForeach2Test(int[] ids); ​ 对应的测试代码： 12345678910 @Test public void dynamicForeach2Test() &#123; SqlSession session = Util.getSqlSessionFactory().openSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); int[] ids = new int[] &#123;1,3,6,9&#125;; List blogs = blogMapper.dynamicForeach2Test(ids); for (Blog blog : blogs) System.out.println(blog); session.close();&#125; 自己把参数封装成Map的类型123456&lt;select id="dynamicForeach3Test" resultType="Blog"&gt; select * from t_blog where title like "%"#&#123;title&#125;"%" and id in &lt;foreach collection="ids" index="index" item="item" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; ​ 上述collection的值为ids，是传入的参数Map的key，对应的Mapper代码：​ public List dynamicForeach3Test(Map params);​ 对应测试代码： 12345678910111213141516171819@Test public void dynamicForeach3Test() &#123; SqlSession session = Util.getSqlSessionFactory().openSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); final List ids = new ArrayList(); ids.add(1); ids.add(2); ids.add(3); ids.add(6); ids.add(7); ids.add(9); Map params = new HashMap(); params.put("ids", ids); params.put("title", "中国"); List blogs = blogMapper.dynamicForeach3Test(params); for (Blog blog : blogs) System.out.println(blog); session.close(); &#125;]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 高级使用]]></title>
    <url>%2F2013%2F03%2F07%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay50_SpringMVC%E9%AB%98%E7%BA%A7%2F01.SpringMVC%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring 高级使用Spring MVC异常处理Spring MVC异常处理介绍 Spring MVC通过HandlerExceptionResolver处理程序的异常,包括处理映射,数据绑定及处理器执行时发生异常。HandlerExceptionResolver仅有一个接口方法: ModelAndView resolveException(HttpServletRequest reqeust,HttpServletResponse response,Object handler,Exception ex); 当发生异常时,Spring MVC将调用 resolveException()方法,并转到ModelAndView对应视图中,作为一个异常报告页面,反馈给用户! HandlerExceptionResolver拥有4个实现类: DefaultHandlerExceptionResolver SimpleMappingExceptionResolver AnnotationMethodHandlerExceptionResolver ResponseStatusExceptionResolver 异常处理方案DefaultHandlerExceptionResolver​ Spring MVC默认装配了DefaultHandlerExceptionResolver,它会将Spring MVC框架的异常转换为相应的相应状态码! 异常和相应状态码对应表 异常类型 响应状态码 ConversionNotSupportedException 500(Web服务器内部错误) HttpMediaTypeNotAcceptableException 406(无和请求accept匹配的MIME类型) HttpMediaTypeNotSupportedException 415(不支持MIME类型) HttpMessageNotReadableException 400 HttpMessageNotWritableException 500 HttpRequestMethodNotSupportedException 405 MissingServletRequestParameterException 400 在web.xml响应状态码配置一个对应页面 1234&lt;error-page&gt; &lt;error&gt;404&lt;/error&gt; &lt;location&gt;/404.html&lt;/location&gt;&lt;/error-page&gt; 注意: 静态资源注意会被DispatcherServlet拦截! AnnotationMethodHandlerExceptionResolver Spring MVC 默认注册了 AnnotationMethodHandlerExceptionResolver,它允许通过@ExceptionHandler注解指定处理特定异常的方法! 12345@ExceptionHandlerpublic String handleException(RuntimeException re, HttpServletRequest request)&#123; return "forward:/user/error";&#125; 通过@ExceptionHandler指定了当前类的一个错误处理方法!如果当前类中出现异常,会触发错误处理方法! 但是@ExceptionHandler的异常处理方法只能对同一处理类中的其他处理方法进行异常响应处理!! 全局异常处理123456789101112131415@ControllerAdvicepublic class MyExecptionHandler &#123; @ExceptionHandler(Exception.class) public ModelAndView handleException(Exception ex) &#123; System.out.println("全局异常:ex = " + ex); ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("error"); modelAndView.addObject("exception",ex); return modelAndView; &#125;&#125; 此处可以捕捉全局异常,但是不要忘了在spring配置的时候扫描该类! Spring MVC 拦截器的使用拦截器简介Spring Web MVC 的处理器拦截器，类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 常见应用场景 日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算 PV（Page View）等 权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面 性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间 通用行为：读取 Cookie 得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取 Locale、Theme 信息等，只要是多个处理器都需要的即可使用拦截器实现 第一个 Spring MVC 拦截器Spring MVC 拦截器需要实现 HandlerInterceptor 接口，该接口定义了 3 个方法，分别为 preHandle()、postHandle() 和 afterCompletion()，咱们就是通过重写这 3 个方法来对用户的请求进行拦截处理的。 preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)：该方法在请求处理之前进行调用。Spring MVC 中的 Interceptor 是链式调用的，在一个应用中或者说是在一个请求中可以同时存在多个 Interceptor 。每个 Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是 Interceptor 中的 preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求做一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值 Boolean 类型的，当它返回为 false 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 true 时，就会继续调用下一个 Interceptor 的 preHandle 方法，如果已经是最后一个 Interceptor 的时候，就会是调用当前请求的 Controller 中的方法。 postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)：通过 preHandle 方法的解释咱们知道这个方法包括后面要说到的 afterCompletion 方法都只能在当前所属的 Interceptor 的 preHandle 方法的返回值为 true 的时候，才能被调用。postHandle 方法在当前请求进行处理之后，也就是在 Controller 中的方法调用之后执行，但是它会在 DispatcherServlet 进行视图返回渲染之前被调用，所以咱们可以在这个方法中对 Controller 处理之后的 ModelAndView 对象进行操作。postHandle 方法被调用的方向跟 preHandle是相反的，也就是说，先声明的 Interceptor 的 postHandle 方法反而会后执行。 afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)：也是需要当前对应的 Interceptor 的 preHandle 方法的返回值为 true 时才会执行。因此，该方法将在整个请求结束之后，也就是在 DispatcherServlet 渲染了对应的视图之后执行，这个方法的主要作用是用于进行资源清理的工作。 创建登录拦截器我们知道对系统的相关操作是需要登录后才可以使用的，当未登录时是无法直接访问需要登录权限的操作的，为了做到这个效果，我们使用登录拦截器来判断用户是否登录，如果用户已登录则放行让用户继续操作，否则就将其跳转到登录页。 定义一个名为 LoginInterceptor 的拦截器，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.funtl.my.shop.web.interceptor;import com.funtl.my.shop.entity.User;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 登录拦截器 * &lt;p&gt;Title: LoginInterceptor&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * * @author Lusifer * @version 1.0.0 * @date 2018/6/12 5:44 */public class LoginInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; User user = (User) httpServletRequest.getSession().getAttribute("user"); // 判断用户是否登录 if (user == null) &#123; // 用户未登录，重定向到登录页 httpServletResponse.sendRedirect("/login"); return false; &#125; // 放行 return true; &#125; public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; // 如果请求来自登录页 if (modelAndView.getViewName().endsWith("login")) &#123; // 则直接重定向到首页不再显示登录页 httpServletResponse.sendRedirect("/main"); &#125; &#125; public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 在 spring-mvc.xml 中配置拦截器拦截器定义后还需要在 spring-mvc.xml 中配置拦截器，代码如下： 123456789&lt;!-- 拦截器配置，拦截顺序：先执行后定义的，排在第一位的最后执行。--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;mvc:exclude-mapping path="/static/**"/&gt; &lt;mvc:exclude-mapping path="/login"/&gt; &lt;bean class="com.funtl.my.shop.web.interceptor.LoginInterceptor"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 相关配置说明： 1mvc:interceptor ：定义一个拦截器 mvc:mapping：映射路径，需要拦截的请求路径 mvc:exclude-mapping：需要排除的请求路径，比如登录页本身是不需要拦截的，这里还包括了静态资源路径也是不需要拦截的 bean class：配置指定的拦截器对象 Spring MVC处理文件上传 Spring MVC为文件上传提供了直接支持,这种支持是通过即插即用的MultipartResolver实现. Spring使用Jakarta Commons FileUpload技术实现了一个MultipartResolver实现类:CommonsMultipartResolver。 在SpringMVC上下文中默认没有装配MultipartResolver,因此默认情况下不能处理文件上传工作。如果想使用Spring的文件上传功能,则需要先在上下文中配置MultipartResolver。 添加依赖12345678910111213&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 配置MultipartResolver配置 1234567&lt;!--multipartResolver配置--&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver" p:defaultEncoding="UTF-8" p:maxUploadSize="5242880" p:uploadTempDir="file:/d:/temp"/&gt; 编写控制器和文件上传表单 编写文件上传表单 upload.jsp 123456789101112131415&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;form method="post" enctype="multipart/form-data" action="/user/upload"&gt; &lt;label for="name"&gt;文件名称&lt;input type="text" id="name" name="name" /&gt;&lt;/label&gt; &lt;input type="file" name="file" /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 编写控制器代码 12345678910111213141516@RequestMapping("/toUpload")public String toUpload()&#123; //跳转到上传页面 return "user/upload";&#125;@RequestMapping("/upload")public String saveFile(@RequestParam("name") String name , @RequestParam("file")MultipartFile file) throws IOException &#123; //接收表单提交的数据,包含文件 System.out.println("name = " + name); if (!file.isEmpty()) &#123; file.transferTo(new File("G:/temp/"+file.getOriginalFilename())); &#125; return "success";&#125; ​ SpringMVC会将上传文件绑定到MultipartFile对象上. MultipartFile提供了获取长传文件内容,文件名等方法,通过transferTo()方法还可将文件存储到磁盘中,具体方法如下: 方法名称 方法解释 byte [] getBytes() 获取文件数据 String getContentType() 获取文件MIMETYPE类型,如image/jpeg,text/plain等 InputStream getInputStream() 获取文件输入流 String getName() 获取表单中文件组件的名称 name值! String getOriginalFilename() 获取文件上传的原名 long getSize() 获取文件的字节大小,单位为byte boolean isEmpty() 是否有长传的文件 void transferTo(File dest) 可以将上传的文件保存到指定的文件中]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 单表CRUD操作]]></title>
    <url>%2F2013%2F03%2F06%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay50_Mybatis%E5%9F%BA%E7%A1%80%2F04.Mybatis%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[MyBatis 单表 CRUD 操作概述本章主要内容是带领大家学习 MyBatis 的单表 CRUD 的相关操作方法 INSERT继续以 tb_user 表为例，修改映射文件，增加如下配置： 123456789101112131415161718192021&lt;insert id="insert"&gt; INSERT INTO tb_user ( id, username, password, phone, email, created, updated ) VALUES ( #&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;phone&#125;, #&#123;email&#125;, #&#123;created&#125;, #&#123;update&#125; )&lt;/insert&gt; 单元测试代码如下： 123456789101112@Testpublic void testInsert() &#123; TbUser tbUser = new TbUser(); tbUser.setEmail("admin@admin.com"); tbUser.setPassword("admin"); tbUser.setPhone("15888888888"); tbUser.setUsername("Lusifer"); tbUser.setCreated(new Date()); tbUser.setUpdate(new Date()); tbUserDao.insert(tbUser);&#125; DELETE继续以 tb_user 表为例，修改映射文件，增加如下配置： 123&lt;delete id="delete"&gt; DELETE FROM tb_user WHERE id = #&#123;id&#125;&lt;/delete&gt; 单元测试代码如下： 1234567@Testpublic void testDelete() &#123; TbUser tbUser = new TbUser(); tbUser.setId(37L); tbUserDao.delete(tbUser);&#125; 查询单个对象继续以 tb_user 表为例，修改映射文件，增加如下配置： 1234567891011121314&lt;select id="getById" resultType="TbUser"&gt; SELECT a.id, a.username, a.password, a.phone, a.email, a.created, a.updated AS "update" FROM tb_user AS a WHERE a.id = #&#123;id&#125;&lt;/select&gt; 单元测试代码如下： 12345@Testpublic void testGetById() &#123; TbUser tbUser = tbUserDao.getById(36L); System.out.println(tbUser.getUsername());&#125; UPDATE继续以 tb_user 表为例，修改映射文件，增加如下配置： 123456789101112&lt;update id="update"&gt; UPDATE tb_user SET username = #&#123;username&#125;, password = #&#123;password&#125;, phone = #&#123;phone&#125;, email = #&#123;email&#125;, created = #&#123;created&#125;, updated = #&#123;update&#125; WHERE id = #&#123;id&#125;&lt;/update&gt; 单元测试代码如下： 1234567@Testpublic void testUpdate() &#123; TbUser tbUser = tbUserDao.getById(36L); tbUser.setUsername("Lusifer"); tbUserDao.update(tbUser);&#125; 使用模糊查询继续以 tb_user 表为例，修改映射文件，增加如下配置： 1234567891011121314&lt;select id="selectByName" resultType="TbUser"&gt; SELECT a.id, a.username, a.password, a.phone, a.email, a.created, a.updated AS "update" FROM tb_user AS a WHERE a.username LIKE CONCAT ('%', #&#123;username&#125;, '%')&lt;/select&gt; 在进行模糊查询时，需要进行字符串的拼接。SQL 中的字符串的拼接使用的是函数 concat(arg1, arg2, …) 。注意不能使用 Java 中的字符串连接符 +。 单元测试代码如下： 1234567@Testpublic void testSelectByName() &#123; List&lt;TbUser&gt; tbUsers = tbUserDao.selectByName("uni"); for (TbUser tbUser : tbUsers) &#123; System.out.println(tbUser.getUsername()); &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring对象关系映射]]></title>
    <url>%2F2013%2F03%2F05%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay50_Mybatis%E5%9F%BA%E7%A1%80%2F03.Spring%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[第一个 MyBatis 对象关系映射POM编写完相关代码后，我们可以使用单元测试查看 MyBatis 的执行效果，需要增加单元测试相关依赖，配置如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 导入 SQL群共享中已经为大家准备好了练习用的 SQL，位置： tools/myshop.zip 定义实体类以 tb_user 表为例，实体类代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.funtl.my.shop.domain;import java.io.Serializable;import java.util.Date;public class TbUser implements Serializable &#123; private Long id; private String username; private String password; private String phone; private String email; private Date created; private Date update; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getCreated() &#123; return created; &#125; public void setCreated(Date created) &#123; this.created = created; &#125; public Date getUpdate() &#123; return update; &#125; public void setUpdate(Date update) &#123; this.update = update; &#125;&#125; 定义数据访问接口注意：Spring 集成 MyBatis 后，不需要手动实现 DAO 层的接口，所有的 SQL 执行语句都写在对应的关系映射配置文件中。 12345678910111213141516package com.funtl.my.shop.web.admin.dao;import com.funtl.my.shop.domain.TbUser;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface TbUserDao &#123; /** * 查询全部用户信息 * @return */ public List&lt;TbUser&gt; selectAll();&#125; 定义业务逻辑接口1234567891011121314package com.funtl.my.shop.web.admin.service;import com.funtl.my.shop.domain.TbUser;import java.util.List;public interface TbUserService &#123; /** * 查询全部用户信息 * @return */ public List&lt;TbUser&gt; selectAll();&#125; 实现业务逻辑接口123456789101112131415161718192021package com.funtl.my.shop.web.admin.service.impl;import com.funtl.my.shop.domain.TbUser;import com.funtl.my.shop.web.admin.dao.TbUserDao;import com.funtl.my.shop.web.admin.service.TbUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class TbUserServiceImpl implements TbUserService &#123; @Autowired private TbUserDao tbUserDao; @Override public List&lt;TbUser&gt; selectAll() &#123; return tbUserDao.selectAll(); &#125;&#125; 定义映射文件映射文件，简称为 Mapper，主要完成 DAO 层中 SQL 语句的映射。映射文件名随意，一般放在 src/resources/mapper 文件夹中。这里映射文件名称定为 TbUserMapper.xml。 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.funtl.my.shop.web.admin.dao.TbUserDao"&gt; &lt;select id="selectAll" resultType="TbUser"&gt; SELECT a.id, a.username, a.password, a.phone, a.email, a.created, a.updated FROM tb_user AS a &lt;/select&gt;&lt;/mapper&gt; 创建单元测试所有工作准备就绪，我们就可以测试 MyBatis 是否能够正常执行了。创建一个单元测试类，代码如下： 123456789101112131415161718192021222324252627package com.funtl.my.shop.web.admin.service.test;import com.funtl.my.shop.domain.TbUser;import com.funtl.my.shop.web.admin.dao.TbUserDao;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;"classpath:spring-context.xml", "classpath:spring-context-druid.xml", "classpath:spring-context-mybatis.xml"&#125;)public class TbUserServiceTest &#123; @Autowired private TbUserDao tbUserDao; @Test public void testSelectAll() &#123; List&lt;TbUser&gt; tbUsers = tbUserDao.selectAll(); for (TbUser tbUser : tbUsers) &#123; System.out.println(tbUser.getUsername()); &#125; &#125;&#125; 成功执行测试后，控制台输出如下： 1234567891011121314151617181920212223242018-06-13 08:00:40,069 INFO [org.springframework.test.context.support.DefaultTestContextBootstrapper] - Loaded default TestExecutionListener class names from location [META-INF/spring.factories]: [org.springframework.test.context.web.ServletTestExecutionListener, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener, org.springframework.test.context.support.DependencyInjectionTestExecutionListener, org.springframework.test.context.support.DirtiesContextTestExecutionListener, org.springframework.test.context.transaction.TransactionalTestExecutionListener, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener]2018-06-13 08:00:40,106 INFO [org.springframework.test.context.support.DefaultTestContextBootstrapper] - Using TestExecutionListeners: [org.springframework.test.context.web.ServletTestExecutionListener@4b9e13df, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener@2b98378d, org.springframework.test.context.support.DependencyInjectionTestExecutionListener@475530b9, org.springframework.test.context.support.DirtiesContextTestExecutionListener@1d057a39, org.springframework.test.context.transaction.TransactionalTestExecutionListener@26be92ad, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener@4c70fda8]2018-06-13 08:00:40,213 INFO [org.springframework.beans.factory.xml.XmlBeanDefinitionReader] - Loading XML bean definitions from class path resource [spring-context.xml]2018-06-13 08:00:40,513 INFO [org.springframework.beans.factory.xml.XmlBeanDefinitionReader] - Loading XML bean definitions from class path resource [spring-context-druid.xml]2018-06-13 08:00:40,565 INFO [org.springframework.beans.factory.xml.XmlBeanDefinitionReader] - Loading XML bean definitions from class path resource [spring-context-mybatis.xml]2018-06-13 08:00:40,586 INFO [org.springframework.context.support.GenericApplicationContext] - Refreshing org.springframework.context.support.GenericApplicationContext@55d56113: startup date [Wed Jun 13 08:00:40 CST 2018]; root of context hierarchy2018-06-13 08:00:41,650 INFO [com.alibaba.druid.pool.DruidDataSource] - &#123;dataSource-1&#125; initedzhangsanzhangsan1zhangsan2zhangsan3zhangsan5lisilisi1jd_gogogotidytidy1niuniuniuniu2niuniu3niuniu4test01test022018-06-13 08:00:42,143 INFO [org.springframework.context.support.GenericApplicationContext] - Closing org.springframework.context.support.GenericApplicationContext@55d56113: startup date [Wed Jun 13 08:00:40 CST 2018]; root of context hierarchy2018-06-13 08:00:42,149 INFO [com.alibaba.druid.pool.DruidDataSource] - &#123;dataSource-1&#125; closed]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 整合 MyBatis]]></title>
    <url>%2F2013%2F03%2F04%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay50_Mybatis%E5%9F%BA%E7%A1%80%2F02.Spring%E6%95%B4%E5%90%88MyBatis%2F</url>
    <content type="text"><![CDATA[Spring 整合MyBatisSpring 整合 DruidPOM在 pom.xml 文件中新增 com.alibaba:druid 和 mysql:mysql-connector-java 依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt; 配置数据库连接配置数据库连接 jdbc.properties ，配置代码如下： 1234567891011121314# JDBC# MySQL 8.x: com.mysql.cj.jdbc.Driverjdbc.driverClass=com.mysql.jdbc.Driverjdbc.connectionURL=jdbc:mysql://192.168.75.134:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsejdbc.username=rootjdbc.password=123456# JDBC Pooljdbc.pool.init=1jdbc.pool.minIdle=3jdbc.pool.maxActive=20# JDBC Testjdbc.testSql=SELECT &apos;x&apos; FROM DUAL Spring 集成 Druid创建一个名为 spring-context-druid.xml 的 Spring 配置文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 加载配置属性文件 --&gt; &lt;context:property-placeholder ignore-unresolvable="true" location="classpath:jdbc.properties"/&gt; &lt;!-- 数据源配置, 使用 Druid 数据库连接池 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClass&#125;"/&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name="url" value="$&#123;jdbc.connectionURL&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="$&#123;jdbc.pool.init&#125;"/&gt; &lt;property name="minIdle" value="$&#123;jdbc.pool.minIdle&#125;"/&gt; &lt;property name="maxActive" value="$&#123;jdbc.pool.maxActive&#125;"/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="60000"/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000"/&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000"/&gt; &lt;property name="validationQuery" value="$&#123;jdbc.testSql&#125;"/&gt; &lt;property name="testWhileIdle" value="true"/&gt; &lt;property name="testOnBorrow" value="false"/&gt; &lt;property name="testOnReturn" value="false"/&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="stat"/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置 Druid 监控中心Druid 提供了大量的监控数据，只需要在 web.xml 中配置一个 Servlet 就可以方便的查看这些信息。 修改 web.xml 配置文件，增加 Druid 提供的 Servlet 12345678&lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 打开浏览器，输入：http://localhost:8080/druid/index.html 浏览器显示效果如下： Spring 整合 MyBatisPOM在 pom.xml 文件中增加 MyBatis 相关依赖： 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;&lt;/dependency&gt; 主要增加了 3 个依赖，分别为 org.mybatis:mybatis、org.mybatis:mybatis-spring、org.springframework:spring-jdbc 创建 MyBatis 配置文件创建一个名为 mybatis-config.xml 的配置文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 全局参数 --&gt; &lt;settings&gt; &lt;!-- 打印 SQL 语句 --&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt; &lt;setting name="cacheEnabled" value="false"/&gt; &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt; &lt;setting name="aggressiveLazyLoading" value="true"/&gt; &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false --&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部 --&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;!-- 使用驼峰命名法转换字段。 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt; &lt;setting name="jdbcTypeForNull" value="NULL"/&gt; &lt;/settings&gt;&lt;/configuration&gt; Spring 集成 MyBatis创建一个名为 spring-context-mybatis.xml 的 Spring 配置文件，内容如下： 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 配置 SqlSession --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 用于配置对应实体类所在的包，多个 package 之间可以用 ',' 号分割 --&gt; &lt;property name="typeAliasesPackage" value="com.funtl.my.shop.domain"/&gt; &lt;!-- 用于配置对象关系映射配置文件所在目录 --&gt; &lt;property name="mapperLocations" value="classpath:/mapper/**/*.xml"/&gt; &lt;property name="configLocation" value="classpath:/mybatis-config.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 扫描 Mapper --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.funtl.my.shop.web.admin.dao" /&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 简介]]></title>
    <url>%2F2013%2F03%2F03%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay50_Mybatis%E5%9F%BA%E7%A1%80%2F01.Mybatis%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[MyBatis 简介概述MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注 SQL 语句本身，而不用再花费精力去处理诸如注册驱动、创建 Connection、配置 Statement 等繁杂过程。 Mybatis 通过 xml 或注解的方式将要执行的各种 Statement（Statement、PreparedStatement 等）配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 MyBatis 框架执行 SQL 并将结果映射成 Java 对象并返回。 MyBatis 与 HibernateHibernate 框架是提供了全面的数据库封装机制的 “全自动” ORM，即实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。 相对于此，MyBatis 只能算作是 “半自动” ORM。其着力点，是在 POJO 类与 SQL 语句之间的映射关系。也就是说，MyBatis 并不会为程序员自动生成 SQL 语句。具体的 SQL 需要程序员自己编写，然后通过 SQL 语句映射文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO。因此，MyBatis 成为了“全自动”ORM 的一种有益补充。 MyBatis 的特点 在 XML 文件中配置 SQL 语句，实现了 SQL 语句与代码的分离，给程序的维护带来了很大便利。 因为需要程序员自己去编写 SQL 语句，程序员可以结合数据库自身的特点灵活控制 SQL 语句，因此能够实现比 Hibernate 等全自动 ORM 框架更高的查询效率，能够完成复杂查询。 简单，易于学习，易于使用，上手快。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 基本使用]]></title>
    <url>%2F2013%2F03%2F02%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay49_SpringMVC%2F03.SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SpringMVC基本使用常用注解@RequestParam表单参数处理获取表单参数 创建一个登陆表单 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--action指定controller中对应的方法路径即可!--&gt; &lt;form action="/xx/login" method="POST"&gt; &lt;label for="username"&gt;用户名:&lt;input type="text" id="username" name="username" /&gt;&lt;/label&gt; &lt;label for="password"&gt;密码:&lt;input type="text" id="password" name="password" /&gt;&lt;/label&gt; &lt;input type="submit" value="登陆"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 获取参数的控制器 1234567891011121314151617@RequestMapping("/xx")@Controllerpublic class HelloWorld &#123; @RequestMapping(value = "/helloworld",method = RequestMethod.GET) public String hellworld()&#123; System.out.println("helloworld"); return "helloworld"; &#125; //接收form表单 @RequestMapping(value = "/login",method = RequestMethod.POST) public String login(String username,String password)&#123; System.out.println("username = " + username); System.out.println("password = " + password); return "helloworld"; &#125; &#125; 获取参数,只需要在对应的方法中添加参数即可,如果参数名与请求传参的name值相同即可直接赋值,注意:对应类型很重要,如果是普通的输入框,使用字符串即可,如果是多选框,可以使用List类型的参数接值! 如果参数名和name值相同,无需使用@RequestParam注解! 注意: 将基本类型转化成包装类型!! 方法的参数名与传参的name值不同 指name的值和方法参数名相同,开发中,也会碰到请求参数name的值与方法的参数名不同,我们还需要将指定的name对应参数传给方法的指定参数,这时,就不需要使用@RequestParam注解! 12345678910//此案例,我们修改了input标签的name值,使得与login方法不同,所以我们需要使用@RequestParam(value = //"name") String username将其指定到 username参数上!&lt;label for="username"&gt;用户名:&lt;input type="text" id="username" name="name" /&gt;&lt;/label&gt; //name改为 name @RequestMapping(value = "/login",method = RequestMethod.POST) public String login(@RequestParam(value = "name") String username, String password)&#123; System.out.println("username = " + username); System.out.println("password = " + password); return "helloworld"; &#125; 方法参数设置默认值 经过前面学习,不管name值和方法参数是否相同,我们都能讲想要的请求参数赋给对应的方法参数上。 但是，有一种特殊情况，如果客户端没有在请求传参，那么我们将得到null,我们不希望得到null,希望得到一个默认值,这个时候,我们还需要使用@RequestParam的defaultValue属性进行对应的设置。 1234567@RequestMapping("/list")public String list(@RequestParam(defaultValue = "1") Integer currentPage , @RequestParam(defaultValue = "10") Integer pageSize)&#123; //设置默认值,如果不传递使用参数的默认值 System.out.println("currentPage = " + currentPage); System.out.println("pageSize = " + pageSize); return "list"; &#125; @PathVariable获取路径参数我们可以通过此注解,获取路径部分的数据! 例如: http://localhost:8080/user/list/1 获取路径/list/后面1的数据! 12345@RequestMapping("/user/list/&#123;id&#125;")public String getData(@PathVariable(value = "id") Integer id)&#123; System.out.println("id = " + id); return "list" ;&#125; 代码解释: 将路径中想要获取部分使用 {标注名}标注,在方法对应赋值的参数添加@PathVariable注解即可!value值为标注名!!! @CookieValue@CookieValue注解可以获取请求中的cookie!! @RequestMapping(“/cookie”) 12345public String testCookie(@CookieValue(&quot;JSESSIONID&quot;)String cookie)&#123; System.out.println(&quot;cookie:&quot;+cookie); return &quot;result&quot;;&#125; @RequestHeader@RequestHeader注解可以获取请求头中的数据!! @RequestMapping(“/header”) 1234567public String testHeader(@CookieValue(&quot;JSESSIONID&quot;)String cookie, @RequestHeader(&quot;User-Agent&quot;)String header)&#123; System.out.println(&quot;cookie:&quot;+cookie); System.out.println(&quot;header:&quot;+header); return &quot;result&quot;;&#125; 返回页面结果ModelAndView 处理方法返回对象ModelAndView 1234567891011@RequestMapping(value = &#123;"checkLogin"&#125;, method = RequestMethod.POST)public ModelAndView checkLogin(String username, String password) &#123; boolean status = false; if ("jerry".equals(username)) &#123; status = true; &#125; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("result"); modelAndView.addObject("status", status); return modelAndView;&#125; jsp页面获取数据 通过EL表达式获取 123456789101112131415161718&lt;%-- Created by IntelliJ IDEA. User: jie Date: 2019/7/11 Time: 3:20 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ page isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录结果&lt;/h1&gt;是否登录成功：$&#123;status&#125;&lt;/body&gt;&lt;/html&gt; 其他重要操作转发和重定向 转发: forward 重定向:redirect 转发语法: 12345678910111213141516@RequestMapping("/user")@Controllerpublic class UserContoller &#123; @RequestMapping("/index") public String index(Integer size)&#123; System.out.println("index method 被调用!"+size); return "forward:/user/result"; &#125; @RequestMapping("/result") public String result()&#123; return "result"; &#125; &#125; 重定向语法: 12345678910111213141516@RequestMapping("/user")@Controllerpublic class UserContoller &#123; @RequestMapping("/index") public String index(Integer size)&#123; System.out.println("index method 被调用!"+size); return "redirect:/user/result"; &#125; @RequestMapping("/result") public String result()&#123; return "result"; &#125;&#125; 解决参数乱码问题 Spring MVC中 GET方式不会乱码! 在web.xml配置文件中添加spring自带的Filter设置编码格式 1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 实战练习-向controller传递对象类型数据 通过form表单向指定的controller的方法传递对象! 创建Pojo对象Address.java 12345678package com.itqf.springmvc.pojo;public class Address &#123; private String province; private String city; //toString,getter,setter&#125; User.java 12345678public class User &#123; private String username; private String password; private Integer age; private Address address; //toString,getter,setter&#125; 创建控制器类123456789101112131415@RequestMapping("/user")@Controllerpublic class UserContoller &#123; //跳转到 WEB-INF/user/form.jsp @RequestMapping("/form") public String from()&#123; return "user/form"; &#125; //form表单提交数据到此处!获取在转发到success.jsp @RequestMapping("/add") public String add(User user)&#123; System.out.println(user); return "success"; &#125;&#125; 创建form.jsp文件位置: /WEB-INF/user/form.jsp 12345678&lt;form action="/spring-mvc-22/user/add" method="post"&gt; &lt;label for="username"&gt;用户名:&lt;input type="text" id="username" name="username" /&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for="password"&gt;密码:&lt;input type="password" id="password" name="password" /&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for="age"&gt;年龄:&lt;input type="text" name="age" /&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for="address.province"&gt;省份:&lt;input type="text" name="address.province" /&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for="address.city"&gt;城市:&lt;input type="text" name="address.city" /&gt;&lt;/label&gt;&lt;br/&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt; 注意:name的特殊写法,这里可以直接将表单数据转成User对象,但是User对象内部包含 Address的对象,所以,这里可以调用第一层属性,再点一层属性,如果多层依次类推! 创建success.jsp 文件位置: /WEB-INF/success.jsp 测试​ 访问跳转路径即可!!! Pojo类汇总包含Date字段处理​ 实体类中,包含Date类型,需要使用特殊的注解进行转化! 1234567public class User &#123; private String name; private String age; @DateTimeFormat(pattern = "yyyy-MM-dd") private Date birthday;' //getter setter toString &#125; restful @RequestBody]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 项目]]></title>
    <url>%2F2013%2F03%2F01%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay49_SpringMVC%2F02.SpringMVC%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[SpringMVC项目创建webapp项目创建项目名为testSpringMVC项目 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置web.xml 配置核心 DispatcherServlet 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:/spring-mvc*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置spring-mvc.xml创建一个名为 spring-mvc.xml 文件来配置 MVC 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;description&gt;Spring MVC Configuration&lt;/description&gt; &lt;!-- 加载配置属性文件 --&gt; &lt;context:property-placeholder ignore-unresolvable="true" location="classpath:myshop.properties"/&gt; &lt;!-- 使用 Annotation 自动注册 Bean,只扫描 @Controller --&gt; &lt;context:component-scan base-package="com.lusifer.myshop" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!-- 默认的注解映射的支持 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 定义视图文件解析 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="$&#123;web.view.prefix&#125;"/&gt; &lt;property name="suffix" value="$&#123;web.view.suffix&#125;"/&gt; &lt;/bean&gt; &lt;!-- 静态资源映射 --&gt; &lt;mvc:resources mapping="/static/**" location="/static/" cache-period="31536000"/&gt;&lt;/beans&gt; 相关配置说明： context:property-placeholder：动态加载属性配置文件以变量的方式引用需要的值 context:component-scan：当前配置文件为 MVC 相关，故只需要扫描包含 @Controller 的注解即可，由于 spring-context.xml 配置文件中也配置了包扫描，所以还需要排除 @Controller 的注解扫描。 InternalResourceViewResolver：视图文件解析器的一种，用于配置视图资源的路径和需要解释的视图资源文件类型，这里有两个需要配置的属性 prefix（前缀）以及 suffix（后缀）。 prefix：配置视图资源路径，如：/WEB-INF/views/ suffix：配置视图资源类型，如：.jsp mvc:resources：静态资源映射，主要用于配置静态资源文件存放路径，如：JS、CSS、Image 等 添加Controller创建UserController业务请求处理类 1234567891011121314151617181920212223package com.qf.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;/** * Created by jie on 2019/7/11. */@Controller@RequestMapping("/user/")public class UserController &#123; /** * 登录页面 * * @return */ @RequestMapping(value = &#123;"login"&#125;, method = RequestMethod.GET) public String toLoginPage() &#123; return "login"; &#125;&#125; 注解说明@Controller在 Spring MVC 中，控制器 Controller 负责处理由 DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个 Model ，然后再把该 Model 返回给对应的 View 进行展示。在 Spring MVC 中提供了一个非常简便的定义 Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用 @Controller 标记一个类是 Controller ，然后使用 @RequestMapping 和 @RequestParam 等一些注解用以定义 URL 请求和 Controller 方法之间的映射，这样的 Controller 就能被外界访问到。此外 Controller 不会直接依赖于 HttpServletRequest 和 HttpServletResponse 等 HttpServlet 对象，它们可以通过 Controller 的方法参数灵活的获取到。 @Controller 用于标记在一个类上，使用它标记的类就是一个 Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了 @RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用 @RequestMapping 注解的方法才是真正处理请求的处理器。 @RequestMappingRequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 RequestMapping 注解有六个属性： value， method value：指定请求的实际地址，指定的地址可以是 URI Template 模式 method：指定请求的method类型， GET、POST、PUT、DELETE 等 consumes，produces consumes：指定处理请求的提交内容类型（Content-Type），例如 application/json, text/html produces: 指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回 params，headers params：指定 request 中必须包含某些参数值是，才让该方法处理 headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求 添加日志log4j添加依赖12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 添加配置文件添加配置文件log4j.properties 1234567###log4j.rootLogger=debug,stdout### to stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 简介]]></title>
    <url>%2F2013%2F02%2F28%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay49_SpringMVC%2F01.SpringMVC%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Spring MVC简介概述Spring MVC 也叫 Spring Web MVC ，属于展示层框架。SpringMVC 是 Spring 框架的一部分。 Spring Web MVC 框架提供了 MVC (模型 - 视图 - 控制器) 架构和用于开发灵活和松散耦合的 Web 应用程序的组件。 MVC 模式导致应用程序的不同方面(输入逻辑，业务逻辑和 UI 逻辑)分离，同时提供这些元素之间的松散耦合。 模型 (Model)：封装了应用程序数据，通常它们将由 POJO 类组成。 视图 (View)：负责渲染模型数据，一般来说它生成客户端浏览器可以解释 HTML 输出。 控制器 (Controller)：负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。 DispatcherServlet 组件类Spring Web MVC 框架是围绕 DispatcherServlet 设计的，它处理所有的 HTTP 请求和响应。 Spring Web MVC DispatcherServlet 的请求处理工作流如下图所示： 以下是对应于到 DispatcherServlet 的传入 HTTP 请求的事件顺序： 在接收到 HTTP 请求后，DispatcherServlet 会查询 HandlerMapping 以调用相应的 Controller。 Controller 接受请求并根据使用的 GET 或 POST 方法调用相应的服务方法。 服务方法将基于定义的业务逻辑设置模型数据，并将视图名称返回给 DispatcherServlet。 DispatcherServlet 将从 ViewResolver 获取请求的定义视图。 当视图完成，DispatcherServlet 将模型数据传递到最终的视图，并在浏览器上呈现。 所有上述组件，即: HandlerMapping，Controller 和 ViewResolver 是 WebApplicationContext 的一部分，它是普通 ApplicationContext 的扩展，带有 Web 应用程序所需的一些额外功能。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 中AOP开发]]></title>
    <url>%2F2013%2F02%2F27%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay48_SpringAOP%2F03.Spring%20%E4%B8%ADAOP%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Spring 中AOP开发配置文件开发添加依赖先在pom.xml文件中添加aop所需要依赖 123456789101112131415161718192021222324252627&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 添加spring配置文件新建pring-aop.xml配置文件到resource目录下 添加业务接口和实现类在指定包名com.qf.spring.aop.service.impl下创建业务实现类和接口 业务处理接口UserService 123456package com.qf.spring.aop.service;public interface UserService &#123; void login(); void logout();&#125; 业务处理类UserServiceImpl 123456789101112131415package com.qf.spring.aop.service.impl;import com.qf.spring.aop.service.UserService;public class UserServiceImpl implements UserService &#123; @Override public void login() &#123; System.out.println("login"); &#125; @Override public void logout() &#123; System.out.println("logout"); &#125;&#125; 添加增强实现类在指定包名下新增MyAdivce，用作方法增强实现类 123456789101112131415161718192021222324252627282930313233343536373839package com.qf.spring.aop;import org.aspectj.lang.ProceedingJoinPoint;public class MyAdivce &#123; /** //前置通知：目标方法运行之前调用 //后置通知(如果出现异常不会调用)：在目标方法运行之后调用 //环绕通知：在目标方法之前和之后都调用 //异常拦截通知：如果出现异常，就会调用 //后置通知(无论是否出现 异常都会调用)：在目标方法运行之后调用 */ //前置通知 public void before()&#123; System.out.println("这是前置通知"); &#125; //后置通知 public void afterReturning()&#123; System.out.println("这是后置通知(方法不出现异常)"); &#125; public Object around(ProceedingJoinPoint point) throws Throwable &#123; System.out.println("这是环绕通知之前部分!!"); Object object = point.proceed(); //调用目标方法 System.out.println("这是环绕通知之后的部分!!"); return object; &#125; public void afterException()&#123; System.out.println("异常通知!"); &#125; public void after()&#123; System.out.println("这也是后置通知,就算方法发生异常也会调用!"); &#125;&#125; 配置spring-aop.xml在spring-aop.xml文件中添加bean声明，添加切面，切点关系 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd "&gt; &lt;bean name="userService" class="com.qf.spring.aop.service.impl.UserServiceImpl" /&gt; &lt;!--配置通知对象--&gt; &lt;bean name="myAdvice" class="com.qf.spring.aop.MyAdivce" /&gt; &lt;!-- 配置将增强织入目标对象--&gt; &lt;aop:config&gt; &lt;!-- com.qf.spring.aop.service.impl.UserServiceImpl 1 2 3 4 1: 修饰符 public/private/* 可忽略 2: 返回值 String/../* 3: 全限定类名 类名 ..代表不限层数 *ServiceImpl 4: (..) --&gt; &lt;aop:pointcut id="pc" expression="execution(* com.qf.spring.aop.service.impl.*ServiceImpl.* (..))"/&gt; &lt;aop:aspect ref="myAdvice"&gt; &lt;aop:before method="before" pointcut-ref="pc" /&gt; &lt;aop:after-returning method="afterReturning" pointcut-ref="pc" /&gt; &lt;aop:around method="around" pointcut-ref="pc" /&gt; &lt;aop:after-throwing method="afterException" pointcut-ref="pc" /&gt; &lt;aop:after method="after" pointcut-ref="pc" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 编写测试类在src\test\java\com\qf\spring\aop目录下新增测试类AppTest 123456789101112131415161718192021package com.qf.spring.aop;import com.qf.spring.aop.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;"classpath:spring-aop.xml"&#125;)public class AppTest &#123; @Autowired private UserService userService; @Test public void test() &#123; userService.login(); &#125;&#125; 输出123456这是前置通知这是环绕通知之前部分!!login这也是后置通知,就算方法发生异常也会调用!这是环绕通知之后的部分!!这是后置通知(方法不出现异常) 注解方式开发基于上面项目进行修改，修改为注解的方式进行开发 修改spring-aop.xml文件修改原来spring-aop.xml内容，将aop相关内容删除，并且添加&lt;aop:aspectj-autoproxy/&gt;元素 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"&gt; &lt;bean name="userService" class="com.qf.spring.aop.service.impl.UserServiceImpl"/&gt; &lt;!--配置通知对象--&gt; &lt;bean name="myAdvice" class="com.qf.spring.aop.MyAdivce"/&gt; &lt;!-- 配置将增强织入目标对象 使用注解的方式--&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 修改MyAdivce类内容在类上添加注解@Aspect,在方法上分别添加注解 @Pointcut(&quot;execution(* com.qf.spring.aop.service.impl.*ServiceImpl.*(..))&quot;) @Before(&quot;MyAdivce.pointcut()&quot;) @AfterReturning(&quot;MyAdivce.pointcut()&quot;) @Around((&quot;MyAdivce.pointcut()&quot;)) @AfterTransaction @After(&quot;MyAdivce.pointcut()&quot;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.qf.spring.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.test.context.transaction.AfterTransaction;@Aspectpublic class MyAdivce &#123; /** * //前置通知：目标方法运行之前调用 * //后置通知(如果出现异常不会调用)：在目标方法运行之后调用 * //环绕通知：在目标方法之前和之后都调用 * //异常拦截通知：如果出现异常，就会调用 * //后置通知(无论是否出现 异常都会调用)：在目标方法运行之后调用 */ @Pointcut("execution(* com.qf.spring.aop.service.impl.*ServiceImpl.*(..))") public void pointcut() &#123; &#125; //前置通知 @Before("MyAdivce.pointcut()") public void before() &#123; System.out.println("这是前置通知"); &#125; //后置通知 @AfterReturning("MyAdivce.pointcut()") public void afterReturning() &#123; System.out.println("这是后置通知(方法不出现异常)"); &#125; @Around(("MyAdivce.pointcut()")) public Object around(ProceedingJoinPoint point) throws Throwable &#123; System.out.println("这是环绕通知之前部分!!"); Object object = point.proceed(); //调用目标方法 System.out.println("这是环绕通知之后的部分!!"); return object; &#125; @AfterTransaction public void afterException() &#123; System.out.println("异常通知!"); &#125; @After("MyAdivce.pointcut()") public void after() &#123; System.out.println("这也是后置通知,就算方法发生异常也会调用!"); &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP基础代理机制]]></title>
    <url>%2F2013%2F02%2F26%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay48_SpringAOP%2F02.AOP%20%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[AOP基础代理机制Spring的 AOP底层用到两种代理机制: JDK 的动态代理：针对实现了接口的类产生代理。 CGlib 的动态代理：针对没有实现接口的类产生代理，应用的是底层的字节码增强的技术 生成当前类的子类对象 JDK动态代理实现 创建接口和对应实现类 1234567public interface UserService &#123; void login(); void loginOut(); &#125; 12345678910111213//实现类public class UserServiceImpl implements UserService &#123; public void login() &#123; System.out.println("login方法触发"); &#125; public void loginOut() &#123; System.out.println("loginOut方法触发"); &#125;&#125; 创建动态代理类 1234567891011121314151617181920public class PerformHandler implements InvocationHandler &#123; private Object target; //目标对象 public PerformHandler(Object target)&#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //本方法中的其他输出输入增强 System.out.println("方法触发了"); //执行被代理类 原方法 Object invoke = method.invoke(target, args); System.out.println("执行完毕了"); return invoke; &#125;&#125; 测试 1234567891011121314@Testpublic void test1()&#123; //测试JDK动态代理技术 UserService userService = new UserServiceImpl(); PerformHandler performHandler = new PerformHandler(userService); userService = (UserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), performHandler ); userService.login(); &#125; 测试结果: 在调用接口方法的前后都会添加代理类的方法! CGlib实现代理 使用JDK创建代理有一个限制,它只能为接口创建代理实例.这一点可以从Proxy的接口方法 newProxyInstance(ClassLoader loader,Class [] interfaces,InvocarionHandler h)中看的很清楚 ​ 第二个入参 interfaces就是需要代理实例实现的接口列表. ​ 对于没有通过接口定义业务方法的类,如何动态创建代理实例呢? JDK动态代理技术显然已经黔驴技穷,CGLib作为一个替代者,填补了这一空缺. ​ GCLib采用底层的字节码技术,可以为一个类创建子类,在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势志入横切逻辑. 创建创建CGLib代理器 123456789101112131415161718192021222324252627public class CglibProxy implements MethodInterceptor&#123; private Enhancer enhancer = new Enhancer(); //设置被代理对象 public Object getProxy(Class clazz)&#123; enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); &#125; public Object intercept(Object obj, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("CGLig代理之前之前"); Object invoke = methodProxy.invokeSuper(obj,objects); System.out.println("CGLig代理之前之后"); return invoke; &#125;&#125; 测试 1234567@Testpublic void test2()&#123; //TODO CGlib实现 CglibProxy cglibProxy = new CglibProxy(); UserServiceImpl userService= (UserServiceImpl) cglibProxy.getProxy(UserServiceImpl.class); userService.login();&#125;]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP 介绍]]></title>
    <url>%2F2013%2F02%2F25%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay48_SpringAOP%2F01.AOP%20%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[AOP介绍概述​ AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 ​ AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 ​ 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 代码优化过程理解AOP 基于OOP实现对公共代码抽离 基于AOP实现对公共代码抽离 AOP核心概念 连接点(Joinpoint): 特定点是程序执行的某一个特定位置,如类开始初始化前,类初始化后,类某一个方法调用前/调用后,方法抛出异常后,一个类或一段程序代码拥有一些具有边界性质的特定点,这写代码中的特定点就称为”连接点”,Spring仅支持方法连接点,即仅能在方法调用前,方法调用后,方法抛出异常时,以及方法调用前后这些程序执行点织入增强. 切点(Pointcut) 每个程序类都拥有多个连接点,如一个拥有两个方法的类,这两个方法都是连接点,即连接点是程序类中客观存在的事物,但在众多连接点中,如何定位某些感兴趣的连接点呢?AOP通过”切点”定位特定的连接点. 增强(Advice) 增强是织入目标类连接点上的一段程序代码,在Spring中,增强不仅可以描述程序代码,还拥有另一个和连接点相关的信息,这便是执行点的方位,结合执行点的方位信息和切点信息,就可以找到特定的连接,正因为增强既包含了用于添加到目标连接点上的一段执行逻辑,又包含用于定位连接点的方位信息,所以Spring所提供的增强接口都是带方位名的.如BeforeAdvice,AfterReturningAdvice,ThrowsAdvice等.BeforeAdvice表示方法调用前的位置.而AfterReturningAdivce表示访问返回后的位置,所以只有结合切点和增强,才能确定特定的连接点并实施增强逻辑. 目标对象(Target) 增强逻辑的织入目标类.如果没有AOP,那么目标业务类需要自己实现所有逻辑,如果使用AOP可以把一些非逻辑性代码通过AOP织入到主程序代码上. 引介(Introduction) 引介是一种特殊的增强,它为类添加一些属性和方法.这样,即使一个业务类原本没有实现某一个接口,通过AOP的引介功能,也可以动态地为该业务类添加接口的实现逻辑.让业务类成为这个接口的实现类. 织入(Weaving) 织入是将增强添加到目标类具体链接点上的过程,AOP就像一台织布机,将目标类,增强,或者引介天衣无缝的编织到一起,我们不能不说”织入”这个词太精辟了,根据不同的实现技术,AOP有3种织入方式: 编译期织入,这要求使用特殊的Java编译器. 类装载期织入,这要求使用特殊的类装载器. 动态代理织入,在运行期为目标类添加增强生成子类的方式. Spring采用动态代理织入,而AspectJ采用编译期织入和类装载器织入. 代理(Proxy) 一个类被AOP织入增强后,就产生了一个结果类.它是融合了原类和增强逻辑的代理类,根据不同的代理方式,代理类既可能是和原类具有相同接口的类,也可能就是原类的子类,所以可以采用与调用原类相同的方法调用代理类. 123456789class Proxy &#123; Target target; login()&#123; //方法前增强 打印日志 target.login(); //方法后增强 打印日志 &#125;&#125;new Proxy().login(); 切面(Aspect) 切面由切点和增强(介入)组成,它既包括横切逻辑的定义,也包括链接点的定义,也包括链接点的定义,Spring AOP就是负责实施切面的框架,它将切面所定义的横切所定义的横切逻辑织入切面所指定的链接点中. AOP的工作重心在于如何将增强应用于目标对象的连接点中上,这里包含两项工作: 第一,如何通过切点和增强定位到链接点上; 第二,如何在增强中编写切面代码; 核心概念的图解 结合下图然后再来回顾一下上面的概念点。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 项目]]></title>
    <url>%2F2013%2F02%2F24%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay47_SpringIoC%2F04.Spring%20%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[创建Spring项目POM创建一个工程名为 hello-spring 的项目，pom.xml 文件如下： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-spring&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 主要增加了 org.springframework:spring-context 依赖 创建接口与实现创建 UserService 接口12345package com.funtl.hello.spring.service;public interface UserService &#123; public void sayHi();&#125; 创建 UserServiceImpl 实现123456789package com.funtl.hello.spring.service.impl;import com.funtl.hello.spring.service.UserService;public class UserServiceImpl implements UserService &#123; public void sayHi() &#123; System.out.println(&quot;Hello Spring&quot;); &#125;&#125; 创建 Spring 配置文件在 src/main/resources 目录下创建 spring-context.xml 配置文件，从现在开始类的实例化工作交给 Spring 容器管理（IoC），配置文件如下： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.funtl.hello.spring.service.impl.UserServiceImpl&quot; /&gt;&lt;/beans&gt; &lt;bean /&gt;：用于定义一个实例对象。一个实例对应一个 bean 元素。 id：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean，Bean 与 Bean 间的依赖关系也是通过 id 属性关联的。 class：指定该 Bean 所属的类，注意这里只能是类，不能是接口。 测试 Spring IoC创建一个 MyTest 测试类，测试对象是否能够通过 Spring 来创建，代码如下： 1234567891011121314151617package com.funtl.hello.spring;import com.funtl.hello.spring.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; // 获取 Spring 容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;); // 从 Spring 容器中获取对象 UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.sayHi(); &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 与IOC]]></title>
    <url>%2F2013%2F02%2F23%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay47_SpringIoC%2F03.Spring%20%E4%B8%8EIOC%2F</url>
    <content type="text"><![CDATA[Spring 与 IoC概述控制反转（IoC，Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。 IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种： 依赖注入和依赖查找。依赖注入方式应用更为广泛。 依赖查找：Dependency Lookup，DL，容器提供回调接口和上下文环境给组件，程序代码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。 依赖注入：Dependency Injection，DI，程序代码不做定位查询，这些工作由容器自行完成。 依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。 Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。 依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 的特点]]></title>
    <url>%2F2013%2F02%2F22%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay47_SpringIoC%2F02.Spring%20%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Spring 的特点非侵入式所谓非侵入式是指，Spring 框架的 API 不会在业务逻辑上出现，即业务逻辑是 POJO。由于业务逻辑中没有 Spring 的 API，所以业务逻辑可以从 Spring 框架快速的移植到其他框架， 即与环境无关。 容器Spring 作为一个容器，可以管理对象的生命周期、对象与对象之间的依赖关系。可以通过配置文件，来定义对象，以及设置与其他对象的依赖关系。 IoC控制反转（Inversion of Control），即创建被调用者的实例不是由调用者完成，而是由 Spring 容器完成，并注入调用者。 当应用了 IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。即，不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。 AOP面向切面编程（AOP，Aspect Orient Programming），是一种编程思想，是面向对象编程 OOP 的补充。很多框架都实现了对 AOP 编程思想的实现。Spring 也提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如日志和事务管理）进行开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。 我们可以把日志、安全、事务管理等服务理解成一个“切面”，那么以前这些服务一直是直接写在业务逻辑的代码当中的，这有两点不好：首先业务逻辑不纯净；其次这些服务被很多业务逻辑反复使用，完全可以剥离出来做到复用。那么 AOP 就是这些问题的解决方案， 可以把这些服务剥离出来形成一个“切面”，以期复用，然后将“切面”动态的“织入”到业务逻辑中，让业务逻辑能够享受到此“切面”的服务。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 简介]]></title>
    <url>%2F2013%2F02%2F21%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay47_SpringIoC%2F01.Spring%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Spring 简介概述Spring 的主要作用就是为代码“解耦”，降低代码间的耦合度。 根据功能的不同，可以将一个系统中的代码分为 主业务逻辑 与 系统级业务逻辑 两类。它们各自具有鲜明的特点：主业务代码间逻辑联系紧密，有具体的专业业务应用场景，复用性相对较低；系统级业务相对功能独立，没有具体的专业业务应用场景，主要是为主业务提供系统级服务，如日志、安全、事务等，复用性强。 Spring 根据代码的功能特点，将降低耦合度的方式分为了两类：IoC 与 AOP。IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”。而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”。 Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。Spring 的核心是控制反转（IoC）和面向切面编程（AOP）。简单来说，Spring 是一个分层的 Java SE/EE full-stack(一站式)轻量级开源框架。 Spring 体系结构 Spring 由 20 多个模块组成，它们可以分为数据访问/集成（Data Access/Integration）、Web、面向切面编程（AOP, Aspects）、应用服务器设备管理（Instrumentation）、消息发送（Messaging）、核心容器（Core Container）和测试（Test）。]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个Maven应用程序]]></title>
    <url>%2F2013%2F02%2F20%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay46_Maven%2F07.Maven%20%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[第一个 Maven 应用程序概述下面我们来学习如何使用 Maven 创建一个 Java Web 应用程序 创建 Maven 项目选择 File -&gt; New -&gt; Project... 选择 Maven 项目 填写项目信息 选择工作空间 目录结构Java Web 的 Maven 基本结构如下： 12345678├─src│ ├─main│ │ ├─java│ │ ├─resources│ │ └─webapp│ │ └─WEB-INF│ └─test│ └─java 结构说明： src：源码目录 src/main/java：Java 源码目录 src/main/resources：资源文件目录 src/main/webapp：Web 相关目录 src/test：单元测试 IDEA Maven 项目管理在 IDEA 界面的右侧 Maven Projects 选项，可以管理 Maven 项目的整个生命周期、插件、依赖等 完善 Java Web 程序POM修改 pom.xml 配置，内容如下： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.funtl&lt;/groupId&gt; &lt;artifactId&gt;hello-maven&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置说明： packaging：打包方式，这里是 war 包，表示为 Java Web 应用程序 dependencies：项目依赖配置，整个项目生命周期中所需的依赖都在这里配置 创建测试用 Servlet创建一个 Servlet 用于测试请求 1234567891011121314151617181920package com.funtl.hello.maven.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getRequestDispatcher("/index.jsp").forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); &#125;&#125; 创建测试用 JSP创建一个 JSP 页面，用于测试请求 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello Maven&lt;/body&gt;&lt;/html&gt; 创建 Log4J 的配置文件在 src/main/resources 目录下创建 log4j.properties 配置文件，内容如下： 123456789101112log4j.rootLogger=INFO, console, filelog4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%d %p [%c] - %m%nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.file.File=logs/log.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.A3.MaxFileSize=1024KBlog4j.appender.A3.MaxBackupIndex=10log4j.appender.file.layout.ConversionPattern=%d %p [%c] - %m%n 配置 web.xmlweb.xml 配置文件如下： 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.funtl.hello.maven.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 测试运行按照之前章节 第一个 IDEA 应用程序 配置完 Tomcat 后直接运行，打开浏览器访问 http://localhost:8080 显示如下： 1Hello Maven]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 常用命令]]></title>
    <url>%2F2013%2F02%2F19%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay46_Maven%2F06.Maven%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Maven 常用命令本章节只提供 Maven 使用时的一些基本命令 清除产生的项目1mvn clean 编译源代码1mvn compile 打包1mvn package 只打包不测试（跳过测试）1mvn -dmaven.test.skip=true 安装到本地仓库1mvn install 源码打包123mvn source:jar或mvn source:jar-no-fork]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 快照]]></title>
    <url>%2F2013%2F02%2F18%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay46_Maven%2F05.Maven%20%E5%BF%AB%E7%85%A7%2F</url>
    <content type="text"><![CDATA[Maven 快照概述大型应用软件一般由多个模块组成，一般它是多个团队开发同一个应用程序的不同模块，这是比较常见的场景。例如，一个团队正在对应用程序的应用程序，用户界面项目(app-ui.jar:1.0) 的前端进行开发，他们使用的是数据服务工程 (data-service.jar:1.0)。 现在，它可能会有这样的情况发生，工作在数据服务团队开发人员快速地开发 bug 修复或增强功能，他们几乎每隔一天就要释放出库到远程仓库。 现在，如果数据服务团队上传新版本后，会出现下面的问题： 数据服务团队应该发布更新时每次都告诉应用程序 UI 团队，他们已经发布更新了代码。 UI 团队需要经常更新自己 pom.xml 以获得更新应用程序的版本。 为了处理这类情况，引入快照的概念，并发挥作用。 什么是快照？快照（SNAPSHOT）是一个特殊版本，指出目前开发拷贝。不同于常规版本，Maven 每生成一个远程存储库都会检查新的快照版本。 现在，数据服务团队将在每次发布代码后更新快照存储库为：data-service:1.0-SNAPSHOT 替换旧的 SNAPSHOT jar。 快照与版本在使用版本时，如果 Maven 下载所提到的版本为 data-service:1.0，那么它永远不会尝试在库中下载已经更新的版本 1.0。要下载更新的代码，data-service 的版本必须要升级到 1.1。 在使用快照（SNAPSHOT）时，Maven 会在每次应用程序 UI 团队建立自己的项目时自动获取最新的快照（data-service:1.0-SNAPSHOT）。 快照交互示意图]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 插件]]></title>
    <url>%2F2013%2F02%2F17%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay46_Maven%2F04.Maven%20%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Maven 插件Maven 是一个执行插件的框架，每一个任务实际上是由插件完成的。Maven 插件通常用于： 创建 jar 文件 创建 war 文件 编译代码文件 进行代码单元测试 创建项目文档 创建项目报告 一个插件通常提供了一组目标，可使用以下语法来执行： 1mvn [plugin-name]:[goal-name] 例如，一个 Java 项目可以使用 Maven 编译器插件来编译目标，通过运行以下命令编译 1mvn compiler:compile 常用插件以下是一些常见的插件列表： 插件 描述 clean 编译后的清理目标，删除目标目录 compiler 编译 Java 源文件 surefile 运行JUnit单元测试，创建测试报告 jar 从当前项目构建 JAR 文件 war 从当前项目构建 WAR 文件 javadoc 产生用于该项目的 Javadoc antrun 从构建所述的任何阶段运行一组 Ant 任务]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 依赖]]></title>
    <url>%2F2013%2F02%2F16%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay46_Maven%2F03.Maven%20POM%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[Maven 依赖Maven POMPOM 代表项目对象模型。它是 Maven 中工作的基本单位，这是一个 XML 文件。它始终保存在该项目基本目录中的 pom.xml 文件。 POM 包含的项目是使用 Maven 来构建的，它用来包含各种配置信息。 POM 也包含了目标和插件。在执行任务或目标时，Maven 会使用当前目录中的 POM。它读取POM得到所需要的配置信息，然后执行目标。部分的配置可以在 POM 使用如下： project dependencies plugins goals build profiles project version developers mailing list 创建一个POM之前，应该要先决定项目组(groupId)，它的名字(artifactId)和版本，因为这些属性在项目仓库是唯一标识的。 POM 的例子123456789&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lusifer&lt;/groupId&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt; 要注意的是，每个项目只有一个 POM 文件 所有的 POM 文件要项目元素必须有三个必填字段: groupId，artifactId，version 在库中的项目符号是：groupId:artifactId:version pom.xml 的根元素是 project，它有三个主要的子节点。 节点 描述 groupId 这是项目组的编号，这在组织或项目中通常是独一无二的。 例如，一家银行集团 com.company.bank 拥有所有银行相关项目。 artifactId 这是项目的 ID。这通常是项目的名称。 例如，consumer-banking。 除了 groupId 之外，artifactId 还定义了 artifact 在存储库中的位置。 version 这是项目的版本。与 groupId 一起使用，artifact 在存储库中用于将版本彼此分离。 例如：com.company.bank:consumer-banking:1.0，com.company.bank:consumer-banking:1.1 Maven 依赖机制概述在 Maven 依赖机制的帮助下自动下载所有必需的依赖库，并保持版本升级。让我们看一个案例研究，以了解它是如何工作的。假设你想使用 Log4j 作为项目的日志。这里你要做什么？ 传统方式 访问 http://logging.apache.org/log4j/ 下载 Log4j 的 jar 库 复制 jar 到项目类路径 手动将其包含到项目的依赖 所有的管理需要一切由自己做 如果有 Log4j 版本升级，则需要重复上述步骤一次。 Maven 的方式 你需要知道 log4j 的 Maven 坐标，例如： 123&lt;groupId&gt;log4j&lt;/groupId&gt;&lt;artifactId&gt;log4j&lt;/artifactId&gt;&lt;version&gt;1.2.17&lt;/version&gt; 它会自动下载 log4j 的 1.2.17 版本库 声明 Maven 的坐标转换成 pom.xml 文件 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 当 Maven 编译或构建，log4j 的 jar 会自动下载，并把它放到 Maven 本地存储库 所有由 Maven 管理 解释说明看看有什么不同？那么到底在 Maven 发生了什么？当建立一个 Maven 的项目，pom.xml 文件将被解析，如果看到 log4j 的 Maven 坐标，然后 Maven 按此顺序搜索 log4j 库： 在 Maven 的本地仓库搜索 log4j 在 Maven 中央存储库搜索 log4j 在 Maven 远程仓库搜索 log4j(如果在 pom.xml 中定义) Maven 依赖库管理是一个非常好的工具，为您节省了大量的工作]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 仓库]]></title>
    <url>%2F2013%2F02%2F15%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay46_Maven%2F02.Maven%20%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Maven 仓库Maven 本地仓库Maven 的本地资源库是用来存储所有项目的依赖关系(插件 Jar 和其他文件，这些文件被 Maven 下载)到本地文件夹。很简单，当你建立一个 Maven 项目，所有相关文件将被存储在你的 Maven 本地仓库。 默认情况下，Maven 的本地资源库默认为 .m2 目录文件夹： Unix/Mac OS X：~/.m2 Windows：C:\Documents and Settings\{your-username}\.m2 通常情况下，可改变默认的 .m2 目录下的默认本地存储库文件夹到其他更有意义的名称，例如， maven-repo 找到 {M2_HOME}\conf\setting.xml, 更新 localRepository 到其它名称。 执行之后，新的 Maven 本地存储库现在改为 D:/apache-maven-3.5.2/repo Maven 中央仓库当你建立一个 Maven 的项目，Maven 会检查你的 pom.xml 文件，以确定哪些依赖下载。首先，Maven 将从本地资源库获得 Maven 的本地资源库依赖资源，如果没有找到，然后把它会从默认的 Maven 中央存储库 http://repo1.maven.org/maven2/ 查找下载。 使用 MVNrepository 搜索：https://mvnrepository.com/ 配置镜像地址默认的中央仓库服务器在国外，访问慢，还会存在被墙以后无法访问的问题，所以一般国内都会添加阿里的maven参考作为代理服务器。需要配置setting.xml中在mirrors节点中添加阿里Maven服务地址mirror。 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt;]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 简介]]></title>
    <url>%2F2013%2F02%2F14%2FJavaEE%E6%A1%86%E6%9E%B6%2FDay46_Maven%2F01.Maven%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Maven简介Maven介绍Maven 是一个项目管理和综合工具。Maven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。 在多个开发团队环境时，Maven 可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven 让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。 Maven 提供了开发人员的方式来管理： Builds Documentation Reporting Dependencies SCMs Releases Distribution mailing list 概括地说，Maven 简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。 Maven 增加可重用性并负责建立相关的任务。 Maven安装配置想要安装 Apache Maven 在 Windows 系统上, 需要下载 Maven 的 zip 文件，并将其解压到你想安装的目录，并配置 Windows 环境变量。 注意：请尽量使用 JDK 1.8 及以上版本 JDK 和 JAVA_HOME确保已安装 JDK，并设置 JAVA_HOME 环境变量到 Windows 环境变量。 下载 Apache Maven下载地址：http://maven.apache.org/download.cgi 下载 Maven 的 zip 文件，例如： apache-maven-3.5.2-bin.zip，将它解压到你要安装 Maven 的文件夹。假设你解压缩到文件夹 – D:\apache-maven-3.5.2 注意：在这一步，只是文件夹和文件，安装不是必需的。 添加 MAVEN_HOME添加 MAVEN_HOME 环境变量到 Windows 环境变量，并将其指向你的 Maven 文件夹。 添加到环境变量 - PATH 验证Maven安装使用命令：mvn -version 输出： 1234567C:\Users\Lusifer&gt;mvn -versionApache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T15:58:13+08:00)Maven home: D:\apache-maven-3.5.2\bin\..Java version: 1.8.0_152, vendor: Oracle CorporationJava home: C:\Program Files\Java\jdk1.8.0_152\jreDefault locale: zh_CN, platform encoding: GBKOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;]]></content>
      <categories>
        <category>JavaWeb框架</category>
      </categories>
      <tags>
        <tag>JavaWeb框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三层架构]]></title>
    <url>%2F2013%2F02%2F13%2FDatabase%2FDay38_MVC%2F02.%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[三层架构什么是三层架构 三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层。 三层架构的分层 分层（tier） 概念 表现层（UI） 通俗讲就是展现给用户的界面，用于显示数据和接受用户输入的数据；即用户在使用一个系统的时候他的所见所得。 业务逻辑层（BLL） 针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。是表示层和数据访问层之间的桥梁。 数据访问层（DAL） 该层所做事务直接操作数据库，针对数据的增添、删除、修改、查找等。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC模式]]></title>
    <url>%2F2013%2F02%2F12%2FDatabase%2FDay38_MVC%2F01.MVC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MVC模式什么是 MVC 模式 MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 MVC 详细分层 Model（模型）：对应的组件是JavaBean（Java类）。模型可以分为业务逻辑和数据模型，它们代表应用程序的业务逻辑和状态。 View（视图）：对应的组件是JSP或HTML文件。视图提供了可交互的客户界面，向客户显示模型数据。。 Controller（控制器）对应的组件是Servlet。控制器响应客户的请求，根据客户的请求来操作模型，并且把模型的响应结果由视图展示给客户。 MVC设计模型的优点和好处 各司其职、互不干涉 如果某一层的需求发生了变化，就只需要更改相应层中的代码，而不会影响到其他层。 有利于在开发中的分工。 由于按层把系统分开，那么就能更好地实现开发中的分工。网页设计人员可以开发JSP页面，对于业务熟悉的开发人员可以开发模型中相关业务处理的方法，而其他开发人员可开发控制器，以进行程序控制。 有利于组件的重用 如控制层可独立成一个通用的组件，视图层也可做成通用的操作界面。把显示与数据分离，这样就增加了各个模块的可重用性。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接池]]></title>
    <url>%2F2013%2F02%2F11%2FDatabase%2FDay37_pool%2F02.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[数据库连接池什么是数据库连接池 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。 释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。 模拟数据库连接池 连接池类——- FastConnectionPool 模拟数据库连接池的操作流程： 创建一个数据库连接池 初始10个连接对象 来一个客户端，从连接池里取 当客户用完了，则不是真的销毁，而是放入到连接池中123456789101112131415public class FastConnectionPool &#123; private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;&gt;(); static&#123; for (int i = 0; i &lt; 10; i++) &#123; Connection connection = DBUtils.getConnection(); pool.add(connection); &#125; &#125; public Connection getConnection()&#123; return pool.removeFirst(); &#125; public void release(Connection cennection)&#123; pool.add(cennection); &#125;&#125; DataSoure 连接池各有各的实现方式，所以sun公司定义了一个标准：DataSource 所以我们实现的连接要符合sun公司的规范，就需要实现接口 DataSource ，所以我们可以编写一个 MyDataSource 类，之后就是面向 DataSource 来编程。 DBCP DBCP（DataBase Connection Pool）数据库连接池，是Java数据库连接池的一种，由Apache开发，通过数据库连接池，可以让程序自动管理数据库连接的释放和断开。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//配置文件：dbcpconfig.properties#连接设置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdrusername=rootpassword=root#&lt;!-- 初始化连接 --&gt;initialSize=20#最大连接数量maxActive=100#&lt;!-- 最大空闲连接 --&gt;maxIdle=20#&lt;!-- 最小空闲连接 --&gt;minIdle=5#&lt;!-- 超时等待时间以毫秒为单位 --&gt;maxWait=6000#解决编码问题connectionProperties=useUnicode=true;characterEncoding=utf8#指定由连接池所创建的连接的自动提交（auto-commit）状态。defaultAutoCommit=true#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。#可用值为下列之一：NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLEdefaultTransactionIsolation=REPEATABLE_READ//工具类public class DBCPUtils &#123; private static DataSource dataSource; static&#123; try &#123; Properties properties = new Properties(); properties.load(DBCPUtils.class.getClassLoader().getResourceAsStream("dbcpconfig.properties")); dataSource = BasicDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException&#123; return dataSource.getConnection(); &#125; &#125; C3P0 C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有 Hibernate，Spring 等。12345678910111213141516171819202122232425262728293031// 配置文件：c3p0-config.xml&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/jdr&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!--当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException,如设为0则无限期等待。单位毫秒。Default: 0 --&gt; &lt;property name="checkoutTimeout"&gt;30000&lt;/property&gt; &lt;!--每30秒检查所有连接池中的空闲连接。Default: 0 --&gt; &lt;property name="idleConnectionTestPeriod"&gt;30&lt;/property&gt; &lt;!-- 初始化连接池的连接对象 --&gt; &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; &lt;!--最大空闲时间,30秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt; &lt;property name="maxIdleTime"&gt;30&lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; &lt;property name="maxPoolSize"&gt;100&lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; &lt;property name="minPoolSize"&gt;10&lt;/property&gt; &lt;/default-config&gt; &lt;/c3p0-config&gt; public class C3P0Utils &#123; private static DataSource dataSource; static&#123; dataSource = new ComboPooledDataSource(); &#125; public static Connection getConnection() throws SQLException&#123; return dataSource.getConnection(); &#125; &#125; Durid Druid是阿里巴巴开发的号称为监控而生的数据库连接池，Druid是目前最好的数据库连接池。在功能、性能、扩展性方面，都超过其他数据库连接池，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况。1234567891011121314151617181920212223242526272829303132333435363738394041//配置文件：druid.proertiesdriverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/testusername=rootpassword=root#初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时initialSize=5#最大连接池数量maxActive=10#最小连接池数量maxIdle=6#获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。maxWait=3000//工具类public class druidUtils &#123; private static Properties properties = null; static&#123; try &#123; properties = new Properties(); properties.load(druidUtils.class.getResourceAsStream("/druid.properties")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection()&#123; DataSource dataSource = null; Connection connection = null; try &#123; dataSource = DruidDataSourceFactory.createDataSource(properties); connection = dataSource.getConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2013%2F02%2F10%2FDatabase%2FDay37_pool%2F01.%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池什么是线程池 线程池是一种线程使用模式。一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。 线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。 如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。 如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。 为什么使用线程池 一个线程完成一项任务所需时间为：T1创建线程时间，T2在线程中执行任务的时间，T3销毁线程时间。 线程池技术正是关注如何缩短或调整T1、T3时间的技术，从而提高程序的性能。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。 线程池不仅调整T1，T3产生的时间段，而且它还显著减少了创建线程的数目。 系统启动一个新线程的成本是比较高的，因为涉及与操作系统的交互，在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，优先考虑使用线程池。 线程池在系统启动时即创建大量空闲的线程，程序将一个 Runnable 对象传给线程池，线程池就会启动一条线程来执行该对象的 run()，当 run() 执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个 Runnable 对象的Run() 。 JDK1.5以前，开发者必须手动实现自己的线程池，JDK1.5开始，Java内建支持线程池 ThreadPool 线程池的使用 Java通过Executors提供四种线程池，分别为： newCachedThreadPool():创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool():创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool():创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor():创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO， LIFO， 优先级）执行。 线程池的案例123456789101112131415161718public class Demo &#123; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executor = Executors.newCachedThreadPool(); Task task = new Task(); executor.submit(task); executor.shutdown(); &#125;&#125;class Task implements Runnable&#123; static int count; @Override public void run() &#123; count++; for (int i = 0;i &lt;1000;i++)&#123; System.out.println(Thread.currentThread().getName()+":"+i+"-----"+count); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库三大范式]]></title>
    <url>%2F2013%2F02%2F09%2FDatabase%2FDay36_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B7%B1%E5%85%A5%2F07.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库三大范式什么是范式 为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就叫做范式。 范式就是符合某一种设计要求的总结，要想设计一个结构合理的关系型数据库，必须满足一定的范式。 什么是数据库三大范式 一般地，在进行数据库设计时，应遵循三大原则，也就是我们通常说的三大范式 第一范式要求确保表中每列的原子性，也就是不可拆分 第二范式要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖 第三范式确保主键列之间没有传递函数依赖关系，也就是消除传递依赖。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2013%2F02%2F08%2FDatabase%2FDay36_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B7%B1%E5%85%A5%2F06.%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数什么是自定义函数 MySQL本身提供了内置函数，这些函数的存在给我们日常的开发和数据操作带来了很大的便利，可是我们总会出现其他的需求：我们需要调用一个函数，这个函数需要按照我们的要求来实现我们自己的功能，可是这个函数式系统不能提供的因为这中需求的不确定性。因此我们需要自己来解决这种需求。还好MySQL设计的扩展性给了我们这个机会，我们可以通过自定义函数的功能解决这个问题。 创建自定义函数123 Create function function_name(参数列表) returns 返回值类型 函数体内容 函数名：应该合法的标识符，并且不应该与已有的关键字冲突。一个函数应该属于某数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则默认为当前数据库。 参数列表：可以有一个或者多个函数参数，甚至是没有参数也是可以的。对于每个参数，由参数名和参数类型组成。 返回值：指明返回值类类型 函数体：自定义函数的函数体由多条可用的MySQL语句，流程控制，变量声明等语句构成。需要指明的是函数体中一定要含有return 返回语句。 存储过程与函数的区别 本质上没区别。函数只能通过return语句返回单个值或者表对象。而存储过程不允许执行return，但是通过out参数返回多个值。 函数是可以嵌入在sql中使用的,可以在select中调用，而存储过程不行。函数限制比较多，如不能用临时表，只能用表变量等，而存储过程的限制相对就比较少。 一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。 当对数据库进行复杂操作时(如对多个表进行Update、Insert、Query、Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。存储过程可以从自己的存储过程内引用其它存储过程，这可以简化一系列复杂语句. 3. 存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。 存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。 存储过程可以接受参数、输出参数、返回单个或多个结果集以及返回值，可以向程序返回错误原因。但函数只能返回一个特定类型的值或者表对象。 存储过程中的CRUD的操作会影响数据库状态，但函数却不能。 函数只能是in类型，存储过程可以使用In\out\inout类型。 常见的函数 数学函数 绝对值：ABS(x) 平方根函数SQRT(x) 求余函数MOD(x,y) 随机数的函数RAND() 幂运算函数POW(x,y) 字符串函数 计算字符串长度的函数LENGTH(s) 合并字符串CONCAT(s1,s2,…) 截取字符串SUBSTRING(s,n,len); 日期和时间函数 返回当前日期CURDATE() 返回当前时间CURTIME() 返回当前时间和日期NOW() 返回日期d中的对应的部分：YEAR(d)、MONTH(d)、DAYOFMONTH(d)、HOUR(d)、MINUTE(t)、SECOND(t) 返回日期d表示星期几DAYOFWEEK(d)，0表示星期一 按照表达式f显示日期d DATE_FORMAT(d,f) 按照表达式f显示时间t TIME_FORMAT(t,f) 条件判断函数： IF(expr, v1, v2) 如果表达式expr成立，则返回v1，否则返回v2 IFNULL(v1,v2) 如果v1不为空则显示v1否则显示v2 更多函数请参考：https://www.runoob.com/mysql/mysql-functions.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储过程]]></title>
    <url>%2F2013%2F02%2F07%2FDatabase%2FDay36_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B7%B1%E5%85%A5%2F05.%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[存储过程什么是存储过程 存储过程是一组可编程的函数，是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。 存储过程的优缺点 优点 存储过程可封装，并隐藏复杂的商业逻辑。 存储过程可以回传值，并可以接受参数。 存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。 存储过程可以用在数据检验，强制实行商业逻辑等。 缺点 存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。 存储过程的性能调校与撰写，受限于各种数据库系统。 存储过程的使用 创建存储过程 create procedure 存储过程名称(参数列表)[存储过程特性]begin 存储过程内容End 调用存储过程 call 存储过程名称(实参列表); 删除存储过程 drop procedure 存储过程名称; 形参列表 [in | out | inout] 参数名称 参数类型; 变量 变量的作用 变量的作用范围是begin~end程序段中。 定义变量 declare 变量名 变量类型 [default 默认值]; 为变量赋值 set 变量名 = 值; select 字段1[,…] into 变量名[,…] from 表名 where 条件;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引]]></title>
    <url>%2F2013%2F02%2F06%2FDatabase%2FDay36_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B7%B1%E5%85%A5%2F04.%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[索引什么是索引 索引是用于快速找出在某个列中有一特定值的行。 不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。如果表中查询的列有一个索引，MySQL能快速到达一个位置去搜寻到数据文件的中间，没有必要看所有数据。 当然索引也不易过多，索引越多写入，修改的速度越慢。因为，写入修改数据时，也要修改索引。 MySQL 的索引类型 索引类型 功能说明 普通索引 最基本的索引，它没有任何限制 唯一索引 某一行企用了唯一索引则不准许这一列的行数据中有重复的值。针对这一列的每一行数据都要求是唯一的 主键索引 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引，常用于用户ID。类似于书中的页码 全文索引 对于需要全局搜索的数据，进行全文索引。一般用于检索检索文本信息的 普通索引 类型 详细说明 基本语法 alter table 表 add index(字段) 示例 ALTER TABLE money ADD INDEX(username); 示例解释 为money表的username字段增加索引 唯一索引 类型 详细说明 基本语法 alter table 表 add UNIQUE(字段) 示例 ALTER TABLE money ADD UNIQUE(email); 示例解释 为money表的email字段增加唯一索引 主键索引 类型 详细说明 基本语法 alter table 表 add PRIMARY KEY(字段) 示例 ALTER TABLE money ADD PRIMARY KEY(id); 示例解释 为money表的id字段增加主键索引 全文索引 类型 详细说明 基本语法 alter table 表 add FULLTEXT(字段) 示例 ALTER TABLE money ADD FULLTEXT(content); 示例解释 为money表的content字段增加唯一索引 删除索引 Alter table 表 drop index 索引名； 检查索引是否引用 mysql在使用like查询的时候只有使用后面的%时，才会使用到索引。1EXPLAIN SELECT * FROM `user` WHERE username LIKE &apos;t_%&apos;;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发器]]></title>
    <url>%2F2013%2F02%2F05%2FDatabase%2FDay36_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B7%B1%E5%85%A5%2F03.%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[触发器什么是触发器 触发器（TRIGGER）是数据库提供给程序员和DBA 用来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，是用户定义在表上的一类由事件驱动的特殊过程。触发器的执行不是由程序调用，也不是由手工启动，而是由事件来触发的。其中，事件是指用户对表的增（INSERT）、删（DELETE）、改（即更新UPDATE）等操作。触发器经常被用于加强数据的完整性约束和业务规则等。 触发器的作用 可维护数据库的安全性、一致性和完整性。 可在写入数据表前，强制检验或转换数据。 当触发器发生错误时，异常的结果会被撤销。 部分数据库管理系统可以针对数据定义语言（DDL）使用触发器，称为DDL 触发器，还可以针对视图定义替代触发器（INSTEAD OF）。创建触发器123456create trigger 触发器名 before|after 触发事件 on 表名 for each row 执行语句;create trigger 触发器名 before|after 触发事件 on 表名 for each rowBegin 执行语句列表End 触发器的过度对象 New：范围：可在insert、update触发器中使用 Old： 范围：可在delete、update触发器中使用 删除触发器 drop trigger 触发器名称;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视图]]></title>
    <url>%2F2013%2F02%2F04%2FDatabase%2FDay36_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B7%B1%E5%85%A5%2F02.%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[视图什么是视图 视图可以看成数据库中的一张虚拟表，方便用户对一张或者多张表的某些字段进行操作。 视图的作用 使操作简单可以为复杂并且使用频繁的查询定义一个视图，简化查询的步骤。 增加数据的安全性通过视图，用户只能查询和修改指定的数据，指定数据以外的信息，用户根本接触不到，这样可以保证敏感信息不会被没有权限的人看到。 提高表的独立性视图可以屏蔽原有表结构变化所带来的影响，例如原来表删除或者增加了某些列，对视图不会照成影响。 视图的操作 视图的创建1234create [algorithm = &#123;undefined | merge | temptable&#125;] view 视图名 as 查询语句[with check option]; algorithm 表示视图选择的算法。 undefined 表示自动选择算法 merge 表示将使用视图的语句与视图定义合并起来，使得视图的某一个部分取代语句对应的部分。 temptable 表示将视图结果存入临时表，然后使用临时表执行语句 with check option 表示更新视图时要保证在该视图的权限范围内。简单来说可以这么解释：通过视图进行的修改，必须也能通过该视图看到修改后的结果。 修改视图 1create or replace view ... 删除视图 1drop view 视图名;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2013%2F02%2F03%2FDatabase%2FDay36_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B7%B1%E5%85%A5%2F01.%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务什么是事务? MySQL:每一条语句都属于独立事务,默认自动管理提交的. 如果需要把多条语句当成一个整体,那么就需要把多条语句放在一个事务里面 开启事务：start transaction 提交事务：commit 回滚事务：rollback 事务的特性有哪些? 事务的特性：ACID 原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持久性（ Durability ） 原子性：事务是数据库的逻辑工作单位,事务中包含的各操作要么都完成,要么都不完成 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态.因此当数据库只包含成功事务提交的结果时,就说数据库处于一致性状态.如果数据库系统运行中发生故障,有些事务尚未完成就被迫中断,这些未完成事务对数据库所做的修改有一部分已写入物理数据库,这时数据库就处于一种不正确的状态,或者说是不一致的状态. 隔离性：一个事务的执行不能受其它事务干扰.即一个事务内部的操作及使用的数据对其它并发事务是隔离的,并发执行的各个事务之间不能互相干扰. 持久性：指一个事务一旦提交,它对数据库中的数据的改变就应该是永久性的.接下来的其它操作或故障不应该对其执行结果有任何影响. 事务的状态与隔离级别 不考虑事务的隔离级别,会出现以下的状态: 脏读:一个线程中的事务读到了另外一个线程中未提交的update数据. 不可重复读:一个线程中的事务读到了另外一个线程中已经提交的update的数据. 虚读(幻读):一个线程中的事务读到了另外一个线程中已经提交的insert的数据. 要想避免以上现象,通过更改事务的隔离级别来避免: read uncommitted:脏读、不可重复读、虚读有可能发生. read committed:避免脏读的发生,(不可重复读、虚读有可能发生). repeatable read:(避免脏读、不可重复读的发生),虚读有可能发生. serializable:避免脏读、不可重复读、虚读的发生. MySQL默认的隔离级别：repeatable read ORACLE默认的隔离级别：read committed 设置当前的事务隔离级别:set transaction isolation level 级别; JDBC设置隔离级别 JDBC开启事务123456// start transactionconnection.setAutoCommit(false); // rollbackconnection.rollback(); // commitconnection.commit();]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL练习]]></title>
    <url>%2F2013%2F02%2F02%2FDatabase%2F14.Mysql%20%E7%AE%80%E4%BB%8B%E4%B8%8ECURD%2F%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[设有一数据库，包括四个表：学生表（Student）、课程表（Course）、成绩表（Score）以及教师信息表（Teacher）。表结构及数据如下 Student (学生表) 属性名 数据类型 可否为空 含 义 Sno varchar (20) 否 学号（主码） Sname varchar (20) 否 学生姓名 Ssex varchar (20) 否 学生性别 Sbirthday datetime 可 学生出生年月 Class varchar (20) 可 学生所在班级 Course（课程表） 属性名 数据类型 可否为空 含 义 Cno varchar (20) 否 课程号（主码） Cname varchar (20) 否 课程名称 Tno varchar (20) 否 教工编号 Score(成绩表) 属性名 数据类型 可否为空 含 义 Sno varchar (20) 否 学号 Cno varchar (20) 否 课程号 Degree Decimal(4,1) 可 成绩 Teacher(教师表) 属性名 数据类型 可否为空 含 义 Tno varchar (20) 否 教工编号（主码） Tname varchar (20) 否 教工姓名 Tsex varchar (20) 否 教工性别 Tbirthday datetime 可 教工出生年月 Prof varchar (20) 可 职称 Depart varchar (20) 否 教工所在部门 添加学生信息1234567#添加学生信息insert into student values(&apos;108&apos;,&apos;曾华&apos;,&apos;男&apos;,&apos;1977-09-01&apos;,&apos;95033&apos;);insert into student values(&apos;105&apos;,&apos;匡明&apos;,&apos;男&apos;,&apos;1975-10-02&apos;,&apos;95031&apos;);insert into student values(&apos;107&apos;,&apos;王丽&apos;,&apos;女&apos;,&apos;1976-01-23&apos;,&apos;95033&apos;);insert into student values(&apos;101&apos;,&apos;李军&apos;,&apos;男&apos;,&apos;1976-02-20&apos;,&apos;95033&apos;);insert into student values(&apos;109&apos;,&apos;王芳&apos;,&apos;女&apos;,&apos;1975-02-10&apos;,&apos;95031&apos;);insert into student values(&apos;103&apos;,&apos;陆君&apos;,&apos;男&apos;,&apos;1974-06-03&apos;,&apos;95031&apos;); 添加教师表1234insert into teacher values(&apos;804&apos;,&apos;李诚&apos;,&apos;男&apos;,&apos;1958-12-02&apos;,&apos;副教授&apos;,&apos;计算机系&apos;);insert into teacher values(&apos;856&apos;,&apos;张旭&apos;,&apos;男&apos;,&apos;1969-03-12&apos;,&apos;讲师&apos;,&apos;电子工程系&apos;);insert into teacher values(&apos;825&apos;,&apos;王萍&apos;,&apos;女&apos;,&apos;1972-05-05&apos;,&apos;助教&apos;,&apos;计算机系&apos;);insert into teacher values(&apos;831&apos;,&apos;刘冰&apos;,&apos;女&apos;,&apos;1977-08-14&apos;,&apos;助教&apos;,&apos;电子工程系&apos;); 添加课程表1234insert into course values(&apos;3-105&apos;,&apos;计算机导论&apos;,&apos;825&apos;);insert into course values(&apos;3-245&apos;,&apos;操作系统&apos;,&apos;804&apos;);insert into course values(&apos;6-166&apos;,&apos;数字电路&apos;,&apos;856&apos;);insert into course values(&apos;9-888&apos;,&apos;高等数学&apos;,&apos;831&apos;); 添加成绩表123456789101112insert into score values(&apos;103&apos;,&apos;3-245&apos;,&apos;86&apos;);insert into score values(&apos;105&apos;,&apos;3-245&apos;,&apos;75&apos;);insert into score values(&apos;109&apos;,&apos;3-245&apos;,&apos;68&apos;);insert into score values(&apos;103&apos;,&apos;3-105&apos;,&apos;92&apos;);insert into score values(&apos;105&apos;,&apos;3-105&apos;,&apos;88&apos;);insert into score values(&apos;109&apos;,&apos;3-105&apos;,&apos;76&apos;);insert into score values(&apos;103&apos;,&apos;3-105&apos;,&apos;64&apos;);insert into score values(&apos;105&apos;,&apos;3-105&apos;,&apos;91&apos;);insert into score values(&apos;109&apos;,&apos;3-105&apos;,&apos;78&apos;);insert into score values(&apos;103&apos;,&apos;6-166&apos;,&apos;85&apos;);insert into score values(&apos;105&apos;,&apos;6-166&apos;,&apos;79&apos;);insert into score values(&apos;109&apos;,&apos;6-166&apos;,&apos;81&apos;);]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引擎与事务]]></title>
    <url>%2F2013%2F02%2F01%2FDatabase%2F14.Mysql%20%E7%AE%80%E4%BB%8B%E4%B8%8ECURD%2F07%20-%20%E5%BC%95%E6%93%8E%E4%B8%8E%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[引擎engine12345例如: 一首诗保存起来，可以保存到(脑子里、纸上、磁盘上)等 不变的是数据，变的是存储的格式 信息可以用不同的engine来存储信息 engine 存储数据的方式不同 特点 Myisam InnoDB BDB Memory Archive 批量插入的速度 高 低 高 非常高 事务安全 支持 支持 锁机制 表锁 行锁 页锁 表锁 行锁 存储限制 没有 64TB 没有 有 没有 外键 支持 事务 事务：指的是逻辑上一组操作，组成这个事务的各个执行单元，要么一起成功,要么一起失败！ 事务的特性 原子性 - 事务不可分割,最小的执行单位 一致性 - 事务执行的前后数据的完整性保持一致 隔离性 - 一个事务执行的过程中,不应该受到其他的事务的干扰.（强调并发访问的问题，多个事物同时操作一条数据，保证操作的时候不能互相的干扰） 持久性 - 事务一旦提交,数据就永久保存到数据库中 如果不考虑隔离性:引发一些读的问题 脏读– 一个事务读到了另一个事务未提交的数据.(冠希给美美转账:冠希转钱但是没提交事物，给美美打电话说钱转了，美美查账没收到钱) 不可重复读 – 一个事务读到了另一个事务已经提交的update数据,导致多次查询结果不一致.（在一个事物中不管你查询多少次，数据必须保持一致） 虚读 – 一个事务读到了另一个事务已经提交的insert数据,导致多次查询结构不一致. 通过设置数据库的隔离级别来解决上述读的问题 未提交读:以上的读的问题都有可能发生. 已提交读:避免脏读,但是不可重复读，虚读都有可能发生. 可重复读:避免脏读，不可重复读.但是虚读是有可能发生. 串行化:以上读的情况都可以避免. 1—Read uncommitted isolation 2—Read committed isolation 4—Repeatable read isolation（Mysql默认值） 8—Serializable isolation（Oracle默认值） 查看mysql的隔离级别 SELECT @@TX_ISOLATION; Mysql 开始事务 start transaction; Mysql 提交事务 commit; Mysql 回滚数据 rollback;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化]]></title>
    <url>%2F2013%2F01%2F31%2FDatabase%2F14.Mysql%20%E7%AE%80%E4%BB%8B%E4%B8%8ECURD%2F06%20-%20Mysql%20%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[MySQL 优化 表关联查询时务必遵循 小表驱动大表 原则； 使用查询语句 where 条件时，不允许出现 函数，否则索引会失效； 使用单表查询时，相同字段尽量不要用 OR，因为可能导致索引失效，比如：SELECT * FROM table WHERE name = ‘手机’ OR name = ‘电脑’，可以使用 UNION 替代； LIKE 语句不允许使用 % 开头，否则索引会失效； 组合索引一定要遵循 从左到右 原则，否则索引会失效；比如：SELECT * FROM table WHERE name = ‘张三’ AND age = 18，那么该组合索引必须是 name,age 形式； 索引不宜过多，根据实际情况决定，尽量不要超过 10 个； 每张表都必须有 主键，达到加快查询效率的目的； 分表，可根据业务字段尾数中的个位或十位或百位（以此类推）做表名达到分表的目的； 分库，可根据业务字段尾数中的个位或十位或百位（以此类推）做库名达到分库的目的； 表分区，类似于硬盘分区，可以将某个时间段的数据放在分区里，加快查询速度，可以配合 分表 + 表分区 结合使用； 神器 EXPLAIN 语句 EXPLAIN 显示了 MySQL 如何使用索引来处理 SELECT 语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。 使用方法，在 SELECT 语句前加上 EXPLAIN 即可，如： EXPLAIN SELECT * FROM tb_item WHERE cid IN (SELECT id FROM tb_item_cat) id： SELECT 识别符。这是 SELECT 的查询序列号 select_type： SELECT类型,可以为以下任何一种 SIMPLE: 简单 SELECT(不使用 UNION 或子查询) PRIMARY: 最外面的 SELECT UNION: UNION 中的第二个或后面的 SELECT 语句 DEPENDENT UNION: UNION 中的第二个或后面的 SELECT 语句,取决于外面的查询 UNION RESULT: UNION 的结果 SUBQUERY: 子查询中的第一个 SELECT DEPENDENT SUBQUERY: 子查询中的第一个 SELECT,取决于外面的查询 DERIVED: 导出表的 SELECT(FROM 子句的子查询) table： 输出的行所引用的表 partitions： 表分区 type： 联接类型。下面给出各种联接类型，按照 从最佳类型到最坏类型 进行排序 system: 表仅有一行(=系统表)。这是 const 联接类型的一个特例。 const: 表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const 表很快,因为它们只读取一次! eq_ref: 对于每个来自于前面的表的行组合, 从该表中读取一行。这可能是最好的联接类型, 除了 const 类型。 ref: 对于每个来自于前面的表的行组合, 所有有匹配索引值的行将从这张表中读取。 ref_or_null: 该联接类型如同 ref,但是添加了 MySQL 可以专门搜索包含 NULL 值的行。 index_merge: 该联接类型表示使用了索引合并优化方法。 unique_subquery: 该类型替换了下面形式的 IN 子查询的 ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery 是一个索引查找函数, 可以完全替换子查询, 效率更高。 index_subquery: 该联接类型类似于 unique_subquery。可以替换 IN 子查询, 但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr) range: 只检索给定范围的行,使用一个索引来选择行。 index: 该联接类型与 ALL 相同,除了只有索引树被扫描。这通常比 ALL 快,因为索引文件通常比数据文件小。 ALL: 对于每个来自于先前的表的行组合, 进行完整的表扫描。 possible_keys： 指出 MySQL 能使用哪个索引在该表中找到行 key： 显示 MySQL 实际决定使用的键(索引)。如果没有选择索引, 键是 NULL。 key_len： 显示 MySQL 决定使用的键长度。如果键是 NULL, 则长度为 NULL。 ref： 显示使用哪个列或常数与 key 一起从表中选择行。 rows： 显示 MySQL 认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。 filtered： 显示了通过条件过滤出的行数的百分比估计值。 Extra： 该列包含 MySQL 解决查询的详细信息 Distinct: MySQL 发现第 1 个匹配行后,停止为当前的行组合搜索更多的行。 Not exists: MySQL 能够对查询进行 LEFT JOIN 优化, 发现 1 个匹配 LEFT JOIN 标准的行后, 不再为前面的的行组合在该表内检查更多的行。 range checked for each record (index map: #): MySQL 没有发现好的可以使用的索引, 但发现如果来自前面的表的列值已知, 可能部分索引可以使用。 Using filesort: MySQL 需要额外的一次传递, 以找出如何按排序顺序检索行。 Using index: 从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。 Using temporary: 为了解决查询, MySQL 需要创建一个临时表来容纳结果。 Using where: WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。 Using sort_union(…), Using union(…), Using intersect(…): 这些函数说明如何为 index_merge 联接类型合并索引扫描。 Using index for group-by: 类似于访问表的 Using index 方式,Using index for group-by 表示 MySQL 发现了一个索引,可以用来查询 GROUP BY 或 DISTINCT 查询的所有列, 而不要额外搜索硬盘访问实际的表]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视图]]></title>
    <url>%2F2013%2F01%2F30%2FDatabase%2F14.Mysql%20%E7%AE%80%E4%BB%8B%E4%B8%8ECURD%2F05%20-%20Mysql%20%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[视图什么时是视图 视图就是一张虚拟的表,表示通过某种运算得到的投影 什么样的情况下使用视图 一直重复操作某一个结果的集的时候，可以把这个结果集变成一个视图 例图需要求班级学生分数的前三高 最后三名 中间的第几名到第几名 如何创建是视图 create view 视图名 as select … 12345create table total(tid int(11) NULLtsalary double NULLtname varchar(20) NULL); 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*求最高工资三人的姓名与钱*/SELECT tname AS &apos;names&apos;,tsalary AS salaryFROM total ORDER BY tsalary DESCLIMIT 0,3; /*求最低工资三人的姓名与钱*/SELECT tname AS &apos;names&apos;,tsalary AS salaryFROM totalORDER BY tsalary ASCLIMIT 0,3;/*求第几名到几名?此时反复用到相同的数据*/SELECT tname AS &apos;names&apos;,tsalary AS salaryFROM totalORDER BY tsalary ASC;/*创建视图create view salarysasselect...*/CREATE VIEW salarys ASSELECT tname AS &apos;names&apos;,tsalary AS salaryFROM totalORDER BY tsalary ASC;/*视图相当于一张表*/SELECT * FROM salarys;/*工资高的前三者*/SELECT * FROM salarys ORDER BY salary DESC LIMIT 3; 视图的好处 简化查询 复杂统计时，先用视图生成结果，在查询视图 更加精细的权限控制 2个网站合作，可以查询对方网站用户，但是不能开放密码字段 多表查询(数据多分表) 一千万篇文章 放入五张表，每张表200万条数据 不知道在哪张表 create view novel as select title from novel1 union select title from novel2…. 修改表会影响视图，修改视图会影响表吗?（会影响一一对应的）]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表操作]]></title>
    <url>%2F2013%2F01%2F29%2FDatabase%2F14.Mysql%20%E7%AE%80%E4%BB%8B%E4%B8%8ECURD%2F04%20-%20%E8%A1%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[表数据操作MySQL中使用SQL语言几点说明 属于一个SQL语句，使用分号（;）结尾，否则mysql认为语句没有输入完。 箭头（-&gt;）代表SQL语句没有输入完 取消SQL语句使用（\c） SQL语句关键字和函数名不区分大小写（Linux区分，Windows不区分） 使用函数时，函数名和后面的括号之间不能有空格 常见完整性约束 PRIMARY KEY 主码约束(主键) UNIQUE 唯一性约束 NOT NULL 非空值约束 AUTO_INCREMENT 用于整数列默认自增1 UNSIGNED 无符号整数 DEFAULT default_value 默认值约束 DEFAULT cur_timestamp 创建新记录时默认保存当前时间（仅适用timestamp数据列） ON UPDATE cur_timestamp 修改记录时默认保存当前时间（仅适用timestamp数据列） CHARACTER SET name 指定字符集（仅适用字符串） 主键与外键 数据表之间的关联/引用关系是依靠具体的主键（primary key）和外键（foreign key）建立起来的 主键：帮助MySQL以最快的速度把一条特点的数据记录的位置确定下来。 主键必须是唯一的 主键应该是紧凑的，因此整数类型比较适合 外键：引用另外一个数据表的某条记录。 外键列类型尽可能与主键列类型保持一致 外键列应该加上NOT NULL 12345678910111213主键create table student( sid int not null auto_increment, name varchar(20) not null, primary key(sid));外键（自动检查外键是否匹配，仅适用InnoDB）create table score( cid int not null auto_increment primary key, score int, sid int, foreign key(sid) references student(sid)); 主表和从表 当主表中没有对应的记录时，不能将记录添加到子表 成绩表中不能出现在学员信息表中不存在的学号； 不能更改主表中的值而导致子表中的记录孤立 把学员信息表中的学号改变了，学员成绩表中的学号也应当随之改变； 子表存在与主表对应的记录，不能从主表中删除该行 不能把有成绩的学员删除了 删除主表前，先删子表 先删学员成绩表、后删除学员信息表 思考 电话号码一般使用什么数据类型存储? 性别一般使用什么数据类型存储? 年龄信息一般使用什么数据类型存储? 照片信息一般使用什么数据类型存储? 薪水一般使用什么数据类型存储? 学员姓名允许为空吗? 家庭地址允许为空吗? 电子邮件信息允许为空吗? 考试成绩允许为空吗? 选择主键的原则 最少性 尽量选择单个键作为主键 稳定性 尽量选择数值更新少的列作为主键 12345678910111213例：建立一个学生信息表(student)定义列sno学号，类型为5位定长字符串，非空，主键定义列sname姓名，类型为8位定长字符串，非空定义列ssex性别，取值1或0定义列sage年龄，类型为短整型定义列sdept系名，数据类型为20位变长字符串例：建立一个课程信息表（course）定义列courseid课程号，类型为整型，非空，自动增长，主键定义列cname课程名，类型为16位变长字符串，非空例：建立一个学生考试成绩信息表(sc)定义列grade成绩，类型为整型要求把表字段补充完整，可以通过学号查看学生相关课程的成绩 更改表结构操作 语法：alter table 表名 action; 说明：action 可以是如下语句： add 列名 建表语句 [first | after 列名] 可以为表添加一列，如果没指定first或者after，则在列尾添加一列，否则在指定列添加新列 add primary key (列名) 为表添加一个主键，如果主键已经存在，则出现错误 add foreign key(列名) references 表名(列名) 为表添加一个外键 alter 列名 set default 默认值可以更改指定列默认值 change 旧列名 新列名 &lt;建表语句&gt; [first | after 列名] 可以更改列类型和列名称，如果原列的名字和新列的名字相同 modify 列名 &lt;建表语句&gt; [first | after 列名和change的作用相同 drop 列名 //可以删除一列 drop primary key //可以删除主键 engine 类型名 //可以改变表类型 rename as 新表名 //可以将表名更改 1234567891011121314举例1：向people表中添加字段address2,类型为varchar,最大长度为100alter table people add address2 varchar(100);举例2: 将people表中的name列默认值改为100:alter table people alter name set default 100;举例3:向student表增加“入学时间”列，其数据类型为日期型。alter table student add scome date；注：无论基本表中原来是否已有数据，新增加的列一律为空值。举例4:将年龄的数据类型改为半字长整数。alter table student modify sage smallint； 注：修改原有的列定义有可能会破坏已有数据 插入记录操作 语法 insert into 表名 列名 values 值; 叙述 如果表名后面没写字段名，则默认是向所有的字段添加值，另外字符串值应该用‘ ’或“ ”引号括起来 12举例1：向people表中添加一条记录：insert into people(name,age) values(“zhangsan”,20); 12345678910创建一张学生信息表，往表中插入数据create table students( scode int not null auto_increment, sname varchar(20) not null, saddress varchar(20) default‘未知’, sgrade int, semail varchar(20), ssex bit, primary key(scode)); 插入多条数据123456789INSERT STUDENTS (SName,SGrade,SSex)VALUES(&apos;测试女生1&apos;,75,0), (&apos;测试女生2&apos;,77,0),(&apos;测试女生3&apos;,83,0),(‘测试男生1&apos;,81,1),(&apos;测试女生4&apos;,90,0),(‘测试男生2&apos;,94,1),(&apos;测试女生5&apos;,51,0),(‘测试男生3&apos;,53,1); 案例 创建表插入数据 1234567891011121314151617学生信息&apos;95001&apos;,&apos;洛燕妮&apos;,&apos;女&apos;,20,&apos;信息系&apos; &apos;95002&apos;,&apos;欧阳炎&apos;,&apos;男&apos;,19,&apos;计算机系&apos; &apos;95003&apos;,&apos;何东升&apos;,&apos;男&apos;,21,&apos;美术系&apos; &apos;95004&apos;,&apos;刘晨&apos;,&apos;男&apos;,18,&apos;计算机系&apos; &apos;95005&apos;,&apos;沙明华&apos;,&apos;女&apos;,21,&apos;美术系&apos; &apos;95006&apos;,&apos;欧阳宝宝&apos;,&apos;男&apos;,19,&apos;美术系’课程信息1,&apos;JAVA&apos;2,&apos;C&apos;3,&apos;.NET&apos;成绩信息&apos;95001&apos;,1,98 &apos;95002&apos;,1,50 &apos;95004&apos;,1,70 &apos;95003&apos;,4,95 &apos;95005&apos;,4,40 &apos;95006&apos;,4,77 &apos;95001&apos;,2,80 &apos;95002&apos;,3,58 &apos;95006&apos;,2,70 更新纪律操作 语法 update 表名 set 列名=值 where 更新条件(如果不带条件?) 叙述 where 子句是判断语句，用来设定条件，限制只更新匹配的行,如果不带where子句，则更新所有行数据 123将student表中的所有学生名称为&quot;Alex&quot;的改为&quot;Tom&quot;:update student set sname=&quot;Tom&quot; where sname=&quot;Alex&quot;; 删除记录操作 语法 delete from 表名 where 删除条件 叙述 此语句删除表中的行，如果不带where子句，则删除整个表中的记录，但是表不被删除 12删除student表中的所有年龄小于18岁的记录： delete from student where sage&lt;18; 查询12345678SELECT [DISTINCT | DISTINCTROW | ALL] select_expression,... [FROM table_references [WHERE where_definition] [GROUP BY col_name,...] [HAVING where_definition] [ORDER BY &#123;unsigned_integer | col_name |formula&#125; [ASC | DESC] ,...] [LIMIT [offset,] rows] [PROCEDURE procedure_name]] 查询记录操作 from子句：指定查询数据的表 where子句：查询数据的过滤条件 group by子句：对匹配where子句的查询结果进行分组 having子句：对分组后的结果进行条件限制 order by子句：对查询结果结果进行排序，后面跟desc降序或asc升序（默认）。 limit子句：对查询的显示结果限制数目 procedure子句：查询存储过程返回的结果集数据 查询举例 123456789101112131415161718192021222324252627282930举例1 : 查询全体学生的学号与姓名。select sno,sname from student;举例2 : 查询全体学生的详细记录。select sno,sname,ssex,sage,sdept from student; 或select * from student; 举例3 : 查全体学生的姓名及其出生年份。select sname,2008-sage from student；举例4 : 查询全体学生的姓名、出生年份和所有系，要求用小写字母表示所有系名。select sname,&apos;year of birth: &apos;,2008-sage, islower(sdept) from student;举例5 : 查询选修了课程的学生学号(去掉重复的记录)select distinct studentid from sc;举例6 : 查询全体学生的学号与姓名，用中文显示列名。select sno as ‘编号’,sname as ‘姓名’ from student;举例7 : 给表设置别名。select s.sno,s.sname from student as s; 举例8 : 查询年龄在20以下的学生的姓名。select sname from student where sage&lt;20；举例9 : 查询全体学生的姓名、年龄，要求按照年龄降序排序。select sname,sage from student order by sage desc;举例10 : 查询年龄最大的前3个学生的姓名和年龄，或第4、5个学生select sname,sage from student order by sage desc limit 3;或（limit 3,2） 使用集函数 SQL提供的统计函数称为集函数 主要的集函数 记数函数： count(列名) 计算元素的个数 求和函数： sum(列名) 对某一列的值求和，但属性必须是整型 计算平均值：avg(列名)对某一列的值计算平均值 求最大值： max(列名) 找出某一列的最大值 求最小值： min(列名) 找出某一列的最小值 1234567891011121314151617举例11 : 查询学生总数。select count(*) from student;举例12 : 查询选修了课程的学生人数。select count(distinct studentid) from sc;举例13 : 查询1号课程的学生平均成绩。select avg(grade) from sc where courseid=1;举例14 : 查询1号课程的学生最高分和最低分。select max(grade) as ‘最高分’,min(grade) as ‘最低分’ from sc where courseid=1;举例15 : 查询每个学生的平均成绩。select studentid,avg(grade) as ‘平均成绩’ from sc group by studentid;举例16 : 查询学生的平均成绩在70分以上的。select studentid,avg(grade) as ‘平均成绩’ from sc group by studentid having avg(grade)&gt;70; 在WHERE子句中使用谓词 BETWEEN AND :在两数之间 NOT BETWEEN AND ：不在两数之间 IN &lt;值表&gt; ：是否在特定的集合里（枚举） NOT IN &lt;值表&gt; ：与上面相反 LIKE ：是否匹配于一个模式 IS NULL（为空的）或 IS NOT NULL（不为空的）REGEXP : 检查一个值是否匹配一个常规表达式。 1234567891011121314151617181920212223242526272829303132333435举例17 : 查询年龄在20~23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄 。 select sname,sdept,sage from student where sage between 20 and 23; 举例18 : 查询年龄不在20~23岁之间的学生姓名、系别和年龄。 select sname,sdept,sage from student where sage not between 20 and 23; 举例19 : 查询&apos;信息系&apos;、&apos;美术系&apos;和&apos;计算机系&apos;学生的姓名和性别。 select sname,ssex from student where sdept in (‘信息系&apos;,‘美术系&apos;,‘计算机系&apos;);举例20 : 查询学号为95001的学生的详细情况。select * from student where sno like &apos;95001&apos;；等价于：select * from student where sno=&apos;95001&apos;; 举例21 : 查询所有姓刘学生的姓名、学号和性别。select sname,sno,ssex from student where sname like ‘刘%&apos;;举例22 : 某些学生选修课程后没有参加考试，所以有选课记录，但没有考试成绩。查询缺少成绩的学生的学号和相应的课程号。select studentid,courseid from sc where grade is null;举例23 : 查所有有成绩的学生学号和课程号。select studentid,courseid from sc where grade is not null;举例24 : 查询计算机系年龄在20岁以下的学生姓名。select sname from student where sdept=‘计算机系&apos; and sage&lt;20;举例25 : 查询信息系、美术系和计算机系学生的姓名和性别select sname,ssex from student where sdept in (‘信息系&apos;,&apos;美术&apos;,&apos;计算机系&apos;);可改写为：Select sname,ssex from student where sdept=&apos;信息系&apos; or sdept=&apos;美术&apos; or sdept=&apos;计算机系&apos;;举例26 : 查询选修了3号课程的学生的学号及其成绩，查询结果按分数降序排列。select studentid,grade from sc where courseid=3 orber by grade desc;举例27 : 查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。select * from student order by sdept,sage desc; 多表查询 连接查询 同时涉及多个表的查询称为连接查询 用来连接两个表的条件称为连接条件 内连接（inner join） SELECT Students.SName, Sc.CourseID, Sc.Grade FROM Students,ScWHERE Students.SNo = Sc.StudentID SELECTS.SName AS 姓名, CS.CName AS 课程, C.Grade AS 成绩FROM Students AS SINNER JOIN Sc AS C ON (S.SCode = C.StudentID)INNER JOIN Course AS CS ON (CS.CourseID = C.CourseID) 外连接 左外联结 (LEFT JOIN) SELECT S.SName,C.CourseID,C.Grade From Students AS S LEFT JOIN Sc AS C ON C.StudentID = S.SNo SELECT S.SName,C.CourseID,C.Grade From Sc AS C LEFT JOIN Students AS S ON C.StudentID = S.SNo 右外联结 (RIGHT JOIN) SELECT Titles.Title_id, Titles.Title, Publishers.Pub_nameFROM titlesRIGHT OUTER JOIN PublishersON Titles.Pub_id = Publishers.Pub_id 外连接与普通连接的区别 普通连接操作只输出满足连接条件的元组 外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出： 子查询 将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为子查询。一个SELECT-FROM-WHERE语句称为一个查询块 1select sname from student where sno in (select studentid from sc where courseid=2); 123456查询选修了课程名为“Java”的学生学号和姓名select sno,sname from student where sno in (select studentid from sc where cno = (select cno from course where cname=‘Java’));` 赋值表 我们来创建一个副本 可以通过在SELECT查询中指定字段来限制出现在附表中的字段 通过使用SELECT 语句创建已存在表的空副本，并且返回一个空结果集]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL运算符]]></title>
    <url>%2F2013%2F01%2F28%2FDatabase%2F14.Mysql%20%E7%AE%80%E4%BB%8B%E4%B8%8ECURD%2F03%20-%20%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Mysql运算符 算术运算符 比较运算符 逻辑运算符 位运算符 算术运算符 用字符串表示的数字在任何可能便于计算的地方都被自动地转换为数字。当执行转换时，MySQL遵循两个基本规则 如果第一位是数字的字符串被用于一个算数运算中，那么它被转换为这个数字的值 如果一个包含字符和数字混合的字符串不能被正确的转换为数字，那么它被转换成0 比较运算符 比较运算符允许我们对表达式的左边和右边进行比较。一个比较运算符的结果总是1（真），0（假），或是为NULL（不能确定） 比较运算符可以用于比较数字和字符串。数字作为浮点值比较，而字符串以不区分大小写的方式进行比较（除非使用特殊的BINARY二进制关键字） 对于＜＞运算符，如果表达式两边不相等返回真值，相等返回假值。还可以比较字符串 BETWEEN运算符 用于检验一个值（或者一个求值表达式）是否存在一个指定的范围内 ＩＮ运算符用于检验一个值（或者一个求值表达式）是否包含在一个指定的值集合中 可以使用IS NULL或者IS NOT NULL运算符来测定是否为空。可以使用特殊的&lt;=&gt;运算符，MySQL称为”NULL安全的等于”运算符。这意味着即使当包含在比较运算符中的表达式含有一个NULL值时，MySQL也会为比较运算符返回一个真值或假值 如果想执行通配符数据搜索，应该使用LIKE运算符。它通过在表达式中允许使用专门的通配字符，可以找出与指定搜索字符串全部或部分匹配的记录。 默认情况下，比较是不区分大小写的方式执行的。然而，以前我们注意到，可以添加BINARY关键字让MySQL执行区分大小写的比较。 Mysql数据库中的通配符 “%” (百分号) 代表任意长度（长度可以为0）的字符串 a%b表示以a开头，以b结尾的任意长度的字符串。如acb，addgb，ab 等都满足该匹配串 “_ ”(下横线) 代表任意单个字符 a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb，afb等都满足该匹配串 REGEXP运算符 允许我们执行更复杂的字符串比较运算，在这里使用UNIX正则表达式 元字符 逻辑运算符 位运算符 “～” 表示按位取反 “^” 表示异或]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是SQL]]></title>
    <url>%2F2013%2F01%2F27%2FDatabase%2F14.Mysql%20%E7%AE%80%E4%BB%8B%E4%B8%8ECURD%2F02%20-%20SQL%2F</url>
    <content type="text"><![CDATA[什么是SQL 结构化查询语言(Structured Query Language)简称SQL(发音：/ˈes kjuː ˈel/ “S-Q-L”)，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名 操作数据库需要使用SQL语句，而并非Java SQL 分类 数据库定义语言(DDL - Data Definition Language) 用来创建删除数据库，表，列 关键字 create、alter、drop等 数据库操作语言(DML - Data Mainpulation Language) 用来更新表中的数据 关键字 insert、delete、update等 数据库查询语言(DQL - Data Query Language) 用来查询表中的数据 关键字 select、from、where等 数据库控制语言(DCL - Data Control language) 用来定义数据库的访问权限和安全级别 关键字 grant 等 SQL 语法 以分号结束 关键字建议使用大写 注释 / / 数据库操作 创建数据库 create database 数据库名字; create database unreal; create database 数据库名字 character set utf-8; create database unreal character set utf-8; 查看数据库 查看所有的数据库 show databases; 查看某一个数据库 show create database unreal; 删除数据库 drop database unreal; 进入数据库 use unreal; 查看正在使用的数据库 select database(); 数据类型 MySQL支持多种类型，大致可以分为三类： 数值 日期/时间 字符串(字符) 数值类型 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9 233 372 036 854 775 808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 浮点数值 浮点数值 浮点数值 浮点数值 DOUBLE 8 字节 (1.797 693 134 862 315 7 E+308，2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 浮点数值 浮点数值 浮点数值 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 日期和时间类型 类型 大小 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS YEAR 1 1901/2155 YYYY DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS TIMESTAMP 8 1970-01-01 00:00:00/2037 年某时 YYYYMMDD HHMMSS 字符串类型 类型 大小 用途 类型 CHAR 0-255字节 定长字符串 CHAR VARCHAR 0-65535 字节 变长字符串 VARCHAR TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYBLOB TINYTEXT 0-255字节 短文本字符串 TINYTEXT BLOB 0-65 535字节 二进制形式的长文本数据 BLOB TEXT 0-65 535字节 长文本数据 TEXT MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMBLOB MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 MEDIUMTEXT LOGNGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LOGNGBLOB LONGTEXT 0-4 294 967 295字节 极大文本数据 LONGTEXT 表操作 创建表 12345678910create table 表名( 字段名 类型(长度) 约束， 字段名 类型(长度) 约束 ...);create table student( sid int, sname varchar(20)); 主键约束 主键是用于标识当前记录的字段，它的特点是非空、唯一。在开发中一般情况下主键是不具备任何含义，只是用于标识当前记录 创建主键 在创建字段时创建主键 primary key 1234create table student( sid int primary key, sname varchar(20)); 在字段创建之后添加主键 12345create table student( sid int, sname varchar(20), primary key(sid)); 删除主键 alter table student drop primary key; 主键自动增长 sid int primary key auto_increment 查看表 show tables; 查看表结构 desc student; 删除表 drop table student; 修改表结构 添加列 alter table 表名 add 列名 类型 约束; alter table student add sage varchar(10); 修改列类型及约束 alter table 表名 modify 列名 类型 约束; alter table student modify sage int; 修改列名 alter table 表名 change 旧列名 新列名 类型 约束; 删除列名 alter table 表名 drop 列名; alter table student drop sage; 修改表名 rename table 旧表名 to 新表名; 修改表的字符集 alter table 表名 character set 字符集;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL简介与安装]]></title>
    <url>%2F2013%2F01%2F26%2FDatabase%2F14.Mysql%20%E7%AE%80%E4%BB%8B%E4%B8%8ECURD%2F01%20-%20Mysql%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[什么是数据库 数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据进行新增、截取、更新、删除等操作。 所谓“数据库”是以一定方式储存在一起、能与多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合 什么是数据库管理系统 数据库管理系统（英语：Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能 数据库管理系统可以依据它所支持的数据库模型来作分类，例如关系式、XML；或依据所支持的计算机类型来作分类，例如服务器群集、移动电话；或依据所用查询语言来作分类，例如SQL、XQuery；或依据性能冲量重点来作分类，例如最大规模、最高运行速度；亦或其他的分类方式。不论使用哪种分类方式，一些DBMS能够跨类别，例如，同时支持多种查询语言. 常见的数据库管理系统 Mysql 开源免费的数据库(由瑞典MySQL AB 公司开发)，已经被Oracle收购6.x版本开始收费 MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言 Oracle 收费的大型数据库，Oracle公司产品 DB2 IBM公司，收费。常见应用银行系统 SQLServer MicroSoft 公司，收费。C#、.net语言使用多。 Java相关的数据库 Mysql,Oracle 数据库与数据库管理系统的关系 我们操作的是表中的数据 表就看成Java的一个类 表中的列看成Java的属性 一行数据就看成这个对象(类似于重写toString方法，打印对象，多条数据就看成List) 安装- 上课演示 安装完成之后查看运行状态 可在服务里面查询 可以用命令(以管理员身份打开cmd窗口) 配置Mysql的环境变量与JDK一样 进入Mysql 格式: mysql -u用户名 -p密码 mysql -uroot -proot 回车 安装SQLyog- 上课演示 设置数据库局域网访问(可选操作) grant all privileges on . to ‘root‘@’%’ identified by ‘123456’; 恭喜你，安装成功!]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex 状态管理]]></title>
    <url>%2F2013%2F01%2F25%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F085.Vuex-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vuex 状态管理概述Vuex 是一个专为 Vue.js 应用程序开发的 状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 安装 在项目根目录执行如下命令来安装 Vuex 1npm install vuex --save --registry=https://registry.npm.taobao.org 修改 main.js 文件，导入 Vuex，关键代码如下： 12import Vuex from 'vuex'Vue.use(Vuex); 状态管理我们利用路由钩子 beforeEach 来判断用户是否登录，期间会用到 sessionStorage 存储功能 修改 Login.vue在表单验证成功方法内增加如下代码： 12// 设置用户登录成功sessionStorage.setItem('isLogin', 'true'); 修改 main.js利用路由钩子 beforeEach 方法判断用户是否成功登录，关键代码如下： 12345678910111213141516171819202122232425262728293031// 在跳转前执行router.beforeEach((to, form, next) =&gt; &#123; // 获取用户登录状态 let isLogin = sessionStorage.getItem('isLogin'); // 注销 if (to.path == '/logout') &#123; // 清空 sessionStorage.clear(); // 跳转到登录 next(&#123;path: '/login'&#125;); &#125; // 如果请求的是登录页 else if (to.path == '/login') &#123; if (isLogin != null) &#123; // 跳转到首页 next(&#123;path: '/main'&#125;); &#125; &#125; // 如果为非登录状态 else if (isLogin == null) &#123; // 跳转到登录页 next(&#123;path: '/login'&#125;); &#125; // 下一个路由 next();&#125;); 配置 Vuex 创建 Vuex 配置文件 在 src 目录下创建一个名为 store 的目录并新建一个名为 index.js 文件用来配置 Vuex，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex);// 全局 state 对象，用于保存所有组件的公共数据const state = &#123; // 定义一个 user 对象 // 在组件中是通过 this.$store.state.user 来获取 user: &#123; username: '' &#125;&#125;;// 实时监听 state 值的最新状态，注意这里的 getters 可以理解为计算属性const getters = &#123; // 在组件中是通过 this.$store.getters.getUser 来获取 getUser(state) &#123; return state.user; &#125;&#125;;// 定义改变 state 初始值的方法，这里是唯一可以改变 state 的地方，缺点是只能同步执行const mutations = &#123; // 在组件中是通过 this.$store.commit('updateUser', user); 方法来调用 mutations updateUser(state, user) &#123; state.user = user; &#125;&#125;;// 定义触发 mutations 里函数的方法，可以异步执行 mutations 里的函数const actions = &#123; // 在组件中是通过 this.$store.dispatch('asyncUpdateUser', user); 来调用 actions asyncUpdateUser(context, user) &#123; context.commit('updateUser', user); &#125;&#125;;export default new Vuex.Store(&#123; state, getters, mutations, actions&#125;); 修改 main.js 增加刚才配置的 store/index.js，关键代码如下： 12345678910import Vue from 'vue'import Vuex from 'vuex'import store from './store'Vue.use(Vuex);new Vue(&#123; el: '#app', store&#125;); 修改Login.vue登录成功后保存用户信息 1this.$store.dispatch("asyncUpdateUser", thisObj.user); 其它页面显示状态管理里面的存值 1&#123;&#123;this.$store.getters.getUser.username&#125;&#125; 浏览器刷新 Vuex 数据消失问题描述Vuex 的状态存储是响应式的，当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。但是有一个问题就是：vuex 的存储的数据只是在页面的中，相当于我们定义的全局变量，刷新之后，里边的数据就会恢复到初始化状态。但是这个情况有时候并不是我们所希望的。 解决方案监听页面是否刷新，如果页面刷新了，将 state 对象存入到 sessionStorage 中。页面打开之后，判断 sessionStorage 中是否存在 state 对象，如果存在，则说明页面是被刷新过的，将 sessionStorage 中存的数据取出来给 vuex 中的 state 赋值。如果不存在，说明是第一次打开，则取 vuex 中定义的 state 初始值。 修改代码在 App.vue 中增加监听刷新事件 1234567891011export default &#123; name: 'App', mounted() &#123; window.addEventListener('unload', this.saveState); &#125;, methods: &#123; saveState() &#123; sessionStorage.setItem('state', JSON.stringify(this.$store.state)); &#125; &#125;&#125; 修改 store/index.js 中的 state 12345const state = sessionStorage.getItem('state') ? JSON.parse(sessionStorage.getItem('state')) : &#123; user: &#123; username: '' &#125;&#125;; 模块化由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 创建 user 模块在 store 目录下创建一个名为 modules 的目录并创建一个名为 user.js 的文件，代码如下： 12345678910111213141516171819202122232425const user = &#123; // 因为模块化了，所以解决刷新问题的代码需要改造一下 state: sessionStorage.getItem('userState') ? JSON.parse(sessionStorage.getItem('userState')) : &#123; user: &#123; username: '' &#125; &#125;, getters: &#123; getUser(state) &#123; return state.user; &#125; &#125;, mutations: &#123; updateUser(state, user) &#123; state.user = user; &#125; &#125;, actions: &#123; asyncUpdateUser(context, user) &#123; context.commit('updateUser', user); &#125; &#125;&#125;;export default user; 修改 store/index.js12345678910111213import Vue from 'vue'import Vuex from 'vuex'import user from './modules/user'Vue.use(Vuex);export default new Vuex.Store(&#123; modules: &#123; // this.$store.state.user user &#125;&#125;); 备注： 由于组件中使用的是 getters 和 actions 处理，所以调用代码不变 修改 App.vue123456789101112export default &#123; name: 'App', mounted() &#123; window.addEventListener('unload', this.saveState); &#125;, methods: &#123; saveState() &#123; // 模块化后，调用 state 的代码修改为 this.$store.state.user sessionStorage.setItem('userState', JSON.stringify(this.$store.state.user)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter 路由钩子与异步请求]]></title>
    <url>%2F2013%2F01%2F24%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F084.VueRouter-%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[路由钩子与异步请求路由中的钩子函数 beforeRouteEnter：在进入路由前执行 beforeRouteLeave：在离开路由前执行 案例代码如下： 123456789101112export default &#123; props: ['id'], name: "UserProfile", beforeRouteEnter: (to, from, next) =&gt; &#123; console.log("准备进入个人信息页"); next(); &#125;, beforeRouteLeave: (to, from, next) =&gt; &#123; console.log("准备离开个人信息页"); next(); &#125;&#125; 参数说明： to：路由将要跳转的路径信息 from：路径跳转前的路径信息 next：路由的控制参数 next() 跳入下一个页面 next(&#39;/path&#39;) 改变路由的跳转方向，使其跳到另一个路由 next(false) 返回原来的页面 next((vm)=&gt;{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例 在钩子函数中使用异步请求安装 Axios 1npm install axios -s --registry=https://registry.npm.taobao.org 引用 Axios 12import axios from 'axios'Vue.prototype.axios = axios; 在 beforeRouteEnter 中进行异步请求，案例代码如下： 123456789101112131415161718192021222324252627export default &#123; props: ['id'], name: "UserProfile", beforeRouteEnter: (to, from, next) =&gt; &#123; console.log("准备进入个人信息页"); // 注意，一定要在 next 中请求，因为该方法调用时 Vue 实例还没有创建，此时无法获取到 this 对象，在这里使用官方提供的回调函数拿到当前实例 next(vm =&gt; &#123; vm.getData(); &#125;); &#125;, beforeRouteLeave: (to, from, next) =&gt; &#123; console.log("准备离开个人信息页"); next(); &#125;, methods: &#123; getData: function () &#123; this.axios(&#123; method: 'get', url: 'http://localhost:8080/static/data.json' &#125;).then(function (repos) &#123; console.log(repos); &#125;).catch(function (error) &#123; console.log(error); &#125;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter 路由模式与404]]></title>
    <url>%2F2013%2F01%2F23%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F083.VueRouter-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E4%B8%8E%20404%2F</url>
    <content type="text"><![CDATA[路由模式与 404路由模式路由模式有两种 hash：路径带 # 符号，如 http://localhost/#/login history：路径不带 # 符号，如 http://localhost/login 修改路由配置，代码如下： 12345export default new Router(&#123; mode: 'history', routes: [ ]&#125;); 处理 404创建一个名为 NotFound.vue 的视图组件，代码如下： 123456789101112131415&lt;template&gt; &lt;div&gt; 页面不存在，请重试！ &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;NotFount&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 修改路由配置，代码如下： 1234&#123; path: '*', component: NotFound&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter 参数传递与重定向]]></title>
    <url>%2F2013%2F01%2F22%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F082.VueRouter-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[VueRouter 参数传递与重定向参数传递我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了； 使用路径匹配的方式 修改路由配置，主要是在 path 属性中增加了 :id 这样的占位符 1&#123;path: '/user/profile/:id', name:'UserProfile', component: UserProfile&#125; router-link 方式传递 1&lt;router-link :to=&quot;&#123;name: &apos;UserProfile&apos;, params: &#123;id: 1&#125;&#125;&quot;&gt;个人信息&lt;/router-link&gt; 注意： 此时我们将 to 改为了 :to，是为了将这一属性当成对象(Model)使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径； 代码方式传递 1this.$router.push(&#123; name: 'UserProfile', params: &#123;id: 1&#125;&#125;); 在目标组件中使用以下方式接收参数 1&#123;&#123; $route.params.id &#125;&#125; 使用 props 的方式 修改路由配置，主要增加了 props: true 属性 1&#123;path: '/user/profile/:id', name:'UserProfile', component: UserProfile, props: true&#125; router-link 方式传递 1&lt;router-link :to=&quot;&#123;name: &apos;UserProfile&apos;, params: &#123;id: 1&#125;&#125;&quot;&gt;个人信息&lt;/router-link&gt; 代码方式传递 1this.$router.push(&#123; name: 'UserProfile', params: &#123;id: 1&#125;&#125;); 接收参数，为目标组件增加 props 属性 1234export default &#123; props: ['id'], name: "UserProfile"&#125; 模板中使用接收参数 1&#123;&#123; id &#125;&#125; 重定向重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下 修改路由配置123456789&#123; path: '/main', name: 'Main', component: Main&#125;,&#123; path: '/goHome', redirect: '/main'&#125; 说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件； 重定向到组件设置对应路径即可 1&lt;router-link to=&quot;/goHome&quot;&gt;回到首页&lt;/router-link&gt; 带参数的重定向 修改路由配置 12345678910&#123; // 首页 path: '/main/:username', name: 'Main', component: Main&#125;,&#123; path: '/goHome/:username', redirect: '/main/:username'&#125; 重定向到组件 1&lt;router-link to=&quot;/goHome/Lusifer&quot;&gt;回到首页&lt;/router-link&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter 嵌套路由]]></title>
    <url>%2F2013%2F01%2F21%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F081.VueRouter-%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[VueRouter 嵌套路由什么是嵌套路由嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如： 12345678/user/foo/profile /user/foo/posts+------------------+ +-----------------+| User | | User || +--------------+ | | +-------------+ || | Profile | | +------------&gt; | | Posts | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ 创建嵌套视图组件用户信息组件在 views/user 目录下创建一个名为 Profile.vue 的视图组件；该组件在当前章节无任何作用，主要用于展示嵌套效果； 123456789101112131415&lt;template&gt; &lt;div&gt; 个人信息 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;UserProfile&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件；该组件在当前章节无任何作用，主要用于展示嵌套效果； 123456789101112131415&lt;template&gt; &lt;div&gt; 用户列表 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;UserList&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 配置嵌套路由修改 router 目录下的 index.js 路由配置文件，代码如下： 123456789101112131415161718192021222324252627282930313233import Vue from 'vue'import Router from 'vue-router'import Login from "../views/Login"import Main from '../views/Main'// 用于嵌套的路由组件import UserProfile from '../views/user/Profile'import UserList from '../views/user/List'Vue.use(Router);export default new Router(&#123; routes: [ &#123; // 登录页 path: '/login', name: 'Login', component: Login &#125;, &#123; // 首页 path: '/main', name: 'Main', component: Main, // 配置嵌套路由 children: [ &#123;path: '/user/profile', component: UserProfile&#125;, &#123;path: '/user/list', component: UserList&#125;, ] &#125; ]&#125;); 说明：主要在路由配置中增加了 children 数组配置，用于在该组件下设置嵌套路由 修改首页视图接着上一节的代码，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt; &lt;el-menu :default-openeds=&quot;[&apos;1&apos;]&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-caret-right&quot;&gt;&lt;/i&gt;用户管理&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt; &lt;router-link to=&quot;/user/profile&quot;&gt;个人信息&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt; &lt;router-link to=&quot;/user/list&quot;&gt;用户列表&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-caret-right&quot;&gt;&lt;/i&gt;内容管理&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;2-1&quot;&gt;分类管理&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-2&quot;&gt;内容列表&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header style=&quot;text-align: right; font-size: 12px&quot;&gt; &lt;el-dropdown&gt; &lt;i class=&quot;el-icon-setting&quot; style=&quot;margin-right: 15px&quot;&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item&gt;个人信息&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;退出登录&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;span&gt;Lusifer&lt;/span&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;router-view /&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Main&quot; &#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt; .el-header &#123; background-color: #B3C0D1; color: #333; line-height: 60px; &#125; .el-aside &#123; color: #333; &#125;&lt;/style&gt; 说明： 在 &lt;el-main&gt; 元素中配置了 &lt;router-view /&gt; 用于展示嵌套路由 主要使用 &lt;router-link to=&quot;/user/profile&quot;&gt;个人信息&lt;/router-link&gt; 展示嵌套路由内容 效果演示]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter第一个工程]]></title>
    <url>%2F2013%2F01%2F20%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F080.VueRouter-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[VueRouter 第一个工程概述我们结合 ElementUI 组件库，将所需知识点应用到实际中，以最快速度带领大家掌握 Vue 的使用 创建工程 注意： 使用 NPM 安装相关组件依赖时可能会遇到权限问题，此时使用 PowerShell 管理员模式运行即可；开始菜单 -&gt; 鼠标右击 -&gt; Windows PowerShell (管理员) 创建一个名为 hello-vue-element 的工程 12# 使用 webpack 打包工具初始化一个名为 hello-vue-element 的工程vue init webpack hello-vue-element 安装依赖我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件 12345678# 进入工程目录cd hello-vue-element# 安装 vue-routernpm install vue-router --save-dev --registry=https://registry.npm.taobao.org# 安装 element-uinpm i element-ui -S --registry=https://registry.npm.taobao.org# 安装 SASS 加载器npm install sass-loader node-sass --save-dev --registry=https://registry.npm.taobao.org 12# 安装依赖npm install --registry=https://registry.npm.taobao.org 启动项目1npm run dev 运行项目在浏览器打开 http://localhost:8080 第一个 ElementUI 页面目录结构在源码目录中创建如下结构： assets：用于存放资源文件 components：用于存放 Vue 功能组件 views：用于存放 Vue 视图组件 router：用于存放 vue-router 配置 创建首页视图在 views 目录下创建一个名为 Main.vue 的视图组件；该组件在当前章节无任何作用，主要用于登录后展示登录成功的跳转效果； 123456789101112131415&lt;template&gt; &lt;div&gt; 首页 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Main&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 创建登录页视图在 views 目录下创建一个名为 Login.vue 的视图组件，其中 el-* 的元素为 ElementUI 组件； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;template&gt; &lt;div&gt; &lt;el-form ref=&quot;loginForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot; class=&quot;login-box&quot;&gt; &lt;h3 class=&quot;login-title&quot;&gt;欢迎登录&lt;/h3&gt; &lt;el-form-item label=&quot;账号&quot; prop=&quot;username&quot;&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;form.username&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;form.password&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; v-on:click=&quot;onSubmit(&apos;loginForm&apos;)&quot;&gt;登录&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-dialog title=&quot;温馨提示&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&gt; &lt;span&gt;请输入账号和密码&lt;/span&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Login&quot;, data() &#123; return &#123; form: &#123; username: &apos;&apos;, password: &apos;&apos; &#125;, // 表单验证，需要在 el-form-item 元素中增加 prop 属性 rules: &#123; username: [ &#123;required: true, message: &apos;账号不可为空&apos;, trigger: &apos;blur&apos;&#125; ], password: [ &#123;required: true, message: &apos;密码不可为空&apos;, trigger: &apos;blur&apos;&#125; ] &#125;, // 对话框显示和隐藏 dialogVisible: false &#125; &#125;, methods: &#123; onSubmit(formName) &#123; // 为表单绑定验证功能 this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; // 使用 vue-router 路由到指定页面，该方式称之为编程式导航 this.$router.push(&quot;/main&quot;); &#125; else &#123; this.dialogVisible = true; return false; &#125; &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; .login-box &#123; border: 1px solid #DCDFE6; width: 350px; margin: 180px auto; padding: 35px 35px 15px 35px; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; box-shadow: 0 0 25px #909399; &#125; .login-title &#123; text-align: center; margin: 0 auto 40px auto; color: #303133; &#125;&lt;/style&gt; 创建路由在 router 目录下创建一个名为 index.js 的 vue-router 路由配置文件 123456789101112131415161718192021222324import Vue from 'vue'import Router from 'vue-router'import Login from "../views/Login"import Main from '../views/Main'Vue.use(Router);export default new Router(&#123; routes: [ &#123; // 登录页 path: '/login', name: 'Login', component: Login &#125;, &#123; // 首页 path: '/main', name: 'Main', component: Main &#125; ]&#125;); 配置路由 修改 main.js 入口代码 1234567891011121314151617181920212223import Vue from 'vue'import VueRouter from 'vue-router'import router from './router'// 导入 ElementUIimport ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import App from './App'// 安装路由Vue.use(VueRouter);// 安装 ElementUIVue.use(ElementUI);new Vue(&#123; el: '#app', // 启用路由 router, // 启用 ElementUI render: h =&gt; h(App)&#125;); 修改 App.vue 组件代码 1234567891011&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;App&apos;, &#125;&lt;/script&gt; 效果演示在浏览器打开 http://localhost:8080/#/login 你会看到如下效果 附：扩展阅读NPM 相关命令说明 npm install moduleName：安装模块到项目目录下 npm install -g moduleName：-g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置 npm install -save moduleName：--save 的意思是将模块安装到项目目录下，并在 package 文件的 dependencies 节点写入依赖，-S 为该命令的缩写 npm install -save-dev moduleName：--save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devDependencies 节点写入依赖，-D 为该命令的缩写]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter 第一个路由]]></title>
    <url>%2F2013%2F01%2F19%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F079.VueRouter-%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[VueRouter 第一个路由概述Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有： 嵌套的路由/视图表 模块化的、基于组件的路由配置 路由参数、查询、通配符 基于 Vue.js 过渡系统的视图过渡效果 细粒度的导航控制 带有自动激活的 CSS class 的链接 HTML5 历史模式或 hash 模式，在 IE9 中自动降级 自定义的滚动条行为 安装vue-router 是一个插件包，所以我们还是需要用 npm/cnpm 来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。 1234567891011npm install vue-router --save-dev --registry=https://registry.npm.taobao.org# 输出如下npm WARN ajv-keywords@3.4.1 requires a peer of ajv@^6.9.1 but none is installed. You must install peer dependencies yourself.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)+ vue-router@3.0.7added 1 package from 1 contributor and audited 11766 packages in 11.33sfound 10 vulnerabilities (6 moderate, 4 high) run `npm audit fix` to fix them, or `npm audit` for details 如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能： 1234import Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter); 使用以下案例在 vue-cli 项目中使用 vue-router 创建组件页面创建一个名为 src/components 的目录专门放置我们开发的 Vue 组件，在 src/components 目录下创建一个名为 Content.vue 的组件，代码如下： 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; 我是内容页 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Content&quot; &#125;&lt;/script&gt;&lt;style&gt; #app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; &#125;&lt;/style&gt; 安装路由创建一个名为 src/router 的目录专门放置我们的路由配置代码，在 src/router 目录下创建一个名为 index.js 路由配置文件，代码如下： 12345678910111213141516171819202122import Vue from 'vue'// 导入路由插件import Router from 'vue-router'// 导入上面定义的组件import Content from '@/components/Content'// 安装路由Vue.use(Router);// 配置路由export default new Router(&#123; routes: [ &#123; // 路由路径 path: '/content', // 路由名称 name: 'Content', // 跳转到组件 component: Content &#125; ]&#125;); 配置路由修改 main.js 入口文件，增加配置路由的相关代码 1234567891011121314import Vue from 'vue'import App from './App'// 导入上面创建的路由配置目录import router from './router'Vue.config.productionTip = false;new Vue(&#123; el: '#app', // 配置路由 router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;); 使用路由修改 App.vue 组件，代码如下： 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/content&quot;&gt;内容&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;App&apos;&#125;&lt;/script&gt;&lt;style&gt; #app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; &#125;&lt;/style&gt; 说明： router-link： 默认会被渲染成一个 &lt;a&gt; 标签，to 属性为指定链接 router-view： 用于渲染路由匹配到的组件 效果演示]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueCli]]></title>
    <url>%2F2013%2F01%2F18%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F078.Vue-VueCli%2F</url>
    <content type="text"><![CDATA[VueCli什么是 vue-clivue-cli 官方提供的一个脚手架（预先定义好的目录结构及基础代码，咱们在创建 Maven 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架）用于快速生成一个 vue 的项目模板 统一的目录结构 本地调试 热部署 单元测试 集成打包上线 安装环境准备 Node.js（&gt;= 6.x，首选 8.x） git 安装 Node.js请自行前往 http://nodejs.cn/download 官网下载安装，此处不再赘述 安装 vue-cli123456789npm install vue-cli -g --registry=https://registry.npm.taobao.org# 输出如下npm WARN deprecated coffee-script@1.12.7: CoffeeScript on NPM has moved to "coffeescript" (no hyphen)C:\Users\Administrator\AppData\Roaming\npm\vue -&gt; C:\Users\Administrator\AppData\Roaming\npm\node_modules\vue-cli\bin\vueC:\Users\Administrator\AppData\Roaming\npm\vue-init -&gt; C:\Users\Administrator\AppData\Roaming\npm\node_modules\vue-cli\bin\vue-initC:\Users\Administrator\AppData\Roaming\npm\vue-list -&gt; C:\Users\Administrator\AppData\Roaming\npm\node_modules\vue-cli\bin\vue-list+ vue-cli@2.9.6added 241 packages from 206 contributors in 24.481s 测试是否安装成功123456789101112# 查看可以基于哪些模板创建 vue 应用程序，通常我们选择 webpackvue list# 输出如下Available official templates:★ browserify - A full-featured Browserify + vueify setup with hot-reload, linting &amp; unit testing.★ browserify-simple - A simple Browserify + vueify setup for quick prototyping.★ pwa - PWA template for vue-cli based on the webpack template★ simple - The simplest possible Vue setup in a single HTML file★ webpack - A full-featured Webpack + vue-loader setup with hot reload, linting, testing &amp; css extraction.★ webpack-simple - A simple Webpack + vue-loader setup for quick prototyping. 第一个 vue-cli 应用程序创建一个基于 webpack 模板的 vue 应用程序 1234567891011121314151617181920212223242526# 这里的 hello-vue-cli 是项目名称，可以根据自己的需求起名vue init webpack hello-vue-cli# 输出如下? Project name hello-vue-cli? Project description A Vue.js project? Author Lusifer &lt;topsale@vip.qq.com&gt;? Vue build standalone? Install vue-router? No? Use ESLint to lint your code? No? Set up unit tests No? Setup e2e tests with Nightwatch? No? Should we run `npm install` for you after the project has been created? (recommended) no vue-cli · Generated "hello-vue-cli".# Project initialization finished!# ========================To get started: cd hello-vue-cli npm install (or if using yarn: yarn) npm run devDocumentation can be found at https://vuejs-templates.github.io/webpack 说明 Project name：项目名称，默认 回车 即可 Project description：项目描述，默认 回车 即可 Author：项目作者，默认 回车 即可 Install vue-router：是否安装 vue-router，选择 n 不安装（后期需要再手动添加） Use ESLint to lint your code：是否使用 ESLint 做代码检查，选择 n 不安装（后期需要再手动添加） Set up unit tests：单元测试相关，选择 n 不安装（后期需要再手动添加） Setup e2e tests with Nightwatch：单元测试相关，选择 n 不安装（后期需要再手动添加） Should we run npm install for you after the project has been created：创建完成后直接初始化，选择 n，我们手动执行 初始化并运行123456789101112131415161718192021222324252627282930313233343536373839# 初始化cd hello-vue-clinpm install --registry=https://registry.npm.taobao.org# 输出如下npm WARN deprecated browserslist@2.11.3: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.npm WARN deprecated bfj-node4@5.3.1: Switch to the `bfj` package for fixes and new features!npm WARN deprecated browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.&gt; core-js@2.6.9 postinstall D:\Workspace\Study\other\hello-vue-cli\node_modules\core-js&gt; node scripts/postinstall || echo "ignore"Thank you for using core-js ( https://github.com/zloirock/core-js ) for polyfilling JavaScript standard library!The project needs your help! Please consider supporting of core-js on Open Collective or Patreon:&gt; https://opencollective.com/core-js&gt; https://www.patreon.com/zloirockAlso, the author of core-js ( https://github.com/zloirock ) is looking for a good job -)&gt; uglifyjs-webpack-plugin@0.4.6 postinstall D:\Workspace\Study\other\hello-vue-cli\node_modules\webpack\node_modules\uglifyjs-webpack-plugin&gt; node lib/post_install.jsnpm notice created a lockfile as package-lock.json. You should commit this file.npm WARN ajv-keywords@3.4.1 requires a peer of ajv@^6.9.1 but none is installed. You must install peer dependencies yourself.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)added 1207 packages from 667 contributors and audited 11765 packages in 81.571sfound 10 vulnerabilities (6 moderate, 4 high) run `npm audit fix` to fix them, or `npm audit` for details# 运行npm run dev# 输出如下 DONE Compiled successfully in 3226ms I Your application is running here: http://localhost:8080 安装并运行成功后在浏览器输入：http://localhost:8080 目录结构 build 和 config：WebPack 配置文件 node_modules：用于存放 npm install 安装的依赖文件 src：项目源码目录 static：静态资源文件 .babelrc：Babel 配置文件，主要作用是将 ES6 转换为 ES5 .editorconfig：编辑器配置 eslintignore：需要忽略的语法检查配置文件 .gitignore：git 忽略的配置文件 .postcssrc.js：css 相关配置文件，其中内部的 module.exports 是 NodeJS 模块化语法 index.html：首页，仅作为模板页，实际开发时不使用 package.json：项目的配置文件 name：项目名称 version：项目版本 description：项目描述 author：项目作者 scripts：封装常用命令 dependencies：生产环境依赖 devDependencies：开发环境依赖 源码目录12345678│ App.vue│ main.js│├─assets│ logo.png│└─components HelloWorld.vue main.js项目的入口文件，我们知道所有的程序都会有一个入口 12345678910111213// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) import Vue from &#39;vue&#39;：ES6 写法，会被转换成 require(&quot;vue&quot;); （require 是 NodeJS 提供的模块加载器） import App from &#39;./App&#39;：意思同上，但是指定了查找路径，./ 为当前目录 Vue.config.productionTip = false：关闭浏览器控制台关于环境的相关提示 new Vue({...})：实例化 Vue el: &#39;#app&#39;：查找 index.html 中 id 为 app 的元素 template: &#39;&lt;App/&gt;&#39;：模板，会将 index.html 中 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 替换为 &lt;App /&gt; components: { App }：引入组件，使用的是 import App from &#39;./App&#39; 定义的 App 组件 App.vue组件模板 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &apos;./components/HelloWorld&apos;export default &#123; name: &apos;App&apos;, components: &#123; HelloWorld &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; &lt;!-- 字体 --&gt; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; &lt;!-- 文字平滑效果 --&gt; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; template：HTML 代码模板，会替换 &lt;App /&gt; 中的内容 import HelloWorld from &#39;./components/HelloWorld&#39;：引入 HelloWorld 组件，用于替换 template 中的 &lt;HelloWorld/&gt; export default{...}：导出 NodeJS 对象，作用是可以通过 import 关键字导入 name: &#39;App&#39;：定义组件的名称 components: { HelloWorld }：定义子组件 HelloWorld.vue基本同上，不解释.. 关于 &lt;style scoped&gt; 的说明：CSS 样式仅在当前组件有效，声明了样式的作用域]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 内容分发与自定义事件]]></title>
    <url>%2F2013%2F01%2F17%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F077.Vue-%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Vue 内容分发与自定义事件Vue 中的内容分发在 Vue.js 中我们使用 &lt;slot&gt; 元素作为承载分发内容的出口，作者称其为 插槽，可以应用在组合组件的场景中 利用插槽功能实现一个组合组件比如准备制作一个待办事项组件（todo），该组件由待办标题（todo-title）和待办内容（todo-items）组成，但这三个组件又是相互独立的，该如何操作呢？ 定义一个名为 todo 的待办事项组件12345678Vue.component('todo', &#123; template: '&lt;div&gt;\ &lt;slot name="todo-title"&gt;&lt;/slot&gt;\ &lt;ul&gt;\ &lt;slot name="todo-items"&gt;&lt;/slot&gt;\ &lt;/ul&gt;\ &lt;/div&gt;'&#125;); 该组件中放置了两个插槽，分别为 todo-title 和 todo-items 定义一个名为 todo-title 的待办标题组件1234Vue.component('todo-title', &#123; props: ['title'], template: '&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;'&#125;); 定义一个名为 todo-items 的待办内容组件1234Vue.component('todo-items', &#123; props: ['item', 'index'], template: '&lt;li&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;item&#125;&#125;&lt;/li&gt;'&#125;); 实例化 Vue 并初始化数据123456var vm = new Vue(&#123; el: '#vue', data: &#123; todoItems: ['《刀剑神域3》', '《关于我转生成为史莱姆这件事》', '《实力至上主义教室》'] &#125;&#125;); HTML123456&lt;div id="vue"&gt; &lt;todo&gt; &lt;todo-title slot="todo-title" title="今日动漫推荐"&gt;&lt;/todo-title&gt; &lt;todo-items slot="todo-items" v-for="(item, index) in todoItems" v-bind:item="item" v-bind:index="index" :key="index"&gt;&lt;/todo-items&gt; &lt;/todo&gt;&lt;/div&gt; 此时，我们的 todo-title 和 todo-items 组件分别被分发到了 todo 组件的 todo-title 和 todo-items 插槽中 测试效果 使用自定义事件删除待办事项通过以上代码不难发现，数据项在 Vue 的实例中，但删除操作要在组件中完成，那么组件如何才能删除 Vue 实例中的数据呢？此时就涉及到参数传递与事件分发了，Vue 为我们提供了自定义事件的功能很好的帮助我们解决了这个问题；使用 this.$emit(&#39;自定义事件名&#39;, 参数)，操作过程如下 修改创建 Vue 实例代码1234567891011121314var vm = new Vue(&#123; el: '#vue', data: &#123; todoItems: ['《刀剑神域3》', '《关于我转生成为史莱姆这件事》', '《实力至上主义教室》'] &#125;, methods: &#123; // 该方法可以被模板中自定义事件触发 removeTodoItems: function (index) &#123; console.log("删除 " + this.todoItems[index] + " 成功"); // splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目，其中 index 为添加/删除项目的位置，1 表示删除的数量 this.todoItems.splice(index, 1); &#125; &#125;&#125;); 增加了 methods 对象并定义了一个名为 removeTodoItems 的方法 修改 todo-items 待办内容组件的代码12345678910Vue.component('todo-items', &#123; props: ['item', 'index'], template: '&lt;li&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;item&#125;&#125; &lt;button @click="remove"&gt;删除&lt;/button&gt;&lt;/li&gt;', methods: &#123; remove: function (index) &#123; // 这里的 remove 是自定义事件的名称，需要在 HTML 中使用 v-on:remove 的方式指派 this.$emit('remove', index); &#125; &#125;&#125;); 增加了 &lt;button @click=&quot;remove&quot;&gt;删除&lt;/button&gt; 元素并绑定了组件中定义的 remove 事件 修改 todo-items 待办内容组件的 HTML 代码1&lt;todo-items slot="todo-items" v-for="(item, index) in todoItems" v-bind:item="item" v-bind:index="index" :key="index" v-on:remove="removeTodoItems(index)"&gt;&lt;/todo-items&gt; 增加了 v-on:remove=&quot;removeTodoItems(index)&quot; 自定义事件，该事件会调用 Vue 实例中定义的名为 removeTodoItems 的方法 测试效果 完整的 HTML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;布局篇 内容分发与自定义事件&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;todo&gt; &lt;todo-title slot="todo-title" title="今日动漫推荐"&gt;&lt;/todo-title&gt; &lt;todo-items slot="todo-items" v-for="(item, index) in todoItems" v-bind:item="item" v-bind:index="index" :key="index" v-on:remove="removeTodoItems(index)"&gt;&lt;/todo-items&gt; &lt;/todo&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; // 定义一个待办事项组件 Vue.component('todo', &#123; template: '&lt;div&gt;\ &lt;slot name="todo-title"&gt;&lt;/slot&gt;\ &lt;ul&gt;\ &lt;slot name="todo-items"&gt;&lt;/slot&gt;\ &lt;/ul&gt;\ &lt;/div&gt;' &#125;); // 定义一个待办事项标题组件 Vue.component('todo-title', &#123; props: ['title'], template: '&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' &#125;); // 定义一个待办事项内容组件 Vue.component('todo-items', &#123; props: ['item', 'index'], template: '&lt;li&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;item&#125;&#125; &lt;button @click="remove"&gt;删除&lt;/button&gt;&lt;/li&gt;', methods: &#123; remove: function (index) &#123; this.$emit('remove', index); &#125; &#125; &#125;); var vm = new Vue(&#123; el: '#vue', data: &#123; todoItems: ['《刀剑神域3》', '《关于我转生成为史莱姆这件事》', '《实力至上主义教室》'] &#125;, methods: &#123; // 该方法可以被模板中自定义事件触发 removeTodoItems: function (index) &#123; console.log("删除 " + this.todoItems[index] + " 成功"); this.todoItems.splice(index, 1); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 计算属性]]></title>
    <url>%2F2013%2F01%2F16%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F076.Vue-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Vue 计算属性什么是计算属性计算属性的重点突出在 属性 两个字上（属性是名词），首先它是个 属性 其次这个属性有 计算 的能力（计算是动词），这里的 计算 就是个函数；简单点说，它就是一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性），仅此而已； 计算属性与方法的区别完整的 HTML1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;布局篇 计算属性&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;p&gt;调用当前时间的方法：&#123;&#123;currentTime1()&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间的计算属性：&#123;&#123;currentTime2&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; message: 'Hello Vue' &#125;, methods: &#123; currentTime1: function () &#123; return Date.now(); &#125; &#125;, computed: &#123; currentTime2: function () &#123; this.message; return Date.now(); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 说明 methods：定义方法，调用方法使用 currentTime1()，需要带括号 computed：定义计算属性，调用属性使用 currentTime2，不需要带括号；this.message 是为了能够让 currentTime2 观察到数据变化而变化 注意： methods 和 computed 里不能重名 测试效果仔细看图中说明，观察其中的差异 结论调用方法时，每次都需要进行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这一点；计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 组件基础]]></title>
    <url>%2F2013%2F01%2F15%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F075.Vue-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Vue 组件基础什么是组件组件是可复用的 Vue 实例，说白了就是一组可以重复使用的模板，跟 JSTL 的自定义标签、Thymeleaf 的 th:fragment 以及 Sitemesh3 框架有着异曲同工之妙。通常一个应用会以一棵嵌套的组件树的形式来组织： 例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。 第一个 Vue 组件 注意：在实际开发中，我们并不会用以下方式开发组件，而是采用 vue-cli 创建 .vue 模板文件的方式开发，以下方法只是为了让大家理解什么是组件。 使用 Vue.component() 方法注册组件JavaScript1234567891011&lt;script type="text/javascript"&gt; // 先注册组件 Vue.component('my-component-li', &#123; template: '&lt;li&gt;Hello li&lt;/li&gt;' &#125;); // 再实例化 Vue var vm = new Vue(&#123; el: '#vue' &#125;);&lt;/script&gt; HTML12345&lt;div id="vue"&gt; &lt;ul&gt; &lt;my-component-li&gt;&lt;/my-component-li&gt; &lt;/ul&gt;&lt;/div&gt; 说明 Vue.component()：注册组件 my-component-li：自定义组件的名字 template：组件的模板 测试效果 使用 props 属性传递参数像上面那样用组件没有任何意义，所以我们是需要传递参数到组件的，此时就需要使用 props 属性了 注意： 默认规则下 props 属性里的值不能为大写；感谢来自 Java微服务技术交流群2 的群友 [CV战士蛋蛋面] 帮助大家踩坑； JavaScript123456789101112131415&lt;script type="text/javascript"&gt; // 先注册组件 Vue.component('my-component-li', &#123; props: ['item'], template: '&lt;li&gt;Hello &#123;&#123;item&#125;&#125;&lt;/li&gt;' &#125;); // 再实例化 Vue var vm = new Vue(&#123; el: '#vue', data: &#123; items: ["张三", "李四", "王五"] &#125; &#125;);&lt;/script&gt; HTML12345&lt;div id="vue"&gt; &lt;ul&gt; &lt;my-component-li v-for="item in items" v-bind:item="item"&gt;&lt;/my-component-li&gt; &lt;/ul&gt;&lt;/div&gt; 说明 v-for=&quot;item in items&quot;：遍历 Vue 实例中定义的名为 items 的数组，并创建同等数量的组件 v-bind:item=&quot;item&quot;：将遍历的 item 项绑定到组件中 props 定义的名为 item 属性上；= 号左边的 item 为 props 定义的属性名，右边的为 item in items 中遍历的 item 项的值 测试效果 完整的 HTML1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;布局篇 组件基础&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;ul&gt; &lt;my-component-li v-for="item in items" v-bind:item="item"&gt;&lt;/my-component-li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; // 先注册组件 Vue.component('my-component-li', &#123; props: ['item'], template: '&lt;li&gt;Hello &#123;&#123;item&#125;&#125;&lt;/li&gt;' &#125;); // 再实例化 Vue var vm = new Vue(&#123; el: '#vue', data: &#123; items: ["张三", "李四", "王五"] &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 表单输入]]></title>
    <url>%2F2013%2F01%2F14%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F074.Vue-%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Vue 表单输入什么是双向数据绑定Vue.js 是一个 MVVM 框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是 Vue.js 的精髓之处了。值得注意的是，我们所说的数据双向绑定，一定是对于 UI 控件来说的，非 UI 控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用 vuex，那么数据流也是单项的，这时就会和双向数据绑定有冲突。 为什么要实现数据的双向绑定在 Vue.js 中，如果使用 vuex，实际上数据还是单向的，之所以说是数据双向绑定，这是用的 UI 控件来说，对于我们处理表单，Vue.js 的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项，方便跟踪；局部性数据流使用双向，简单易操作。 在表单中使用双向数据绑定你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 注意： v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 单行文本123&lt;div id="vue"&gt; 单行文本：&lt;input type="text" v-model="message" /&gt;&amp;nbsp;&amp;nbsp;单行文本是：&#123;&#123;message&#125;&#125;&lt;/div&gt; 12345678&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; message: "Hello Vue" &#125; &#125;);&lt;/script&gt; 多行文本123&lt;div id="vue"&gt; 多行文本：&lt;textarea v-model="message"&gt;&lt;/textarea&gt;&amp;nbsp;&amp;nbsp;多行文本是：&#123;&#123;message&#125;&#125;&lt;/div&gt; 12345678&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; message: "Hello Textarea" &#125; &#125;);&lt;/script&gt; 单复选框123&lt;div id="vue"&gt; 单复选框：&lt;input type="checkbox" id="checkbox" v-model="checked"&gt;&amp;nbsp;&amp;nbsp;&lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;&lt;/div&gt; 12345678&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; checked: false &#125; &#125;);&lt;/script&gt; 多复选框12345678910&lt;div id="vue"&gt; 多复选框： &lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt; &lt;label for="jack"&gt;Jack&lt;/label&gt; &lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt; &lt;label for="john"&gt;John&lt;/label&gt; &lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt; &lt;label for="mike"&gt;Mike&lt;/label&gt; &lt;span&gt;选中的值: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; 12345678&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; checkedNames: [] &#125; &#125;);&lt;/script&gt; 单选按钮12345678&lt;div id="vue"&gt; 单选按钮： &lt;input type="radio" id="one" value="One" v-model="picked"&gt; &lt;label for="one"&gt;One&lt;/label&gt; &lt;input type="radio" id="two" value="Two" v-model="picked"&gt; &lt;label for="two"&gt;Two&lt;/label&gt; &lt;span&gt;选中的值: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt; 12345678&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; picked: '' &#125; &#125;);&lt;/script&gt; 下拉框12345678910&lt;div id="vue"&gt; 下拉框： &lt;select v-model="selected"&gt; &lt;option disabled value=""&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;选中的值: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt; 12345678&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; selected: '' &#125; &#125;);&lt;/script&gt; 注意： 如果 v-model 表达式的初始值未能匹配任何选项，&lt;select&gt; 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 通信]]></title>
    <url>%2F2013%2F01%2F13%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F073.Vue-%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Vue 通信什么是 AxiosAxios 是一个开源的可以用在浏览器端和 NodeJS 的异步通信框架，它的主要作用就是实现 AJAX 异步通信，其功能特点如下： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF（跨站请求伪造） GitHub：https://github.com/axios/axios 为什么要使用 Axios由于 Vue.js 是一个 视图层框架 并且作者（尤雨溪）严格准守 SoC （关注度分离原则），所以 Vue.js 并不包含 AJAX 的通信功能，为了解决通信问题，作者单独开发了一个名为 vue-resource 的插件，不过在进入 2.0 版本以后停止了对该插件的维护并推荐了 Axios 框架 第一个 Axios 应用程序咱们开发的接口大部分都是采用 JSON 格式，可以先在项目里模拟一段 JSON 数据，数据内容如下： 12345678910111213141516171819202122232425&#123; "name": "广州千锋", "url": "http://www.funtl.com", "page": 88, "isNonProfit": true, "address": &#123; "street": "元岗路.", "city": "广东广州", "country": "中国" &#125;, "links": [ &#123; "name": "Google", "url": "http://www.google.com" &#125;, &#123; "name": "Baidu", "url": "http://www.baidu.com" &#125;, &#123; "name": "SoSo", "url": "http://www.SoSo.com" &#125; ]&#125; 创建一个名为 data.json 的文件并填入上面的内容，放在项目的根目录下，如图所示： 创建 HTML12345&lt;div id="vue"&gt; &lt;div&gt;名称：&#123;&#123;info.name&#125;&#125;&lt;/div&gt; &lt;div&gt;地址：&#123;&#123;info.address.country&#125;&#125;-&#123;&#123;info.address.city&#125;&#125;-&#123;&#123;info.address.street&#125;&#125;&lt;/div&gt; &lt;div&gt;链接：&lt;a v-bind:href="info.url" target="_blank"&gt;&#123;&#123;info.url&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 注意： 在这里使用了 v-bind 将 a:href 的属性值与 Vue 实例中的数据进行绑定 引入 JS 文件12&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; JavaScript1234567891011121314151617181920212223&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data() &#123; return &#123; info: &#123; name: null, address: &#123; country: null, city: null, street: null &#125;, url: null &#125; &#125; &#125;, mounted() &#123; axios .get('data.json') .then(response =&gt; (this.info = response.data)); &#125; &#125;);&lt;/script&gt; 使用 axios 框架的 get 方法请求 AJAX 并自动将数据封装进了 Vue 实例的数据对象中 数据对象这里的数据结构与 JSON 数据结构是匹配的 123456789info: &#123; name: null, address: &#123; country: null, city: null, street: null &#125;, url: null&#125; 调用 get 请求调用 axios 的 get 请求并自动装箱数据 123axios .get('data.json') .then(response =&gt; (this.info = response.data)); 测试效果 完整的 HTML1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;网络篇 Axios&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;div&gt;名称：&#123;&#123;info.name&#125;&#125;&lt;/div&gt; &lt;div&gt;地址：&#123;&#123;info.address.country&#125;&#125;-&#123;&#123;info.address.city&#125;&#125;-&#123;&#123;info.address.street&#125;&#125;&lt;/div&gt; &lt;div&gt;链接：&lt;a v-bind:href="info.url" target="_blank"&gt;&#123;&#123;info.url&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data() &#123; return &#123; info: &#123; name: null, address: &#123; country: null, city: null, street: null &#125;, url: null &#125; &#125; &#125;, mounted() &#123; axios .get('data.json') .then(response =&gt; (this.info = response.data)); &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 事件]]></title>
    <url>%2F2013%2F01%2F12%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F072.Vue-%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Vue 事件监听事件 v-on HTML123&lt;div id="vue"&gt; &lt;button v-on:click="sayHi"&gt;点我&lt;/button&gt;&lt;/div&gt; 注：在这里我们使用了 v-on 绑定了 click 事件，并指定了名为 sayHi 的方法 JavaScript方法必须定义在 Vue 实例的 methods 对象中 123456789101112131415&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; message: 'Hello World' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; sayHi: function (event) &#123; // `this` 在方法里指向当前 Vue 实例 alert(this.message); &#125; &#125; &#125;);&lt;/script&gt; 测试效果 完整的 HTML123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html xmlns:v-on=""&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;事件篇 v-on&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;button v-on:click="sayHi"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; message: 'Hello World' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; sayHi: function (event) &#123; // `this` 在方法里指向当前 Vue 实例 alert(this.message); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 语法]]></title>
    <url>%2F2013%2F01%2F11%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F071.Vue-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Vue 语法条件判断语句 v-if v-else 什么是条件判断语句，就不需要我说明了吧（￣▽￣），直接看语法上效果 HTML1234&lt;div id="vue"&gt; &lt;h1 v-if="ok"&gt;YES&lt;/h1&gt; &lt;h1 v-else&gt;NO&lt;/h1&gt;&lt;/div&gt; JavaScript12345678&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; ok: true &#125; &#125;);&lt;/script&gt; 测试效果 在 Chrome 浏览器上运行，并按 F12 进入 开发者工具 在控制台输入 vm.ok = false ，然后 回车，你会发现浏览器中显示的内容会直接变成 NO 注意： 使用 v-* 属性绑定数据是不需要 双花括号 包裹的 完整的 HTML123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;语法篇 v-if&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;h1 v-if="ok"&gt;YES&lt;/h1&gt; &lt;h1 v-else&gt;NO&lt;/h1&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; ok: true &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 连续的条件判断语句 v-if v-else-if v-else HTML123456&lt;div id="vue"&gt; &lt;h1 v-if="type === 'A'"&gt;A&lt;/h1&gt; &lt;h1 v-else-if="type === 'B'"&gt;B&lt;/h1&gt; &lt;h1 v-else-if="type === 'C'"&gt;C&lt;/h1&gt; &lt;h1 v-else&gt;你看不见我&lt;/h1&gt;&lt;/div&gt; 注：=== 三个等号在 JS 中表示绝对等于（就是数据与类型都要相等） JavaScript12345678&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; type: 'A' &#125; &#125;);&lt;/script&gt; 测试效果 在 Chrome 浏览器上运行，并按 F12 进入 开发者工具 分别观察在控制台输入 vm.type = &#39;B&#39;、&#39;C&#39;、&#39;D&#39; 的变化 完整的 HTML1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;语法篇 v-else-if&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;h1 v-if="type === 'A'"&gt;A&lt;/h1&gt; &lt;h1 v-else-if="type === 'B'"&gt;B&lt;/h1&gt; &lt;h1 v-else-if="type === 'C'"&gt;C&lt;/h1&gt; &lt;h1 v-else&gt;你看不见我&lt;/h1&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; type: 'A' &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 循环遍历语句 v-for HTML12345&lt;div id="vue"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/div&gt; 注：items 是源数据数组并且 item 是数组元素迭代的别名。是不是像极了 Thymeleaf JavaScript1234567891011&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; items: [ &#123;message: 'Foo'&#125;, &#123;message: 'Bar'&#125; ] &#125; &#125;);&lt;/script&gt; 测试效果 在 Chrome 浏览器上运行，并按 F12 进入 开发者工具 在控制台输入 vm.items.push({message: &#39;Baz&#39;}) ，尝试追加一条数据，你会发现浏览器中显示的内容会增加一条 Baz 完整的 HTML12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;语法篇 v-for&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; items: [ &#123;message: 'Foo'&#125;, &#123;message: 'Bar'&#125; ] &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 实例的生命周期]]></title>
    <url>%2F2013%2F01%2F10%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F070.Vue-%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Vue 实例的生命周期什么是生命周期Vue 实例有一个完整的生命周期，也就是从 开始创建、初始化数据、编译模板、挂载 DOM、渲染→更新→渲染、卸载 等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。 在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 JS 方法，可以让我们用自己注册的 JS 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 Vue 的实例。 注意： created 钩子函数和 mounted 钩子函数的区别 钩子函数的触发时机beforeCreate在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用。 mountedel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 beforeUpdate数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy实例销毁之前调用。在这一步，实例仍然完全可用。 destroyedVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个 Vue 应用程序]]></title>
    <url>%2F2013%2F01%2F09%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F069.Vue-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[第一个 Vue 应用程序兼容性Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有 兼容 ECMAScript 5 的浏览器。 下载地址 开发版本 包含完整的警告和调试模式：https://vuejs.org/js/vue.js 删除了警告，30.96KB min + gzip：https://vuejs.org/js/vue.min.js CDN &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 第一个 Vue 应用程序Vue.js 的核心是实现了 MVVM 模式，她扮演的角色就是 ViewModel 层，那么所谓的第一个应用程序就是展示她的 数据绑定 功能，操作流程如下： 创建一个 HTML 文件12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;第一个 Vue 应用程序&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 引入 Vue.js1&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 创建一个 Vue 的实例12345678&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; message: 'Hello Vue!' &#125; &#125;);&lt;/script&gt; 说明 el:&#39;#vue&#39;：绑定元素的 ID data:{message:&#39;Hello Vue!&#39;}：数据对象中有一个名为 message 的属性，并设置了初始值 Hello Vue! 将数据绑定到页面元素123&lt;div id="vue"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 说明：只需要在绑定的元素中使用 双花括号 将 Vue 创建的名为 message 属性包裹起来，即可实现数据绑定功能，也就实现了 ViewModel 层所需的效果，是不是和 EL 表达式非常像？ 1#&#123;message&#125; =&gt; &#123;&#123;message&#125;&#125; 完整的 HTML12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;第一个 Vue 应用程序&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="vue"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; message: 'Hello Vue!' &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注：我是在 IDEA 上创建的 HTML，并使用 IDEA 内置的 HTTP 服务器运行 测试 Vue为了能够更直观的体验 Vue 带来的数据绑定功能，我们需要在浏览器测试一番，操作流程如下： 在 Chrome 浏览器上运行第一个 Vue 应用程序，并按 F12 进入 开发者工具 在控制台输入 vm.message = &#39;Hello World&#39; ，然后 回车，你会发现浏览器中显示的内容会直接变成 Hello World 说明在之前的代码中，我们创建了一个名为 vm 的 Vue 实例 123456var vm = new Vue(&#123; el: '#vue', data: &#123; message: 'Hello Vue!' &#125;&#125;); 此时就可以在控制台直接输入 vm.message 来修改值，中间是可以省略 data 的，在这个操作中，我并没有主动操作 DOM，就让页面的内容发生了变化，这就是借助了 Vue 的 数据绑定 功能实现的；MVVM 模式中要求 ViewModel 层就是使用 观察者模式 来实现数据的监听与绑定，以做到数据与视图的快速响应。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 简介]]></title>
    <url>%2F2013%2F01%2F08%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F068.Vue-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Vue 简介概述Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库（如：vue-router，vue-resource，vuex）或既有项目整合。 官方网站 MVVM 模式的实现者我们知道 MVVM 表示如下： Model：模型层，在这里表示 JavaScript 对象 View：视图层，在这里表示 DOM（HTML 操作的元素） ViewModel：连接视图和数据的中间件，Vue.js 就是 MVVM 中的 ViewModel 层的实现者 在 MVVM 架构中，是不允许 数据 和 视图 直接通信的，只能通过 ViewModel 来通信，而 ViewModel 就是定义了一个 Observer 观察者 ViewModel 能够观察到数据的变化，并对视图对应的内容进行更新 ViewModel 能够监听到视图的变化，并能够通知数据发生改变 至此，我们就明白了，Vue.js 就是一个 MVVM 的实现者，他的核心就是实现了 DOM 监听 与 数据绑定 其它 MVVM 实现者 AngularJS ReactJS 微信小程序 为什么要使用 Vue.js 轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+） 移动优先。更适合移动端，比如移动端的 Touch 事件 易上手，学习曲线平稳，文档齐全 吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性 开源，社区活跃度高 Vue.js 的两大核心要素数据驱动 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 组件化 页面上每个独立的可交互的区域视为一个组件 每个组件对应一个工程目录，组件所需的各种资源在这个目录下就近维护 页面不过是组件的容器，组件可以嵌套自由组合（复用）形成完整的页面]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-了解 MVVM 模式]]></title>
    <url>%2F2013%2F01%2F07%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F067.Vue-%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%20MVVM%20%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[了解前端 MVVM 模式什么是 MVVMMVVM（Model-View-ViewModel）是一种软件架构设计模式，由微软 WPF（用于替代 WinForm，以前就是用这个技术开发桌面应用程序的）和 Silverlight（类似于 Java Applet，简单点说就是在浏览器上运行的 WPF） 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于 2005 年在他的博客上发表。 MVVM 源自于经典的 MVC（Model-View-Controller）模式（期间还演化出了 MVP（Model-View-Presenter） 模式）。MVVM 的核心是 ViewModel 层，负责转换 Model 中的数据对象来让数据变得更容易管理和使用，其作用如下： 该层向上与视图层进行双向数据绑定 向下与 Model 层通过接口请求进行数据交互 MVVM 已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的 MVVM 框架有 Vue.js，AngularJS 等。 为什么要使用 MVVMMVVM 模式和 MVC 模式一样，主要目的是分离视图（View）和模型（Model），有几大好处 低耦合： 视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 可复用： 你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。 独立开发： 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试： 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 MVVM 的组成部分 ViewView 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Thymeleaf 等等，各大 MVVM 框架如 Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置模板语言。 ModelModel 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的 接口规则 ViewModelViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。 需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的 比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示） 页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互） 视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层 由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图 MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现 事件驱动编程。 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-了解前后端分离的演变史]]></title>
    <url>%2F2013%2F01%2F06%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F066.Vue-%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[了解前后分离的演变史为什么需要前后分离后端为主的 MVC 时代为了降低开发的复杂度，以后端为出发点，比如：Struts、SpringMVC 等框架的使用，就是后端的 MVC 时代 以 SpringMVC 流程为例： 发起请求到前端控制器(DispatcherServlet) 前端控制器请求 HandlerMapping 查找 Handler，可以根据 xml 配置、注解进行查找 处理器映射器 HandlerMapping 向前端控制器返回 Handler 前端控制器调用处理器适配器去执行 Handler 处理器适配器去执行 Handler Handler 执行完成给适配器返回 ModelAndView 处理器适配器向前端控制器返回 ModelAndView，ModelAndView 是 SpringMVC 框架的一个底层对象，包括 Model 和 View 前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(JSP) 视图解析器向前端控制器返回 View 前端控制器进行视图渲染，视图渲染将模型数据(在 ModelAndView 对象中)填充到 request 域 前端控制器向用户响应结果 优点MVC 是一个非常好的协作模式，能够有效降低代码的耦合度，从架构上能够让开发者明白代码应该写在哪里。为了让 View 更纯粹，还可以使用 Thymeleaf、Freemarker 等模板引擎，使模板里无法写入 Java 代码，让前后端分工更加清晰。 缺点 前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式： 第一种是前端写 DEMO，写好后，让后端去套模板。好处是 DEMO 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大； 另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。 前后端职责纠缠不清：模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现。 Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在 Controller 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。 对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用 【Comet】、【BigPipe】 等技术方案来优化性能。 注：在这期间（2005 年以前），包括早期的 JSP、PHP 可以称之为 Web 1.0 时代。在这里想说一句，如果你是一名 Java 初学者，请你不要再把一些陈旧的技术当回事了，比如 JSP，因为时代在变、技术在变、什么都在变（引用扎克伯格的一句话：唯一不变的是变化本身）；当我们 千锋教育 机构去给大学做实训时，有些同学会认为我们没有讲什么 干货 ，其实不然，只能说是你认知里的干货对于市场来说早就过时了而已。 什么是前后分离基于 AJAX 带来的 SPA 时代时间回到 2005 年 AJAX（Asynchronous JavaScript And XML，异步 JavaScript 和 XML，老技术新用法） 被正式提出并开始使用 CDN 作为静态资源存储，于是出现了 JavaScript 王者归来（在这之前 JS 都是用来在网页上贴狗皮膏药广告的）的 SPA（Single Page Application）单页面应用时代。 优点这种模式下，前后端的分工非常清晰，前后端的关键协作点是 AJAX 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构： 缺点 前后端接口的约定： 如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的 接口规则 ，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。 前端开发的复杂度控制： SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。 前端为主的 MV* 时代此处的 MV* 模式如下： MVC（同步通信为主）：Model、View、Controller MVP（异步通信为主）：Model、View、Presenter MVVM（异步通信为主）：Model、View、ViewModel 为了降低前端开发复杂度，涌现了大量的前端框架，比如：AngularJS、React、Vue.js、EmberJS 等，这些框架总的原则是先按类型分层，比如 Templates、Controllers、Models，然后再在层内做切分，如下图： 优点 前后端职责很清晰： 前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。 前端开发的复杂度可控： 前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本书的厚度去说明。 部署相对独立： 可以快速改进产品体验 缺点 代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。 全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。 性能并非最佳，特别是移动互联网环境下。 SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。 NodeJS 带来的全栈时代前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 NodeJS 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式： 在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职： Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。 Back-end UI layer 处理路由、模板、数据获取、Cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。 通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。 与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。 基于 NodeJS 的全栈模式，依旧面临很多挑战： 需要前端对服务端编程有更进一步的认识。比如 TCP/IP 等网络知识的掌握。 NodeJS 层与 Java 层的高效通信。NodeJS 模式下，都在服务器端，RESTful HTTP 通信未必高效，通过 SOAP 等方式通信更高效。一切需要在验证中前行。 对部署、运维层面的熟练了解，需要更多知识点和实操经验。 大量历史遗留问题如何过渡。这可能是最大最大的阻力。 注意： 看到这里，相信很多同学就可以理解，为什么我总在课堂上说：“前端想学后台很难，而我们后端程序员学任何东西都很简单”；就是因为我们后端程序员具备相对完善的知识体系。** 总结综上所述，模式也好，技术也罢，没有好坏优劣之分，只有适合不适合；前后分离的开发思想主要是基于 SoC（关注度分离原则），上面种种模式，都是让前后端的职责更清晰，分工更合理高效。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-了解前端知识体系]]></title>
    <url>%2F2013%2F01%2F05%2F%E5%89%8D%E7%AB%AF%2FDay64_Vue%2F065.Vue-%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[了解前端知识体系前端三要素 HTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容 CSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式 JavaScript（行为）：是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行，用于控制网页的行为 结构层（HTML）略 表现层（CSS）CSS 层叠样式表是一门标记语言，并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说就是不具备任何语法支持，它主要缺陷如下： 语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器； 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护； 这就导致了我们在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为 【CSS 预处理器】 的工具，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了前端在样式上的开发效率。 什么是 CSS 预处理器CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行 CSS 的编码工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文件，以供项目使用”。 常用的 CSS 预处理器有哪些 SASS：基于 Ruby，通过服务端处理，功能强大。解析效率高。需要学习 Ruby 语言，上手难度高于 LESS。 LESS：基于 NodeJS，通过客户端处理，使用简单。功能比 SASS 简单，解析效率也低于 SASS，但在实际开发中足够了，所以我们后台人员如果需要的话，建议使用 LESS。 行为层（JavaScript）JavaScript 一门弱类型脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行。 Native 原生 JS 开发原生 JS 开发，也就是让我们按照 【ECMAScript】 标准的开发方式，简称是 ES，特点是所有浏览器都支持。截止到当前博客发布时间（2018 年 12 月 04 日），ES 标准已发布如下版本： ES3 ES4（内部，未正式发布） ES5（全浏览器支持） ES6（常用，当前主流版本） ES7 ES8 ES9（草案阶段） 区别就是逐步增加新特性。 TypeScript 微软的标准TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯·海尔斯伯格（C#、Delphi、TypeScript 之父；.NET 创立者）主导。 该语言的特点就是除了具备 ES 的特性之外还纳入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持 TypeScript 语法，需要编译后（编译成 JS）才能被浏览器正确执行。 JavaScript 框架 jQuery：大家熟知的 JavaScript 框架，优点是简化了 DOM 操作，缺点是 DOM 操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容 IE6、7、8； Angular：Google 收购的前端框架，由一群 Java 程序员开发，其特点是将后台的 MVC 模式搬到了前端并增加了模块化开发的理念，与微软合作，采用 TypeScript 语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如：1代 -&gt; 2代，除了名字，基本就是两个东西；截止发表博客时已推出了 Angular6） React：Facebook 出品，一款高性能的 JS 前端框架；特点是提出了新概念 【虚拟 DOM】 用于减少真实 DOM 操作，在内存中模拟 DOM 操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门 【JSX】 语言； Vue：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化） 和 React（虚拟 DOM） 的优点； Axios：前端通信框架；因为 Vue 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用 jQuery 提供的 AJAX 通信功能； UI 框架 Ant-Design：阿里巴巴出品，基于 React 的 UI 框架 ElementUI：饿了么出品，基于 Vue 的 UI 框架 Bootstrap：Twitter 推出的一个用于前端开发的开源工具包 AmazeUI：又叫“妹子 UI”，一款 HTML5 跨屏前端框架 JavaScript 构建工具 Babel：JS 编译工具，主要用于浏览器不支持的 ES 新特性，比如用于编译 TypeScript WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载 注：以上知识点已将 WebApp 开发所需技能全部梳理完毕 三端统一混合开发（Hybrid App）主要目的是实现一套代码三端统一（PC、Android、iOS）并能够调用到设备底层硬件（如：传感器、GPS、摄像头等），打包方式主要有以下两种： 云打包：HBuild -&gt; HBuildX，DCloud 出品；API Cloud 本地打包： Cordova（前身是 PhoneGap） 微信小程序详见微信官网，这里就是介绍一个方便微信小程序 UI 开发的框架：WeUI 后端技术前端人员为了方便开发也需要掌握一定的后端技术，但我们 Java 后台人员知道后台知识体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了 NodeJS 这样的技术。 NodeJS 的作者已经声称放弃 NodeJS（说是架构做的不好再加上笨重的 node_modules，可能让作者不爽了吧），开始开发全新架构的 Deno 既然是后台技术，那肯定也需要框架和项目管理工具，NodeJS 框架及项目管理工具如下： Express：NodeJS 框架 Koa：Express 简化版 NPM：项目综合管理工具，类似于 Maven YARN：NPM 的替代方案，类似于 Maven 和 Gradle 的关系 附：扩展阅读当前主流前端框架Vue.jsiViewiview 是一个强大的基于 Vue 的 UI 库，有很多实用的基础组件比 elementui 的组件更丰富，主要服务于 PC 界面的中后台产品。使用单文件的 Vue 组件化开发模式 基于 npm + webpack + babel 开发，支持 ES2015 高质量、功能丰富 友好的 API ，自由灵活地使用空间。 官网地址 Github iview-admin 备注：属于前端主流框架，选型时可考虑使用，主要特点是移动端支持较多 ElementUIElement 是饿了么前端开源维护的 Vue UI 组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。主要用于开发 PC 端的页面，是一个质量比较高的 Vue UI 组件库。 官网地址 Github vue-element-admin 备注：属于前端主流框架，选型时可考虑使用，主要特点是桌面端支持较多 ICE飞冰是阿里巴巴团队基于 React/Angular/Vue 的中后台应用解决方案，在阿里巴巴内部，已经有 270 多个来自几乎所有 BU 的项目在使用。飞冰包含了一条从设计端到开发端的完整链路，帮助用户快速搭建属于自己的中后台应用。 官网地址 Github 备注：主要组件还是以 React 为主，截止 2019 年 02 月 17 日更新博客前对 Vue 的支持还不太完善，目前尚处于观望阶段 VantUIVant UI 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库，提供了一整套 UI 基础组件和业务组件。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率。 官网地址 Github AtUIat-ui 是一款基于 Vue 2.x 的前端 UI 组件库，主要用于快速开发 PC 网站产品。 它提供了一套 npm + webpack + babel 前端开发工作流程，CSS 样式独立，即使采用不同的框架实现都能保持统一的 UI 风格。 官网地址 Github CubeUIcube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库。支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。 官网地址 Github 混合开发FlutterFlutter 是谷歌的移动端 UI 框架，可在极短的时间内构建 Android 和 iOS 上高质量的原生级应用。Flutter 可与现有代码一起工作, 它被世界各地的开发者和组织使用, 并且 Flutter 是免费和开源的。 官网地址 Github 备注：Google 出品，主要特点是快速构建原生 APP 应用程序，如做混合应用该框架为必选框架 IonicIonic 既是一个 CSS 框架也是一个 Javascript UI 库，Ionic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。它使用 JavaScript MVVM 框架和 AngularJS/Vue 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。 官网地址 官网文档 Github 微信小程序mpvuempvue 是美团开发的一个使用 Vue.js 开发小程序的前端框架，目前支持 微信小程序、百度智能小程序，头条小程序 和 支付宝小程序。 框架基于 Vue.js，修改了的运行时框架 runtime 和代码编译器 compiler 实现，使其可运行在小程序环境中，从而为小程序开发引入了 Vue.js 开发体验。 官网地址 Github 备注：完备的 Vue 开发体验，并且支持多平台的小程序开发，推荐使用 WeUIWeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含 button、cell、dialog、toast、article、icon 等各式元素。 官网地址 Github]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap字体图标]]></title>
    <url>%2F2013%2F01%2F04%2F%E5%89%8D%E7%AB%AF%2FDay44_Bootstrap%2F05.%20Bootstrap%20%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[Bootstrap 字体图标什么是字体图标 所谓字体图标，就是使用字体（Font）格式的字形做成了图标。 Bootstrap 自带的字体图标 Bootstrap 自带的字体图标Bootstrap 捆绑了 200 多种字体格式的字形，在 fonts 文件夹内可以找到字体图标，它包含了下列这些文件： glyphicons-halflings-regular.eot glyphicons-halflings-regular.svg glyphicons-halflings-regular.ttf glyphicons-halflings-regular.woff 相关的 CSS 规则写在 dist 文件夹内的 css 文件夹内的 bootstrap.css 和 bootstrap-min.css 文件上。 使用字体图标如需使用图标，只需要简单地使用下面的代码即可：1&lt;span class="glyphicon glyphicon-search"&gt;&lt;/span&gt; 其它字体图标库 FontAwesome：http://fontawesome.dashgame.com/ LineAwesome：https://icons8.com/line-awesome SocialIcons：http://www.socicon.com/chart.php 阿里巴巴矢量图标库：http://www.iconfont.cn/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap表格]]></title>
    <url>%2F2013%2F01%2F03%2F%E5%89%8D%E7%AB%AF%2FDay44_Bootstrap%2F04.%20Bootstrap%20%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[Bootstrap 表格Bootstrap 表格概述 Bootstrap 提供了一个清晰的创建表格的布局。下表列出了 Bootstrap 支持的一些表格元素： 标签 描述 table 为表格添加基础样式 thead 表格标题行的容器元素（tr），用来标识表格列 tbody 表格主体中的表格行的容器元素（t&gt;） tr 一组出现在单行上的表格单元格的容器元素（td 或 th） td 默认的表格单元格 th 特殊的表格单元格，用来标识列或行（取决于范围和位置）。必须在 thead 内使用 caption 关于表格存储内容的描述或总结 表格类下表样式可用于表格中： 类 描述 .table 为任意 table 添加基本样式 (只有横向分隔线) .table-striped 在 tbody 内添加斑马线形式的条纹 ( IE8 不支持) .table-bordered 为所有表格的单元格添加边框 .table-hover 在 tbody 内的任一行启用鼠标悬停状态 .table-condensed 让表格更加紧凑 tr, th 和 td 类下表的类可用于表格的行或者单元格： 类 描述 .active 将悬停的颜色应用在行或者单元格上 .success 表示成功的操作 .info 表示信息变化的操作 .warning 表示一个警告的操作 .danger 表示一个危险的操作]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[媒体查询]]></title>
    <url>%2F2013%2F01%2F02%2F%E5%89%8D%E7%AB%AF%2FDay44_Bootstrap%2F03.%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[媒体查询什么是媒体查询 @media 媒体查询,媒体查询能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果。 浏览器支持 表格中的数字表示支持 @media 规则的第一个浏览器的版本号 |Chrome IE|Firefox|Safari|Opera| |—|—|—|—| |21|9|3.5|4.0|9| 媒体类型 媒体类型在 CSS2 中是一个常见属性，可以通过媒体类型对不同设备指定不同样式。 ALL：所有设备 Braille：盲人用点子法触觉回馈设备 Embossed：盲文打印机 Handheld：便携设备 Print：打印用纸或打印预览视图 Projection：各种投影设备 Screen：电脑显示器 Speech：语音或音频合成器 Tv：电视机类型设备 Tty：使用固定密度字母栅格的媒介，比如电传打字机和终端 Screen、All、Print 为最常见的三种媒体类型 媒体特性 媒体查询中的大部分接受 min/max 前缀，用来表达其逻辑关系，表示应用大于等于或小于等于某个值的情况。没有特殊说明都支持 min/max。 width：Length 渲染界面的宽度 height：Length 渲染界面的高度 color：整数，表示色彩的字节数 color-index：整数， 色彩表中的色彩数 device-aspct-ratio：整数/整数，宽高比例 device-height：Length 设备屏幕的输出高度 device-width：Length 设备屏幕的输出宽度 grid（不支持 min/max 前缀）：整数，是否基于栅格的设备 monochrome：整数，单色帧缓冲器中每像素字节数 resolution：分辨率（dpi/dpcm）分辨率 scan（不支持 min/max 前缀）：Progressive interlaced，Tv 媒体类型的扫描方式 orientation（不支持 min/max 前缀）：Portrait//landscape 横屏或竖屏 使用媒体查询 语法：@media 媒体类型 and (媒体特性) {你的样式}]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap网格系统]]></title>
    <url>%2F2013%2F01%2F01%2F%E5%89%8D%E7%AB%AF%2FDay44_Bootstrap%2F02.%20Bootstrap%20%E7%BD%91%E6%A0%BC%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Bootstrap 网格系统Bootstrap 概述 Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列。 什么是 Bootstrap 网格系统（Grid System）？ Bootstrap 官方文档中有关网格系统的描述： Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类。 让我们来理解一下上面的语句。Bootstrap 3 是移动设备优先的，在这个意义上，Bootstrap 代码从小屏幕设备（比如移动设备、平板电脑）开始，然后扩展到大屏幕设备（比如笔记本电脑、台式电脑）上的组件和网格。 移动设备优先策略 内容 决定什么是最重要的 布局 优先设计更小的宽度 基础的 CSS 是移动设备优先，媒体查询 是针对于平板电脑、台式电脑 渐进增强 随着屏幕大小的增加而添加元素 响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列。 Bootstrap 网格系统（Grid System）的工作原理网格系统通过一系列包含内容的行和列来创建页面布局。下面列出了 Bootstrap 网格系统是如何工作的： 行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding） 使用行来创建列的水平组 内容应该放置在列内，且唯有列可以是行的直接子元素 预定义的网格类，比如 .row 和 .col-xs-4，可用于快速创建网格布局。LESS 混合类可用于更多语义布局 列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 .rows上的外边距（margin）取负，表示第一列和最后一列的行偏移 网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 .col-xs-4 网格选项-下表总结了 Bootstrap 网格系统如何跨多个设备工作： 说明 超小设备手机（&lt; 768px） 小型设备平板电脑（≥ 768px） 中型设备台式电脑（≥ 992px） 大型设备台式电脑（≥ 1200px） 网格行为 一直是水平的 以折叠开始，断点以上是水平的 以折叠开始，断点以上是水平的 以折叠开始，断点以上是水平的 最大容器宽度 None (auto) 750px 970px 1170px Class 前缀 .col-xs- .col-sm- .col-md- .col-lg- 列数量和 12 12 12 12 最大列宽 Auto 60px 78px 95px 间隙宽度 30px（一个列的每边分别 15px） 30px（一个列的每边分别 15px） 30px（一个列的每边分别 15px） 30px（一个列的每边分别 15px） 可嵌套 Yes Yes Yes Yes 偏移量 Yes Yes Yes Yes 列排序 Yes Yes Yes Yes]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap介绍]]></title>
    <url>%2F2012%2F12%2F31%2F%E5%89%8D%E7%AB%AF%2FDay44_Bootstrap%2F01.%20Boostrap%20%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Bootstrap 介绍什么是 Bootstrap Bootstrap 是基于 HTML、CSS、JavaScript 的一个用于快速开发 Web 应用程序和网站的前端框架。 Bootstrap 的历史 Bootstrap 是由 Twitter 的 Mark Otto 和 Jacob Thornton 开发的。Bootstrap 是 2011 年八月在 GitHub 上发布的开源产品。 Bootstrap 包的内容 基本结构：Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构。这将在 Bootstrap 基本结构 部分详细讲解。 CSS：Bootstrap 自带以下特性：全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统。这将在 Bootstrap CSS 部分详细讲解。 组件：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等等。这将在 布局组件 部分详细讲解。 JavaScript 插件：Bootstrap 包含了十几个自定义的 jQuery 插件。您可以直接包含所有的插件，也可以逐个包含这些插件。这将在 Bootstrap 插件 部分详细讲解。 定制：您可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到您自己的版本。 为什么使用 Bootstrap 移动设备优先：自 Bootstrap 3 起，框架包含了贯穿于整个库的移动设备优先的样式。 浏览器支持：所有的主流浏览器都支持 Bootstrap。 容易上手：只要您具备 HTML 和 CSS 的基础知识，您就可以开始学习 Bootstrap。 响应式设计：Bootstrap 的响应式 CSS 能够自适应于台式机、平板电脑和手机。 它为开发人员创建接口提供了一个简洁统一的解决方案。 它包含了功能强大的内置组件，易于定制。 它还提供了基于 Web 的定制。 它是开源的。 HTML 模板 一个使用了 Bootstrap 的基本的 HTML 模板如下所示： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Bootstrap 模板&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;!--解决乱码问题--&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href="asserts/plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- HTML5 Shiv 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt; &lt;!-- 注意： 如果通过 file:// 引入 Respond.js 文件，则该文件无法起效果 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt; &lt;script src="asserts/plugins/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;!-- 包括所有已编译的插件 --&gt; &lt;script src="asserts/plugins/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 在这里，您可以看到包含了 jquery.js、bootstrap.min.js 和 bootstrap.min.css 文件，用于让一个常规的 HTML 文件变为使用了 Bootstrap 的模板。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery的AJAX]]></title>
    <url>%2F2012%2F12%2F30%2F%E5%89%8D%E7%AB%AF%2FDay43_JQuery%E5%8A%A8%E7%94%BB%E4%B8%8EAJAX%2F04.JQuery%20%E7%9A%84%20AJAX%2F</url>
    <content type="text"><![CDATA[JQuery 的 AJAX案例123456789101112131415161718192021222324&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.8.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#username").blur(function () &#123; $.post("UserServlet?action=checkUsername&amp;username="+$(this).val(),function (data) &#123; if(data == 1)&#123; $("span:eq(0)").text("用户名重复"); &#125;else if(data == 0)&#123; $("span:eq(0)").text("可用"); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="UserServlet?action=register" method="post"&gt; 用户名:&lt;input type="text" name="username" id="username"&gt;&lt;span&gt;&lt;/span&gt;&lt;br/&gt; 密码:&lt;input type="text" name="password" id="password"&gt;&lt;br/&gt; &lt;input type="submit" value="注册"&gt; &lt;/form&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2012%2F12%2F29%2F%E5%89%8D%E7%AB%AF%2FDay43_JQuery%E5%8A%A8%E7%94%BB%E4%B8%8EAJAX%2F03.AJAX%2F</url>
    <content type="text"><![CDATA[AJAX什么是AJAX Ajax：（Asynchronous JavaScript And XML）指异步 JavaScript 及 XML不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的 Web 应用程序的技术，是基于 JavaScript、XML、HTML、CSS 新用法 AJAX :只刷新局部页面的技术 AJAX 交互 传统交互模型: AJAX交互模型: AJAX 技术点 XMLHttpRequest 对象: XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 创建方式:var xmlHttp=new XMLHttpRequest(); XMLHttpRequest 对象的 open(method,url,async) 和 send() 方法用于把请求发送到服务器 onreadystatechange 事件 当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。 XMLHttpRequest 对象的三个重要的属性 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status 200: “OK”404: 未找到页面 AJAX 案例1234567891011121314151617181920212223242526272829303132&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type="text/javascript"&gt; onload = function()&#123; var username = document.getElementById("username"); var span = document.getElementsByTagName("span")[0]; username.onblur = function()&#123; var xmlHttp = new XMLHttpRequest(); xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)&#123; if(xmlHttp.responseText == "1")&#123; span.innerHTML = "&lt;font color='red'&gt;用户名已存在&lt;/font&gt;"; &#125;else if(xmlHttp.responseText == "0")&#123; span.innerHTML = "&lt;font color='green'&gt;用户名可用&lt;/font&gt;"; &#125; &#125; &#125; xmlHttp.open("GET","UserServlet?action=checkUsername&amp;username="+username.value,true); xmlHttp.send(); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="UserServlet" method="post"&gt; &lt;input type="hidden" name="action" value="register"/&gt; 用户名:&lt;input type="text" name="username" id= "username"/&gt;&lt;span&gt;&lt;/span&gt;&lt;br/&gt; 密码:&lt;input type="text" name="password"/&gt;&lt;br/&gt; &lt;input type="submit" value="注册"/&gt; &lt;/form&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画案例]]></title>
    <url>%2F2012%2F12%2F28%2F%E5%89%8D%E7%AB%AF%2FDay43_JQuery%E5%8A%A8%E7%94%BB%E4%B8%8EAJAX%2F02.%20%E5%8A%A8%E7%94%BB%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[动画案例控制透明度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .divFrame &#123; border: solid 1px #666; width: 197px; text-align: center; &#125; .divFrame .divTitle &#123; background-color: #eee; padding: 5px 0px 5px 0px &#125; .divFrame .divContent &#123; padding: 5px 0px 5px 0px &#125; .divFrame .divContent img &#123; border: solid 1px #eee; padding: 2px; width: 120px; height: 120px; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="divFrame"&gt; &lt;div class="divTitle"&gt; &lt;select id="Select1"&gt; &lt;option value="0.2"&gt;0.2&lt;/option&gt; &lt;option value="0.4"&gt;0.4&lt;/option&gt; &lt;option value="0.6"&gt;0.6&lt;/option&gt; &lt;option value="0.8"&gt;0.8&lt;/option&gt; &lt;option value="1.0" selected="selected"&gt;1.0&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="divContent"&gt; &lt;img src="../img/a.jpg" alt="" title="风景图片" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery动画]]></title>
    <url>%2F2012%2F12%2F27%2F%E5%89%8D%E7%AB%AF%2FDay43_JQuery%E5%8A%A8%E7%94%BB%E4%B8%8EAJAX%2F01.%20JQuery%20%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[JQuery 动画隐藏/显示 在 jQuery 中，可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素，slow 为慢，normal 为正常，fast 为快，也可以传递对应的毫秒数 1234567&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("指定节点").hide(show); $("指定节点").show(fast); &#125;)&lt;/script&gt; 也可以使用 toggle() 方法来切换 hide() 和 show() 方法 12345678910 &lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("点击节点").toggle(function()&#123; $("指定节点").hide(2000); &#125;,function()&#123; $("指定节点").show(10); &#125;); &#125;)&lt;/script&gt; 滑动 通过 jQuery，可以在元素上创建滑动效果。 jQuery 拥有以下滑动方法： slideDown() slideUp() slideToggle() slideDown() 与 slideUp() 的使用12345678910&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("点击节点").toggle(function()&#123; $("指定节点").slideUp(3000); &#125;,function()&#123; $("指定节点").slideDown(100); &#125;); &#125;);&lt;/script&gt; 12345678&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("点击节点").click(function()&#123; $("指定节点").slideToggle(2000); &#125;); &#125;);&lt;/script&gt; 淡入淡出 通过 jQuery，您可以实现元素的淡入淡出效果。 jQuery 拥有下面四种 fade 方法： fadeIn() fadeOut() fadeToggle() fadeTo() fadeIn() 与 fadeOut() 的使用: 1234567891011121314151617181920&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("点击节点").toggle(function()&#123; $("指定节点").fadeOut(3000); &#125;,function()&#123; $("指定节点").fadeIn(100); &#125;); /*$("#btn").click(function()&#123; $("#info").fadeToggle(2000); &#125;);*/ $("#btn").toggle(function()&#123; $("#info").fadeOut(2000); &#125;,function()&#123; $("#info").fadeTo(2000,0.2); &#125;); &#125;);&lt;/script&gt; fadeToggle() 的使用: 12345678&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("点击节点").click(function()&#123; $("指定节点").fadeToggle(2000); &#125;); &#125;);&lt;/script&gt; fadeTo() 除了可以传递指定毫秒数,还可以传入透明度数,使用: 12345678910&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("点击节点").toggle(function()&#123; $("指定节点").fadeOut(2000); &#125;,function()&#123; $("指定节点").fadeTo(2000,0.2); &#125;); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[案例]]></title>
    <url>%2F2012%2F12%2F26%2F%E5%89%8D%E7%AB%AF%2FDay42_JQuery%E4%BA%8B%E4%BB%B6%2F03.%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[案例选项卡案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; ul&#123; margin: 0; padding: 0; list-style: none; &#125; #tab li &#123; text-align: center; float: left; padding: 5px; margin-right: 2px; width: 50px; cursor: pointer &#125; #tab li.tabFocus &#123; width: 50px; font-weight: bold; background-color: powderblue; border: solid 1px #666; border-bottom: 0; z-index: 100; position: relative &#125; #content &#123; width: 260px; height: 80px; padding: 10px; background-color: powderblue; clear: left; border: solid 1px #666; position: relative; top: -1px &#125; #content li &#123; display: none &#125; #content li.contentFocus &#123; display: block &#125; &lt;/style&gt; &lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="tab"&gt; &lt;li class="tabFocus"&gt;javaee&lt;/li&gt; &lt;li&gt;php&lt;/li&gt; &lt;li&gt;.NET&lt;/li&gt; &lt;/ul&gt; &lt;ul id="content"&gt; &lt;li class="contentFocus"&gt;企业级应用占据领导地位&lt;/li&gt; &lt;li&gt;中小型网站首选&lt;/li&gt; &lt;li&gt;微软出品&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery事件]]></title>
    <url>%2F2012%2F12%2F25%2F%E5%89%8D%E7%AB%AF%2FDay42_JQuery%E4%BA%8B%E4%BB%B6%2F02.JQuery%20%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[JQuery 事件冒泡机制 父节点和子节点同时绑定同一个事件,触发的时候是先触发子节点事件再触发父节点事件,如果想停掉父节点事件可以在子节点事件添加 return false 或者是调用 stopPropagation() 函数来停止冒泡;123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#parent").click(function () &#123; alert("div事件") &#125;); $("#son").click(function (e) &#123; alert("input事件") //1.返回false return false; //2.通过调用方法 e.stopPropagation(); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;input type="button" value="冒泡" id="son"&gt; &lt;/div&gt;&lt;/body&gt; 绑定与解绑事件 bind() 为绑定事件，传入事件名称以及执行函数 1234567 &lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("指定节点").bind("事件名称",function()&#123; 事件函数内容 &#125;);&lt;/script&gt; unbind() 为解绑事件，传入事件名称 123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("指定节点").unbind("click"); &#125;)&lt;/script&gt; JQuery事件分类 鼠标事件 键盘事件 表单事件 文档事件 click(单击) keypress(键被按下) submit(提交) load(加载/1.8已废弃) dblclick(双击) keydown(键被按下) change(改变) resize(窗口改变) mouseenter(鼠标进入) keyup(键被松开) focus(获取焦点) scroll(滚动) mouseleave(鼠标离开) blur(失去焦点) unload(离开/1.8已废弃) hover(鼠标悬停)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery节点操作]]></title>
    <url>%2F2012%2F12%2F24%2F%E5%89%8D%E7%AB%AF%2FDay42_JQuery%E4%BA%8B%E4%BB%B6%2F01.JQuery%20%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[JQuery 节点操作修改节点内容 使用 html() 或者 text() 这两个函数修改节点内容,html() 函数会把添加的内容进行解析,如果包含标签,则会解析标签;而 text() 函数只会把内容加载进节点中,并不会解析标签1234567&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("主元素").html("&lt;a href='#'&gt;有道无术&lt;/a&gt;"); $("主元素").text("&lt;a id= 'a' href='#'&gt;术尚可求&lt;/a&gt;"); &#125;)&lt;/script&gt; 修改节点属性 使用 attr() 函数改变节点的属性123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("主元素").attr("src","../img/c.jpg &#125;)&lt;/script&gt; 修改节点样式 通过 css() 直接改变样式 123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("主元素").css("color","red"); &#125;)&lt;/script&gt; 通过判断 class 属性值是否存在来添加&amp;删除 class 达到修改样式的效果 123456789101112131415161718192021222324252627&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type="text/css"&gt; .img&#123; width: 50%; height: 50%; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("img:eq(0)").click(function () &#123; if($(this).attr("class") != "")&#123; $(this).removeClass("img"); &#125;else&#123; $(this).addClass("img"); &#125; &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="../img/jdr.jpg" class="img"&gt;&lt;br/&gt; &lt;div class="bold"&gt;jdr&lt;/div&gt;&lt;/body&gt; 调用 toggleClass() 函数来针对元素 class 属性值;存在则删除,不存在则添加. 1234567891011121314151617181920212223&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type="text/css"&gt; .img&#123; width: 50%; height: 50%; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("img:eq(0)").click(function () &#123; $(this).toggleClass("img"); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="../img/jdr.jpg" class="img"&gt;&lt;br/&gt; &lt;div class="bold"&gt;jdr&lt;/div&gt;&lt;/body&gt; 插入节点 使用 append() 函数添加节点在指定节点里,节点对象调用 appendTo() 函数把节点添加到指定节点的内容尾部,节点对象调用 insertBefore() 把节点添加到指定节点前.123456789&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; var img =$("&lt;img src='../img/b.jpg' width='200' height='200'/&gt;"); $(指定节点).append(img); img.appendTo(指定节点); img.insertBefore(指定节点); &#125;)&lt;/script&gt; 删除节点 指定节点通过调用 remove() 删除节点.123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js" &gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $(指定节点).remove(); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery过滤选择器]]></title>
    <url>%2F2012%2F12%2F23%2F%E5%89%8D%E7%AB%AF%2FDay41_JQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F04.JQuery%20%E8%BF%87%E6%BB%A4%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤选择器:first 获取所有主元素的第一个元素123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("主元素:first").css("color","green"); &#125;)&lt;/script&gt; :last 获取所有主元素的最后一个元素123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("主元素:last").css("color","green"); &#125;)&lt;/script&gt; :eq(index) 根据索引进行选择123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("主元素:eq(0)").css("color","red"); &#125;)&lt;/script&gt; gt(index) 匹配所有大于给定索引值的元素123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("主标签:gt(1)").css("color","red"); &#125;)&lt;/script&gt; lt(index) 匹配所有小于给定索引值的元素123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("主标签:lt(1)").css("color","red"); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery层次选择器]]></title>
    <url>%2F2012%2F12%2F22%2F%E5%89%8D%E7%AB%AF%2FDay41_JQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F03.JQuery%20%E5%B1%82%E6%AC%A1%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[JQuery层次选择器子代选择器 获取主标签下的子标签123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("#主标签&gt;子标签").css("color","yellow"); &#125;)&lt;/script&gt; 后代选择器 获取主标签下的所有子标签1234567&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("#主标签 子标签").css("color","red"); &#125;)&lt;/script&gt; 兄弟选择器1 获取主标签后的兄弟标签123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("#主标签+兄弟标签").css("color","blue"); &#125;)&lt;/script&gt; 兄弟选择器2 获取同层次主标签后的所有兄弟标签123456&lt;script type="text/javascript" src="../js/jquery-1.8.2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; $("#主标签~兄弟标签").css("color","blue"); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery的基本选择器]]></title>
    <url>%2F2012%2F12%2F21%2F%E5%89%8D%E7%AB%AF%2FDay41_JQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F02.JQuery%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[JQuery 的基本选择器通配符选择器1234567891011121314151617&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.8.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("*").css("display","none"); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;h1&gt;h1标签&lt;/h1&gt; &lt;h2 id="h2"&gt;h2标签&lt;/h2&gt; &lt;h3 class="h3"&gt;h3标签&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt; 标签选择器1234567891011121314151617&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.8.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("h1").css("display","none"); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;h1&gt;h1标签&lt;/h1&gt; &lt;h2 id="h2"&gt;h2标签&lt;/h2&gt; &lt;h3 class="h3"&gt;h3标签&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt; class 选择器标签选择器1234567891011121314151617&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.8.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $(".h3").css("display","none"); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;h1&gt;h1标签&lt;/h1&gt; &lt;h2 id="h2"&gt;h2标签&lt;/h2&gt; &lt;h3 class="h3"&gt;h3标签&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt; ID 选择器1234567891011121314151617&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-1.8.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#h2").css("display","none"); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;h1&gt;h1标签&lt;/h1&gt; &lt;h2 id="h2"&gt;h2标签&lt;/h2&gt; &lt;h3 class="h3"&gt;h3标签&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery的介绍]]></title>
    <url>%2F2012%2F12%2F20%2F%E5%89%8D%E7%AB%AF%2FDay41_JQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F01.JQuery%20%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[JQueryJQuery 的介绍 jQuery 是一个快速、简洁的 JavaScript 框架，是继 Prototype 之后又一个优秀的 JavaScript 代码库（或 JavaScript 框架）。jQuery 设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装 JavaScript 常用的功能代码，提供一种简便的 JavaScript 设计模式，优化 HTML 文档操作、事件处理、动画设计和 Ajax 交互。jQuery 的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的 CSS选择器，并且可对 CSS 选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。 JQuery 语法 jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。 基础语法是：$(selector).action() 美元符号定义 jQuery 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP]]></title>
    <url>%2F2012%2F12%2F19%2F%E5%89%8D%E7%AB%AF%2FDay25_JSP%2F01.JSP%2F</url>
    <content type="text"><![CDATA[什么是 JSP JSP 全称是Java Server Pages，它和 servlet 技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。JSP实际上就是 Servlet JSP这门技术的最大的特点在于，写 jsp 就像在写 html，但它相比 html 而言，html 只能为用户提供静态数据，而 Jsp 技术允许在页面中嵌套 java 代码，为用户提供动态数据 。 不管是 JS P还是 Servlet ，虽然都可以用于开发动态 web 资源。但由于这2门技术有各自的特点， servlet 只负责响应请求产生数据，并把数据通过转发技术带给 jsp，数据的显示交给 jsp 来做, 在长期的软件实践中，人们逐渐把 servlet 作为 web 应用中的控制器组件来使用，而把JSP技术作为数据显示模板来使用 JSP 的内置对象 每个 JSP 页面在第一次被访问时，WEB容器都会把请求交给 JSP 引擎（即一个 Java 程序）去处理。JSP 引擎先将 JSP 翻译成一个 _jspServlet (实质上也是一个 servlet ) ，然后按照 servlet 的调用方式进行调用。 由于 JSP 第一次访问时会翻译成 servlet ，所以第一次访问通常会比较慢，但第二次访问，JSP 引擎如果发现 JSP 没有变化，就不再翻译，而是直接调用，所以程序的执行效率不会受到影响。 JSP 引擎在调用 JSP 对应的 _jspServlet 时，会传递或创建9个与 web 开发相关的对象供 _jspServlet 使用。JSP 技术的设计者为便于开发人员在编写 JSP 页面时获得这些 web 对象的引用，特意定义了9个相应的变量，开发人员在 JSP 页面中通过这些变量就可以快速获得这9大对象的引用。 request response config application exception（只有在page指令中具有属性isErrorPage=”true”时才有效） session page out pageContext JSP 脚本片段 JSP 的脚本片段用于在 JSP 页面中编写 java 代码 123&lt;% 多行java代码%&gt; JSP 脚本表达式 JSP 的脚本表达式用于将程序数据输出到客户端 1&lt;%= new java.util.Date() %&gt; 注意：JSP 的脚本表达式中的变量不能有分号 EL 表达式 使用语法：${} 1$&#123;id&#125; ${ld} 相当于依次从 pageScope-requestScope-sessionScope-applicationScope，查找 ld 的变量，如果有则返回其值，没有则返回 null ，当然如果确定变量位置，可以直接获取，例如 ${requestScope.ld}。除了上述隐含对象，EL把其它内容全部当做某个域中的变量。 JSTL 标签库 JSP Standard Tag Library，JSP 标准标签库，是一个不断完善的开放源代码的 JSP 标签库，它的使用需要容器的支持，可以以优雅的标签方式代替 JSP 中的 Java 代码。JSTL 相比 EL 可以提供更多可控细节。 1234&lt;%--标签库--%&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%--函数库--%&gt;&lt;%@taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象]]></title>
    <url>%2F2012%2F12%2F18%2F%E5%89%8D%E7%AB%AF%2FDay24_JS(%E4%B8%8B)%2F05.JavaScript%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JavaScript 面向对象的概念 JavaScript 中的所有事物都是对象：字符串、数值、数组、函数… 此外，JavaScript 允许自定义对象。 对象的创建 使用 json 格式创建对象 1234567var tea = &#123; name:&apos;jiangdaran&apos;, age:18, test:function () &#123; alert(&quot;json格式创建对象&quot;); &#125;&#125; 使用 new Object（） 方式创建对象，然后再给对象赋属性与方法 1234567var obj = new Object();obj.name = &apos;jiangdaran&apos;;obj.age = 18;obj.test = function () &#123; alert(&quot;new Object()方法创建对象&quot;);&#125; 使用构造方法的方式创建对象 12345678910function teacher(name,age) &#123; this.name = name; this.age = age; this.test = function () &#123; alert(&quot;构造方法的方式创建对象&quot;); &#125;&#125;var tea = new teacher(&apos;jiangdaran&apos;,18);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie]]></title>
    <url>%2F2012%2F12%2F17%2F%E5%89%8D%E7%AB%AF%2FDay24_JS(%E4%B8%8B)%2F04.cookie%2F</url>
    <content type="text"><![CDATA[什么是 cookie cookie 是以键值对的形式保存的，即 key = value 的格式。各个 cookie 之间一般是以“;”分隔。 cookie 是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个 cookie 可用。因此，cookie 可以跨越一个域名下的多个网页，但不能跨越多个域名使用。 cookie 的作用 保存用户的登录状态 定制页面，如换肤，选择所在地区等等 购物车的实现 记录用户的浏览历史记录 cookie 的缺点 cookie 可能被禁用 cookie 是与浏览器相关的，即使访问同一个页面，不同的浏览器保存的 cookie 也是不能互相访问的 cookie 可能被删除，因为 cookie 实际就是硬盘上的一个文件 cookie 的安全性不够高，所有的 cookie 都是以纯文本的形式记录于文件中。 cookie 的使用 cookie 的创建是通过 document 对象调用 cookie 属性 123var date = new Date();date.setTime(date.getTime()+60*60*1000);document.cookie = &quot;username=zs;expires=&quot;+date.toGMTString(); expries 为 cookie 的有效时间，我们可以通过设置 date 对象的时间来给 cookie 设置有效时间 cookie 的销毁，把所需要的 cookie 有效时间设置为当前时间 12var date = new Date();document.cookie =&quot;username=qq;expires=&quot;+date.toGMTString();]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计时器]]></title>
    <url>%2F2012%2F12%2F16%2F%E5%89%8D%E7%AB%AF%2FDay24_JS(%E4%B8%8B)%2F03.%20%E8%AE%A1%E6%97%B6%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[定时器 通过使用 JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。 在 JavaScritp 中使用计时事件是很容易的，两个关键方法是: setTimeout() - 在指定的毫秒数后执行指定代码。 setInterval() - 间隔指定的毫秒数不停地执行指定的代码。 注意: setInterval() 和 setTimeout() 是 HTML DOM Window对象的两个方法。 setTimeout() 方法 setTimeout() 指定的毫秒数执行指定的代码 语法： 1myVar= window.setTimeout(&quot;javascript function&quot;, milliseconds); setTimeout() 方法会返回某个值。如果你希望取消这个 setTimeout()，你可以使用这个变量名来指定它。 setTimeout() 的第一个参数是含有 JavaScript 语句的字符串。这个语句可能诸如 “alert(‘Hello World’)”，或者对函数的调用，诸如 alertMsg。 第二个参数指示从当前起多少毫秒后执行第一个参数。 提示：1000 毫秒等于一秒。 案例： 123456timer = setTimeout(function ()&#123; alert(&quot;今天又是每好的一天&quot;);&#125;,3000); setInterval() 方法 setInterval() 间隔指定的毫秒数不停地执行指定的代码 语法： 1myVar = window.setInterval(&quot;javascript function&quot;,milliseconds); setInterval() 第一个参数是函数（function）。 第二个参数间隔的毫秒数 注意: 1000 毫秒是一秒。 案例：123456timer = setInterval(function ()&#123; alert(&quot;今天又是每好的一天&quot;);&#125;,1000); 停止执行计时事件 clearInterval() 方法用于停止 setInterval() 方法执行的函数代码。 clearTimeout() 方法用于停止执行setTimeout()方法的函数代码。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM事件]]></title>
    <url>%2F2012%2F12%2F15%2F%E5%89%8D%E7%AB%AF%2FDay24_JS(%E4%B8%8B)%2F02.DOM%20%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[onload事件 onload 事件会在页面加载完毕后用户进入时被触发。 一般可以来做一些网页的环境准备工作 12345678910&lt;script type=&quot;text/javascript&quot;&gt; onload = function () &#123; var divObj = document.getElementById(&quot;div&quot;); alert(divObj); &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt;盒子标签&lt;/div&gt;&lt;/body&gt; onkeydown 与 onkeyup 事件 onkeydown 事件是在监听用户按下键盘按键 onkeyup 事件是在监听用户松开键盘按键 案例：输入小写字母转换成大写字母 onmouseover 与 onmouseout 事件 onmouseover 事件是监听用户把鼠标移动到 HTML 元素上 onmouseout 事件是监听用户把鼠标移出 HTML 元素 案例：改变按钮的value值 onchange 事件 onchang 事件监听 HTML 是否被改变 案例：下拉框改变选项 onfocus 和 onblur 事件 onfocus 事件是获取焦点事件 onblur 事件是失去焦点事件 案例：用户名非空判断]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM对象操作元素]]></title>
    <url>%2F2012%2F12%2F14%2F%E5%89%8D%E7%AB%AF%2FDay24_JS(%E4%B8%8B)%2F01.DOM%20%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[修改元素的内容 我们可以通过元素对象调用 innerHTML 属性来修改元素内容123456&lt;div&gt;美好的一天&lt;/div&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var div = document.getElementById(&quot;div1&quot;); div.innerHTML =&quot;在于学习&quot;;&lt;/script&gt; 修改元素的属性 我们可以通过元素对象直接调用需要修改的属性来进行赋值 123456789101112131415161718192021222324 &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var flag = true; function change() &#123; var img = document.getElementsByTagName(&quot;img&quot;)[0]; if(flag) &#123; img.src = &quot;../img/a.jpg&quot;; flag = false; &#125; else&#123; img.src = &quot;../img/b.jpg&quot;; flag = true; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;../img/a.jpg&quot;&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;改变&quot; onclick=&quot;change()&quot;&gt;&lt;/body&gt; 修改元素的样式 我们可以通过元素对象调用 style 属性来进行赋值 1234567891011121314151617&lt;body&gt; &lt;div&gt;学习&lt;/div&gt;&lt;div &gt;改变命运&lt;/div&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;隐藏&quot; onclick=&quot;myHidden()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;显示&quot; onclick=&quot;myVisible()&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; var div = document.getElementsByTagName(&quot;div&quot;)[1]; function myHidden() &#123; div.style.visibility = &quot;hidden&quot;; &#125; function myVisible() &#123; div.style.visibility = &quot;visible&quot;; div.style.color=&quot;red&quot;; &#125; &lt;/script&gt;&lt;/body&gt; 添加元素 我们可以通过调用 document 的 createElement 函数来创建元素对象 1234567891011121314151617 &lt;script type=&quot;text/javascript&quot;&gt; onload = function () &#123; var input = document.getElementById(&quot;input&quot;); input.onclick = function () &#123; var img = document.createElement(&quot;img&quot;); img.src = &quot;../img/d.jpg&quot;; var body = document.getElementsByTagName(&quot;body&quot;)[0]; body.appendChild(img); &#125; &#125;&lt;/script&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;input&quot;&gt;&lt;br/&gt; &lt;img src=&quot;../img/d.jpg&quot;&gt;&lt;/body&gt; 我们也可以通过元素对象的 cloneNode 函数来克隆元素 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; onload = function () &#123; var input = document.getElementById(&quot;input&quot;); input.onclick = function () &#123; var img = document.getElementsByTagName(&quot;img&quot;)[0]; var newImg = img.cloneNode(); var body = document.getElementsByTagName(&quot;body&quot;)[0]; body.appendChild(newImg); &#125; &#125;&lt;/script&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;input&quot;&gt;&lt;br/&gt; &lt;img src=&quot;../img/d.jpg&quot;&gt;&lt;/body&gt; 注意：cloneNode 函数可以传递 boolean 类型的参数，默认为false，只克隆当前元素。如果为true，则克隆子标签 删除元素 我们可以通过元素对象的 remove 函数删除元素 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; onload = function () &#123; var input = document.getElementsByTagName(&quot;input&quot;)[0]; input.onclick=function () &#123; var img = document.getElementsByTagName(&quot;img&quot;)[0]; img.remove(); &#125; &#125; &lt;/script&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;删除&quot;&gt;&lt;br/&gt; &lt;img src=&quot;../img/img2.jpg&quot;&gt; &lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM对象]]></title>
    <url>%2F2012%2F12%2F13%2F%E5%89%8D%E7%AB%AF%2FDay23_JS(%E4%B8%8A)%2F07.%20BOM%20%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是 BOM 对象 BOM（Browser Object Model）对象指的是浏览器对象模型，它可以使 JavaScript 有能力与浏览器“对话”。 window 对象 所有浏览器都支持 window 对象。它表示浏览器窗口。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 甚至 HTML DOM 的 document 也是 window 对象的属性之一：1window.document.getElementById(&quot;div&quot;); 与此相同：1document.getElementById(&quot;div&quot;); window.location Location属性是一个用于存储当前载入页面URL信息的对象。 实现当前页面的跳转12window.location.href = &quot;http://www.baidu.com&quot;;location.href = &quot;http://www.baidu.com&quot;; 重新加载页面 12window.location.reload();location.reload(); window.history 操作同一个浏览器会话中的已访问页面12345678// 返回history.back()history.go(-1)// 前进history.forward()histroy.go(1)// 刷新histroy.go(0) window.open 操作浏览器访问链接地址 1window.open(&quot;http://www.baidu.com&quot;,&quot;baidu&quot;); 弹出框警告框 警告框经常用于确保用户可以得到某些信息。 当警告框出现后，用户需要点击确定按钮才能继续进行操作。1alert(&quot;文本&quot;) 确认框 确认框用于使用户可以验证或者接受某些信息。 当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。如果用户点击确认，那么返回值为 true。如果用户点击取消，那么返回值为 false。 1confirm(&quot;文本&quot;) 提示框 提示框经常用于提示用户在进入页面前输入某个值。 当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。 如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。 1prompt(&quot;文本&quot;,&quot;默认值&quot;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM对象]]></title>
    <url>%2F2012%2F12%2F12%2F%E5%89%8D%E7%AB%AF%2FDay23_JS(%E4%B8%8A)%2F06.DOM%20%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是 DOM 对象 DOM 对象是文档对象模型，在网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被构造为对象的树： DOM对象的作用 通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML。 JavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 查找元素 通常，通过 JavaScript，您需要操作 HTML 元素。 为了做到这件事情，您必须首先找到该元素。有三种方法来做这件事： 通过 id 找到 HTML 元素 通过标签名找到 HTML 元素 通过类名找到 HTML 元素 1234567891011&lt;div id=&quot;div1&quot; class=&quot;div2&quot; name=&quot;div3&quot;&gt;盒子标签&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 根据id属性获取元素对象 var id = document.getElementById(&quot;div1&quot;); // 根据class属性获取元素集合 var className = document.getElementsByClassName(&quot;div2&quot;)[0]; // 根据标签名获取元素集合 var tagName = document.getElementsByTagName(&quot;div&quot;)[0]; // 根据name属性获取元素集合 var name = document.getElementsByName(&quot;div3&quot;)[0];&lt;/script&gt; 案例 全选按钮的实现]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的函数]]></title>
    <url>%2F2012%2F12%2F11%2F%E5%89%8D%E7%AB%AF%2FDay23_JS(%E4%B8%8A)%2F05.JavaScript%20%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[JavaScript 函数的定义 JavaScript 函数通过 function 关键词进行定义，其后是函数名和括号 ()。函数名可包含字母、数字、下划线和美元符号（规则与变量名相同）。圆括号可包括由逗号分隔的参数： 1(参数 1, 参数 2, ...) 由函数执行的代码被放置在花括号中：{} 123function name(参数 1, 参数 2, 参数 3) &#123; 要执行的代码&#125; 函数参数（Function parameters）是在函数定义中所列的名称。 函数参数（Function arguments）是当调用函数时由函数接收的真实的值。 在函数中，参数是局部变量。 带有返回值的函数 有时，我们会希望函数将值返回调用它的地方。 通过使用 return 语句就可以实现。 在使用 return 语句时，函数会停止执行，并返回指定的值。 12345function MyFunction()&#123; var x=5; return x;&#125; 上面的函数会返回值 5。 注意： 整个 JavaScript 并不会停止执行，仅仅是函数。JavaScript 将继续执行代码，从调用函数的地方。 函数调用将被返回值取代： 1var myVar=MyFunction(); myVar 变量的值是 5，也就是函数 “myFunction()” 所返回的值。 arguments 关键字 在 JavaScript 中不存在函数的重载，只存在覆盖，也没有可变参数 arguments 类似于 java 的可变参数，会自动接收调用方法传递的参数， arguments 本质是数组。 123456789function add() &#123; var sum = 0; for (var i in arguments)&#123; sum += arguments[i]; &#125; console.log(sum);&#125;add(1,2);add(1,2,3,4);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的分支语句]]></title>
    <url>%2F2012%2F12%2F10%2F%E5%89%8D%E7%AB%AF%2FDay23_JS(%E4%B8%8A)%2F04.JavaScript%20%E7%9A%84%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[JavaScript 的if语句 通常在写代码时，您总是需要为不同的决定来执行不同的动作。您可以在代码中使用条件语句来完成该任务。 在 JavaScript 中，我们可使用以下条件语句： if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码 if…else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码 if…else if….else 语句- 使用该语句来选择多个代码块之一来执行 JavaScript 中，不仅仅只能使用 boolean 进行判断，还可以使用各种类型的数据当做 if 的关系表达式，例如：12345678if(0)&#123; console.log(&quot;true&quot;);&#125;else&#123; console.log(&quot;false&quot;);&#125; JavaScript 的 switch 语句 使用 switch 语句来选择要执行的多个代码块之一。 在JavaScript 中，switch 语句的表达式可以存放 boolean 的值。 123456789switch (false)&#123; case true: console.log(&quot;true&quot;); break; case false: console.log(&quot;false&quot;); break;&#125; JavaScript 的 for 循环 for 循环是您在希望创建循环时常会用到的工具。 下面是 for 循环的语法： 1234for (语句 1; 语句 2; 语句 3)&#123; 被执行的代码块&#125; 语句 1 （代码块）开始前执行 语句 2 定义运行循环（代码块）的条件 语句 3 在循环（代码块）已被执行之后执行 案例： 1234for(var i = 0;i &lt; 10;i++)&#123; console.log(i);&#125; JavaScript 的 for/in 循环 for/in 遍历数组。 12345678//数组定义var nums = [2,5,7];//for -in --i为索引而不是数组中的元素for(var i in nums)&#123; console.log(nums[i]);&#125; JavaScript 的 while 循环 while 循环会在指定条件为真时循环执行代码块。1234while (条件)&#123; 需要执行的代码&#125; JavaScript 的 do/while 循环 do/while 循环是 while 循环的变体。该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。12345do&#123; 需要执行的代码&#125;while (条件)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的运算符]]></title>
    <url>%2F2012%2F12%2F09%2F%E5%89%8D%E7%AB%AF%2FDay23_JS(%E4%B8%8A)%2F03.JavaScript%20%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[JavaScript 的运算符算术运算符 给定y = 1，下面的表格解释了这些算术运算符： 运算符 描述 案例 X的结果 y的结果 + 加法 x = y + 1 2 1 - 减法 x = y - 1 0 1 * 乘法 x = y * 2 2 1 / 除法 x = y / 2 0.5 1 % 取模(取余) x = y % 2 1 1 ++ 自增 x = ++y 2 2 x = y++ 1 2 – 自减 x = –y 0 0 x = y– 1 0 赋值运算符 给定 x=10 和 y=5，下面的表格解释了赋值运算符: 运算符 例子 等同于 运算结果 = x = y x = 5 += x += y x = x + y x = 15 -= x -= y x = x - y x = 5 *= x *= y x = x * y x = 5 /= x /= y x = x / y x= 2 %= x %= y x = x % y x = 0 JavaScript 比较运算符 运算符 描述 == 等于 === 等值等型 != 不相等 !== 不等值或不等型 &gt; 大于 &lt; 小于 &gt;= 大于或等于 &lt;= 小于或等于 ? 三元运算符 JavaScript 逻辑运算符 运算符 描述 &amp;&amp; 逻辑与 双竖杆 逻辑或 ! 逻辑非]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的基本语法]]></title>
    <url>%2F2012%2F12%2F08%2F%E5%89%8D%E7%AB%AF%2FDay23_JS(%E4%B8%8A)%2F02.JavaScript%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript 的语法 JavaScript 是一个程序语言。语法规则定义了语言结构。 在编程语言中，一般固定值称为字面量，如 3.14。 数字（Number）字面量 可以是整数或者是小数，或者是科学计数(e)。 标签 如需在 HTML 页面中插入 JavaScript，请使用 标签。 和 会告诉 JavaScript 在何处开始和结束。 和 之间的代码行包含了 JavaScript:123&lt;script&gt; alert(&quot;Hello World&quot;);&lt;/script&gt; JavaScript 变量 JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值： 1234567// 使用小数点来写var x1=34.00;// 不使用小数点来写var x2=34;// 浏览器控制台打印console.log(x1);console.log(x2); 注:定义的变量是没有数据类型，只有在赋值后才有数据类型 JavaScript 变量的生命周期 JavaScript 变量的生命期从它们被声明的时间开始。 局部变量会在函数运行以后被删除。 全局变量会在页面关闭后被删除。 JavaScript 的数据类型 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。 引用数据类型：对象(Object)、数组(Array)、函数(Function)。 JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的介绍]]></title>
    <url>%2F2012%2F12%2F07%2F%E5%89%8D%E7%AB%AF%2FDay23_JS(%E4%B8%8A)%2F01.JavaScript%20%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是javaScript JavaScript 是基于对象和事件驱动的脚本语言，主要是嵌入到HTML中，应用在客户端，动态操作网页元素，也可以作用于服务端。 特点:交互性（表单校验，信息提示，动态数据图表，ajax异步提交，解析服务端响应数据等等）安全性（不可以直接访问本地硬盘）跨平台性（由浏览器解析执行，和平台无关） javaScript的作用JavaScript 是 web 开发者必学的三种语言之一： HTML 定义了网页的内容 CSS 描述了网页的布局 JavaScript 网页的行为 Java Vs JavaScript JavaScript 和 Java 是完全不同的语言，不论是概念还是设计。 JavaScript 在 1995 年由 Brendan Eich 发明，并于 1997 年成为一部 ECMA 标准。JavaScript只需浏览器解析就可以执行，而java需要先编译成字节码文件，然后通过JVM来执行。 JavaScript 是一种弱类型语言，java是强类型语言。 强类型：类型具有规范化：int、float、double、long…Student(对象类型) 弱类型: 定义值的时候var类型，执行时才确定不同类型 JavaScript的组成 一个完整 JavaScript实现由以下3个部分组成]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2012%2F12%2F06%2F%E5%89%8D%E7%AB%AF%2FDay22_CSS%2F06.%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[什么是盒子模型 HTML div 元素是块级元素，它可用于组合其他 HTML 元素的容器。 div 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 如果与 CSS 一同使用，div 元素可用于对大的内容块设置样式属性。 div 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。 盒子模型的概念 CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框和 外边距的方式。 定位 CSS 定位 (Positioning) 属性允许你对元素进行定位。定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。 CSS 定位机制CSS 有三种基本的定位机制：普通流(相对定位)、浮动和绝对定位。除非专门指定，否则所有框都在普通流中定位。也就是说，普通流中的元素的位置由元素在 (X)HTML 中的位置决定。块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。 相对定位 相对于原有的位置发生改变，并且保留原有的空间位置。 123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #one&#123; border: solid red 3px; &#125; #two&#123; border: solid green 3px; /*相对定位*/ position: relative; top:10px; left: 10px; &#125; #three&#123; border: solid blue 3px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;one&quot;&gt;第一个盒子&lt;/div&gt; &lt;div id=&quot;two&quot;&gt;第二个盒子&lt;/div&gt; &lt;div id=&quot;three&quot;&gt;第三个盒子&lt;/div&gt;&lt;/body&gt; 绝对定位 绝对定位相对于他有position属性的父级元素进行定位，如果父级元素没有postion定位，那么就找父级的父级，直到向上找到position定位为止，如果他向上找不到position定位，那么就以最外层的body进行定位。 并且绝对定位不会保留原有的位置空间。 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #one&#123; border: solid red 3px; &#125; #two&#123; border: solid green 3px; /*绝对定位*/ position: absolute; top:1px; &#125; #three&#123; border: solid blue 3px; &#125; #parent&#123; position: relative; border: solid black 3px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;one&quot;&gt;第一个盒子&lt;/div&gt; &lt;div id=&quot;two&quot;&gt;第二个盒子&lt;/div&gt; &lt;div id=&quot;three&quot;&gt;第三个盒子&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 浮动 浮动可以帮助我们更好进行页面排版，使原本竖着排列的盒子可以横向排列起来。 副作用：因为浮动会使元素脱离了标准的文档流，从而导致父级元素无法被撑开。 解决办法：添加空盒子在被浮动的元素后面，添加一个空的div，并且设置一个clear类，并付给该div.clear{clear:both;}1234567891011121314151617181920212223242526272829303132&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #one&#123; border: solid red 2px; height: 100px; width: 100px; float: left; &#125; #two&#123; border: solid blue 2px; height: 100px; width: 100px; float: left; &#125; #parent&#123; border: solid green 2px; /*height: 100px;*/ &#125; #three&#123; clear:both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;one&quot;&gt;第一个盒子&lt;/div&gt; &lt;div id=&quot;two&quot;&gt;第二个盒子&lt;/div&gt; &lt;div id=&quot;three&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的CSS属性]]></title>
    <url>%2F2012%2F12%2F05%2F%E5%89%8D%E7%AB%AF%2FDay22_CSS%2F05.%E5%B8%B8%E7%94%A8%E7%9A%84%20CSS%20%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[字体属性属性名称 font-family:字体样式类型 font-size:字体的大小 font-style:字体类型 font-weight:字体加粗 文本属性属性名称 letter-spacing:字母间隔 text-decoration:划线修饰 text-align:文本对齐方式 text-indent:文本缩进 line-height:行高 背景属性名称 background-color:背景颜色 background-image:背景图片 background-repeat:平铺状态 边框属性名称 border:边框 solid(实线) dashed(虚线) double(双实线)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的样式分类]]></title>
    <url>%2F2012%2F12%2F04%2F%E5%89%8D%E7%AB%AF%2FDay22_CSS%2F04.CSS%20%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[样式的分类 插入样式表的方法有三种: 内联样式(Inline style) 内部样式表(Internal style sheet) 外部样式表(External style sheet) 内联样式: 由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。1&lt;h1 style=&quot;color: pink&quot;&gt;标题标签&lt;/h1&gt; 内部样式: 当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 标签在文档头部定义内部样式表 123456789&lt;style type=&quot;text/css&quot;&gt; #h1&#123; color: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;h1 id=&quot;h1&quot;&gt;标题标签&lt;/h1&gt;&lt;/body&gt; 外部样式: 当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 标签链接到样式表。 标签在（文档的）头部： 1&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../css/style.css&quot;&gt; 样式的优先级别 内联样式&gt;内部样式&amp;外部样式]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器 (下)]]></title>
    <url>%2F2012%2F12%2F03%2F%E5%89%8D%E7%AB%AF%2FDay22_CSS%2F03.CSS%20%E9%80%89%E6%8B%A9%E5%99%A8(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[属性选择器 属性选择器可以选择包含某个属性的元素 1234567891011121314&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *[title][id]&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot; title=&quot;title1&quot;&gt;盒子标签&lt;/div&gt; &lt;h1 title=&quot;title1&quot;&gt;标题标签&lt;/h1&gt; &lt;p&gt;段落标签&lt;/p&gt;&lt;/body&gt; 派生选择器 派生选择器又称之为后代选择器（descendant selector）又称为包含选择器。 派生选择器可以选择作为某元素后代的元素。 1234567891011121314151617&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; ul li&#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;无序列表1 &lt;li&gt;孙子列表&lt;/li&gt; &lt;p&gt;123&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 相邻兄弟选择器 相邻兄弟选择器可以选择某个元素相邻的元素 相邻选择器以一个”+”号显示 12345678910111213141516&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; li+li&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 锚伪类选择器 在支持 CSS 的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。 12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*未访问状态*/ a:link&#123; color: red; &#125; /*已访问状态*/ a:visited&#123; color: pink; &#125; /*鼠标悬停状态*/ a:hover&#123; color: yellow; &#125; /*鼠标点击状态*/ a:active&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;#&quot;&gt;a标签&lt;/a&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器 (上)]]></title>
    <url>%2F2012%2F12%2F02%2F%E5%89%8D%E7%AB%AF%2FDay22_CSS%2F02.CSS%20%E9%80%89%E6%8B%A9%E5%99%A8(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[通配符选择器 匹配所有的元素 通配符选择器:*{属性:属性值}123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;标题标签&lt;/h1&gt; &lt;p&gt;段落标签&lt;/p&gt;&lt;/body&gt; 标签选择器 标签选择器可以为当前HTML所有的标签 指定特定的样式。 1234567891011121314&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; p&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;标题标签&lt;/h1&gt; &lt;p&gt;段落标签1&lt;/p&gt; &lt;p&gt;段落标签2&lt;/p&gt;&lt;/body&gt; id 选择器 id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。 1234567891011121314 &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #son&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;标题标签&lt;/h1&gt; &lt;p id=&apos;son&apos;&gt;段落标签1&lt;/p&gt; &lt;p id=&apos;parent&apos;&gt;段落标签2&lt;/p&gt;&lt;/body&gt; class 选择器 class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点”.”号显示： 123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .son&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;标题标签1&lt;/h1&gt; &lt;h1 class=&quot;son&quot;&gt;标题标签2&lt;/h1&gt; &lt;p class=&quot;son&quot;&gt;段落标签1&lt;/p&gt; &lt;p&gt;段落标签2&lt;/p&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的介绍]]></title>
    <url>%2F2012%2F12%2F01%2F%E5%89%8D%E7%AB%AF%2FDay22_CSS%2F01.CSS%20%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是CSS CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 是为了解决内容与表现分离的问题 多个样式定义可层叠为一 样式通常存储在样式表中 CSS的语法 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明: 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架标签]]></title>
    <url>%2F2012%2F11%2F30%2F%E5%89%8D%E7%AB%AF%2FDay21HTML%2F06.%E6%A1%86%E6%9E%B6%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[框架标签的作用 通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。 框架结构标签（）定义如何将窗口分割为框架 每个 frameset 定义了一系列行或列 rows/columns 的值规定了每行或每列占据屏幕的面积 框架标签的使用 Frame 标签定义了放置在每个框架中的 HTML 文档。 在下面的这个例子中，我们设置了一个两列的框架集。第一列被设置为占据浏览器窗口的 25%。第二列被设置为占据浏览器窗口的 75%。 HTML 文档 “frame_a.htm”被置于第一个列中，而 HTML 文档 “frame_b.htm” 被置于第二个列中： 12345&lt;frameset cols=&quot;25%,75%&quot;&gt; &lt;frame src=&quot;frame_a.htm&quot;&gt; &lt;frame src=&quot;frame_b.htm&quot;&gt; &lt;frame src=&quot;frame_c.htm&quot;&gt;&lt;/frameset&gt; 混合框架结构1234567&lt;frameset rows=&quot;50%,50%&quot;&gt; &lt;frame src=&quot;frame_a.htm&quot;&gt; &lt;frameset cols=&quot;25%,75%&quot;&gt; &lt;frame src=&quot;frame_b.htm&quot;&gt; &lt;frame src=&quot;frame_c.htm&quot;&gt; &lt;/frameset&gt;&lt;/frameset&gt; 框架标签的注意事项 假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在 标签中加入：noresize=”noresize”。 不能将 L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false}); 标签与 标签同时使用！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单标签]]></title>
    <url>%2F2012%2F11%2F29%2F%E5%89%8D%E7%AB%AF%2FDay21HTML%2F05.%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[表单标签 HTML 表单用于收集用户输入。 元素定义 HTML 表单： 1234&lt;form&gt; . 用户名：&lt;input type=&apos;text&apos;/&gt; ...&lt;/form&gt; HTML 表单包含表单元素。 表单元素指的是不同类型的 input 元素、复选框、单选按钮、提交按钮等等。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表格标签]]></title>
    <url>%2F2012%2F11%2F28%2F%E5%89%8D%E7%AB%AF%2FDay21HTML%2F04.%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[表格标签 表格由 table 标签来定义。每个表格均有若干行（由 tr 标签定义），每行被分割为若干单元格（由 td 标签定义）。 字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 完整的表格： 1234567891011&lt;table border=&quot;1&quot; cellspacing=&quot;&quot; cellpadding=&quot;&quot;&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;Header&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;Data&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt;&lt;td&gt;Data&lt;/td&gt;&lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表标签]]></title>
    <url>%2F2012%2F11%2F27%2F%E5%89%8D%E7%AB%AF%2FDay21HTML%2F03.%E5%88%97%E8%A1%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[无序列表 无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。 -无序列表始于 ul 标签。每个列表项始于 li。1234&lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 有序列表 同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 ol 标签。每个列表项始于 li 标签。 1234&lt;ol&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; 自定义列表 自定义列表不仅仅是一列项目，而是项目及其注释的组合。 自定义列表以 dl 标签开始。每个自定义列表项以 dt 开始。每个自定义列表项的定义以 dd 开始。 123456&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt;&lt;dd&gt;Black hot drink&lt;/dd&gt;&lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;White cold drink&lt;/dd&gt;&lt;/dl&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的HTML标签]]></title>
    <url>%2F2012%2F11%2F26%2F%E5%89%8D%E7%AB%AF%2FDay21HTML%2F02.%E5%B8%B8%E7%94%A8%E7%9A%84HTML%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[标题标签 h 标签为标题标签，一共分为6个，h1 - h6 数字越大的标签展示的内容越小 段落标签 p 标签为段落标签，每一个 p 标签之间为一个段落 图片标签 img 为图片标签，主要属性为 src 属性，用来定位图片 超链接 a 标签为超链接标签，超链接可以是一个字一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。 我们通过使用 标签在 HTML 中创建链接。有两种使用 标签的方式： 通过使用 href 属性 - 创建指向另一个文档的链接 通过使用 name 属性 - 创建文档内的书签 案例一：掌握href属性，跳转到另一个文档1&lt;a href=&quot;http://www.baidu.com/&quot; target=&quot;_blank&quot;&gt;baidu&lt;/a&gt; 案例二：链接到不同目录的文件时，如何处理？ 案例三：制作图像链接 案例四：掌握name属性，创建锚链接在文档的某个位置，设置锚点1&lt;a name=&quot;C4&quot;&gt;Demo&lt;/a&gt; 在文档的某个位置，关联到该锚点1&lt;a href=&quot;#C4&quot;&gt;查看 Demo&lt;/a&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML的介绍]]></title>
    <url>%2F2012%2F11%2F25%2F%E5%89%8D%E7%AB%AF%2FDay21HTML%2F01.HTML%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是 HTML HTML（英文 Hyper Text Markup Language 的缩写）中文译为“超文本标记语言”，主要是通过HTML标记对网页中的文本、图片、声音等内容进行描述。 HTML提供了许多标记，如段落标记、标题标记、超链接标记、图片标记等，网页中需要定义什么内容，就用相应的 HTML 标记描述即可。 超文本：图文并茂–视频、音频、图片、文本内容等等 标记语言： 通过标签进行开发 HTML 的结构 补充：在head标签里面还可以设置 ，来设置编码类型]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2012%2F11%2F24%2FJavaEE%2F19.JSON%2FJSON%2F</url>
    <content type="text"><![CDATA[JSON1、JSON概述JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 2、JSON语法规则JSON的语法规则非常的简单，就是使用 大括号：{} 中括号：[] 逗号：， 冒号：： 双引号：“” 数据类型：嵌套对象、数组、字符串、数字、布尔值或空值。 我们在JSON解析中只有三种情况出现： {} 解析’大括号’类型 [] 解析是’中括号’类型 其实只有两种，那第三种则是1与2的组合方法即{’name’:’李书豪’ ，’hobby’:[‘编程’,’电竞’,’睡觉’]｝那么下面分别来看一些这三种类型以及解析 2.1、JSON基本语法与图例 Object(对象类型) 用{ }包含一系列无序的key–Value键值对表示，其中Key和Value之间用冒号分割，每个key-value之间用逗号分割。 Array(数组类型) 使用[ ]包含所有元素，每个元素用逗号分隔，元素可以是任意的值 组合型 3、JSON解析 Object(对象类型)解析 Array(数组类型)解析 组合解析 4、对象转JSON]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[filter]]></title>
    <url>%2F2012%2F11%2F23%2FJavaEE%2F18.Java%20Web(%E4%B8%8B)%2F05.filter%2F</url>
    <content type="text"><![CDATA[5、filter1、Filter概述1.1、什么是过滤器过滤器是执行过滤任务的对象，这些任务是针对对某一资源（servlet 或静态内容）的请求或来自某一资源的响应执行的，抑或同时针对这两者执行。 1.2、过滤器的使用场合 对请求和响应进行统一处理 对请求进行日志记录和审核 对数据进行屏蔽和替换 对数据进行加密和解密 2、Filter的工作原理 3、过滤器的生命周期 实例化 初始化 执行过滤 销毁 ​ 1) web服务器启动时创建Filter，会调用init()方法进行初始化，​ 2) 当接收到客户端请求时，会调用doFilter(),​ 3) 当web服务器关闭时调用destroy()方法进行资源的销毁。 4、过滤器的配置与使用4.1、Filter API 返回值 方法 描述 void init(FilterConfig filterConfig) Web容器调用该方法实现过滤器的初始化 void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 客户端请求资源时，Web容器会调用与资源对应的过滤器的doFilter()方法。在该方法中，可以对请求和响应进行处理，实现过滤器的功能。 void destory() Web容器调用该方法，造成过滤器失效 注意：Filter接口没有实现类，编写过滤器必须要实现该接口。 Filter 用 doFilter 方法执行过滤。每个 Filter 都有对 FilterConfig 对象的访问权，可从该对象获得其初始化参数以及对它可以使用的 ServletContext 的引用，以便为过滤任务加载所需的资源。 4.2、过滤器的配置&lt;示例：使用过滤器计算请求耗时&gt; 4.3、过滤器链多个过滤器组成过滤器链。 过滤器链的执行顺序分二种： 在web.xml中配置 web服务器启动时，如果配置了多个过滤，按类名的字典顺序执行 处理请求时，如果配置了多个过滤，按配置的先后顺序执行 12345678910111213141516# 服务器启动时EncodingFilter init... TimeFilter init...[2019-05-31 10:29:41,511] Artifact day20:war exploded: Artifact is deployed successfully[2019-05-31 10:29:41,512] Artifact day20:war exploded: Deploy took 802 milliseconds# 接收到客户端请求了TimeFilter doFilter...EncodingFilter doFilter...总耗时：1097TimeFilter doFilter...EncodingFilter doFilter...总耗时：1# web服务器关闭时EncodingFilter destroy...TimeFilter destroy... 配置注解版：@WebFilter 按Filter的类名的字典顺序执行 4.4、获取初始化参数]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie]]></title>
    <url>%2F2012%2F11%2F22%2FJavaEE%2F18.Java%20Web(%E4%B8%8B)%2F04.cookie%2F</url>
    <content type="text"><![CDATA[4、cookie1、概述Cookie技术是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器时，就会带着各自的数据过去，这样web服务器处理的就是用户各自的数据了。 使用场景： 记录用户的事件 浏览历史记录 用户名和密码的记录 2、cookie定义1public class Cookie implements Cloneable; cookie 是 servlet 发送到 Web 浏览器的少量信息，这些信息由浏览器保存，然后发送回服务器。cookie 的值可以唯一地标识客户端，因此 cookie 常用于会话管理。 3、API构造方法： 1Cookie cookie=new Cookie(String key,Object value); 用一个name-value对定义一个cookie。 返回值 方法 描述 public String getName() 返回 cookie 的名称。名称在创建之后不得更改。 public String getValue() 返回 cookie 的值。 public void setValue(String newValue) 在创建 cookie 之后将新值分配给 cookie。如果使用二进制值，则可能需要使用 BASE64 编码。 public void setMaxAge(int expiry) 设置 cookie 的最大生存时间，以秒为单位。正值表示 cookie 将在经过该值表示的秒数后过期。注意，该值是 cookie 过期的最大 生存时间，不是 cookie 的当前生存时间。负值意味着 cookie 不会被持久存储，将在 Web 浏览器退出时删除。0 值会导致删除 cookie。 public int getMaxAge() 返回以秒为单位指定的 cookie 的最大生存时间，默认情况下，-1 指示该 cookie 将保留到浏览器关闭为止。 4、示例&lt;示例：使用cookie自动填写用户名&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session]]></title>
    <url>%2F2012%2F11%2F21%2FJavaEE%2F18.Java%20Web(%E4%B8%8B)%2F03.session%2F</url>
    <content type="text"><![CDATA[3、session1、session定义1public interface HttpSession; 这个接口被Servlet引擎用来实现在HTTP客户端和HTTP会话两者的关联。这种关联可能在多外连接和请求中持续一段给定的时间。session用来在无状态的HTTP协议下越过多个请求页面来维持状态和识别用户。 在WEB开发中，服务器可以为每个客户端浏览器创建一个session对象，默认情况下一个浏览器独占一个session对象。在实际应用当中，服务器程序可以把一些敏感数据写到用户浏览器独占的session中可以提高安全性，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 我们知道，request对象解决了同一个请求不同servlet的数据共享问题。那么，同一用户下的不同请求的数据该如何共享呢？那么就需要用到Session对象的相关知识了！实质上，它也用到了cookie技术。为什么这么说呢，用户使用浏览器第一次向服务器发送请求，服务器在接受到请求后，调用对应的 Servlet 进行处理。在处理过程中会给用户创建一个 session 对象，用来存储用户请求处理相关的公共数据，并将此 session 对象的 JSESSIONID 以 Cookie 的形式存储在浏览器中(临时存储，浏览器关闭即失效)。用户在发起第二次请求及后续请求时，请求信息中会附带 JSESSIONID，服务器在接收到请求后，调用对应的 Servlet 进行请求处理，同时根据 JSESSIONID 返回其对应的session对象。 session保存在服务器，而sessionId通过Cookie发送给客户端，但这个Cookie的生命周期只在浏览器内存中存在，也就是说如果用户关闭了浏览器，那么这个Cookie就丢失了。当用户再次打开浏览器访问服务器时，就不会有sessionId发送给服务器，那么服务器会认为你没有session，所以服务器会创建一个session，并在响应中把sessionId中的Cookie发送给客户端。那么原来的session对象会怎么样呢？当一个session长时间没人使用的话，服务器会把session删除了，这个时长在tomcat中配置是30分钟，可以在tomcat-xxx/conf/web.xml中找到这个配置。 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 2、特点 存储于服务器端 依赖于cookie，存储浏览端JSESSIOND 它的有效期为一个会话，即浏览器关闭时消失 3、示例 返回值 方法 描述 void setAttribute(String key,Object obj) 以key/value形式保存数据 Object getAttribute(String key) 通过key获取数据 String getId() 获取sessionId void invalidate() 设置session对象失效，当session失效后，客户端再次请求，服务器会给客户端创建一个新的session，并在响应中给客户端新session的sessionId void setMaxInactiveInterval(int interval) 设置session允许的最大不活动时间（秒），如果设置为1秒，那么只要session在1秒内不被使用，那么session就会被移除 void removeAttribute(String key) 从会话中移除属性 boolean isNew() 查看session是否为新创建的session，当客户端第一次请求时，服务器为客户端创建session，但这时服务器还没有响应客户端，也就是还没有把sessionId响应给客户端时，这时的session的状态就为新创建的session。 &lt;示例：用户必须通过登录才能访问网站主页&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[response]]></title>
    <url>%2F2012%2F11%2F20%2FJavaEE%2F18.Java%20Web(%E4%B8%8B)%2F02.response%2F</url>
    <content type="text"><![CDATA[2、response1、response定义1public interface HttpServletResponse extends ServletResponse 描述一个返回到客户端的HTTP回应对象。 2、返回数据到客户端1234567//将消息返回给客户端//先设置编译再写入消息resp.setCharacterEncoding("utf-8");resp.setContentType("text/html;charset=utf-8");PrintWriter out = resp.getWriter();out.println(msg);//换行打印// out.print();//不换行打印 3、转发与重定向3.1、概述 转发：需要将当前servlet的数据传输给下一个请求的地址 使用场景：如果多个请求之间需要共享数据时 重定向：通知浏览器重新发送新的请求给web服务器。 使用场景：如果多个请求之间不需要共享数据 3.1、转发与重定向的区别 转发第一次请求的url不会改变， 重定向：在地址栏会显示重定向后的url地址 从速度上来说 转发是一次请求/响应的过程中跳转1到多个url 重定向是通知浏览器发出了第二次请求，所以从速度上来说，重定向是相对慢的。 3.3、使用场景 request的方法 返回值 方法 描述 void setAttribute(String name,Object value) 在request的作用内设置键值对的值 Object getAttribute(String name) 根据key取值 RequestDispatcher getRequestDispatcher(String url) 设置要转发的url response 返回值 方法 描述 sendRedirect(String url) 重定向到指定的url]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[request]]></title>
    <url>%2F2012%2F11%2F19%2FJavaEE%2F18.Java%20Web(%E4%B8%8B)%2F01.request%2F</url>
    <content type="text"><![CDATA[1、request1、request定义1public interface HttpServletRequest extends ServletRequest; 用来处理一个对Servlet的HTTP格式的请求信息。servlet 容器创建 HttpServletRequest 对象，并将该对象作为参数传递给 servlet 的 service 方法（doGet、doPost，等等）。 2、获取请求参数的值 返回值 方法 描述 public String getParameter(String name) 返回指定参数名称，返回类型为String类型，若无对应名称的参数，返回NULL public String[] getParameterValue(String name) 返回具有相同参数名称的数值集合，返回类型为String类型的数组 &lt;示例1：实现用户登录&gt; 3、Get和Post的区别GET是最简单的HTTP方法，通过该请求可以获取服务器资源。例如HTML页面、图片、压缩包等等。 POST可以看做是GET的升级版，但是更加的强大。不仅可以请求某个服务器资源，还可以向服务器发送表单数据。 get：a，浏览器的提交方式 b，超链接 c，表单提交的默认方式 post:a,表单提交的时候修改提交方式为post GET会将参数绑定到url地址后面，POST是使用httppost机制来实现的，参数在请求主体中 （约定）GET主要用于取数据（发送的是条件，根据条件拿数据），POST主要用于拿数据（要将数据持久化到服务器） GET用于少量数据的发送（最多4K），POST用来发送大量数据（理论没有限制） GET没有POST安全（GET数据是显式的，POST数据是封装的） GET方式速度比POST快（POST多了一个封装机制） 4、中文乱码产生原因：数据提交时的编码方式。 常见的编码方式： gb2312：包含常用的简体汉字 gbk：收录比gb2312更多的汉字，包括简体和繁体的汉字 utf-8：包含全世界所有国家的字符，属性国际编码，通用性强。 4.1、接收请求参数的中文乱码解决get和post方式提交的数据处理? 4.2、返回响应数据的中文乱码解决]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet]]></title>
    <url>%2F2012%2F11%2F18%2FJavaEE%2F17.Java%20Web(%E4%B8%8A)%2F5%E3%80%81servlet%2F</url>
    <content type="text"><![CDATA[5、servlet5.1、什么是Servlet运行在服务器端，调用Servlet API的java应用程序。 5.2、Servlet的生命周期 5.3、Servlet生命周期各阶段 实例化：Servlet容器创建Servlet的实例(二种方式) 第一种：在第一次请求servlet时创建 第二种：在web服务器启动时创建 12345&lt;servlet&gt; &lt;servlet-name&gt;helloWorldServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.HelloWorldServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!-- 配置的数字表示启动顺序 --&gt;&lt;/servlet&gt; 初始化：容器调用init()方法 有2个重载的方法 12public void init() throws ServletException;public void init(ServletConfig config) throws ServletException;//读取web.xml中的配置参数 请求处理：如果请求servlet，则调用service()方法，get/post请求分别调用对应的doGet()或doPost() 服务终止：销毁实例之前调用destroy()方法 5.4、配置Servlet5.4.1、Servlet API 常用类和接口 说明 Servlet接口 是java Servlet的基础接口，定义了Servlet必须需要实现的方法 GenericServlet类 实现Servlet接口，属于通用的，不依赖于协议的Servlet HttpServlet类 继承GenericServlet类，是在其基础上扩展了http协议的Servlet HttpServletRequest接口 继承自ServletRequest接口，用于获取请求数据的读取 HttpServletResponse接口 继承自ServletResponse接口，用于返回响应数据 5.4.2、配置web.xml配置&lt;servlet&gt;元素： 1234&lt;servlet&gt; &lt;servlet-name&gt;helloWorld&lt;/servlet-name&gt; &lt;servlet-class&gt;demo.web.servlet.HelloWorld&lt;/servlet-class&gt;&lt;/servlet&gt; 配置&lt;servlet-mapping&gt;元素： 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;helloWorld&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloWorld&lt;/url-pattern&gt;&lt;/servlet&gt; servlet的执行流程 12341、客户端发送请求web服务器2、解析请求的url：资源分类，静态资源，servlet的请求的url url:http://localhost:8080/day17/helloWorldServlet 解析后的请求资源==/helloWorldServlet 5.4.2.1、url配置的4种方式 精确匹配 1234567891011121314151617181920&lt;servlet&gt; &lt;servlet-name&gt;myServlet3&lt;/servlet-name&gt; &lt;servlet-class&gt;demo.web.servlet.MyServlet3&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 第一种 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;myServlet3&lt;/servlet-name&gt; &lt;url-pattern&gt;/myServlet3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;myServlet3&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo/myServlet3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- 第二种 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;myServlet3&lt;/servlet-name&gt; &lt;url-pattern&gt;/myServlet3&lt;/url-pattern&gt; &lt;url-pattern&gt;/demo/myServlet3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 当在浏览器中输入如下url时，都会被匹配到该servlet 12http://localhost:8080/testWeb/myServlet3http://localhost:8080/testWeb/demo/myServlet3 注意： http://localhost:8080/testWeb/myServlet3/是非法的url，最后面多了一个”/“，是不会当作 http://localhost:8080/testWeb/myServlet3识别。 另外上述url后面可以跟任意的查询条件，都会被匹配，如： http://localhost:8080/testWeb/myServlet3?name=test&amp;id=1会被匹配到MyServlet3。 路径匹配 以/“字符开头，并以“/*”结尾的字符串用于路径匹配。 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;myServlet3&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 路径以/demo/开始，后面的路径可以任意。比如下面的url都会被匹配。 123http://localhost:8080/testWeb/demo/index.htmlhttp://localhost:8080/testWeb/demo/login.dohttp://localhost:8080/testWeb/demo/logout.action 扩展名匹配 以“*.”开头的字符串被用于扩展名匹配。 12345&lt;servlet-mapping&gt; &lt;servlet-name&gt;myServlet3&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 则任何扩展名为jsp或do的url请求都会匹配。比如下面的url都会被匹配。 12http://localhost:8080/testWeb/user.jsphttp://localhost:8080/testWeb/login.do 缺省匹配 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;myServlet3&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5.4.2.2、匹配规则当一个请求发送到servlet容器的时候，容器先会将请求的url减去当前应用上下文的路径作为servlet的映射url，比如我访问的是http://localhost/test/aaa.html，我的应用上下文是test，容器会将http://localhost/test去掉，剩下的/aaa.html部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下的servlet了（filter不同，后文会提到）。 其匹配规则和顺序如下 精确匹配 例：比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了。 最长路径匹配 例：servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此时访问http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB。 扩展匹配 如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet。例子：servletA的url-pattern：.action，而servletB的url-pattern:/demo/，当一个请求http://localhost:8080/testWeb/demo/addUser.action来的时候，servletB匹配到，不再用servletA匹配。 缺省匹配 如果前面三条规则都没有找到一个Servlet，容器会根据url选择对应的请求资源。如果应用定义了一个default servlet，则容器会将请求丢给default servlet。 5.4.2.3、需要注意的地方 路径匹配和扩展名匹配无法同时设置 匹配方法只有三种，要么是路径匹配（以“/”字符开头，并以“/*”结尾），要么是扩展名匹配（以“*.”开头），要么是精确匹配，三种匹配方法不能进行组合，不要想当然使用通配符或正则规则。 如&lt;url-pattern&gt;/user/*.action&lt;/url-pattern&gt;是非法的 另外注意：&lt;url-pattern&gt;/aa/*/bb&lt;/url-pattern&gt;是精确匹配，合法，这里的*不是通配的含义 “/*”和”/“含义并不相同 “/*”属于路径匹配，并且可以匹配所有request，由于路径匹配的优先级仅次于精确匹配，所以“/”会覆盖所有的扩展名匹配，很多404错误均由此引起，所以这是一种特别恶劣的匹配模式，一般只用于filter的url-pattern “/”是servlet中特殊的匹配模式，切该模式有且仅有一个实例，优先级最低，不会覆盖其他任何url-pattern，只是会替换servlet容器的内建default servlet ，该模式同样会匹配所有request。 配置“/”后，一种可能的现象是myServlet会拦截诸如http://localhost:8080/appDemo/user/addUser.action、http://localhost:8080/appDemo/user/updateUser的格式的请求，但是并不会拦截http://localhost:8080/appDemo/user/users.jsp]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web项目]]></title>
    <url>%2F2012%2F11%2F17%2FJavaEE%2F17.Java%20Web(%E4%B8%8A)%2F4%E3%80%81web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[4、Web项目4.1、Java项目和Web项目的区别 Java Web项目是基于Java EE类的；而Java项目是基于Java应用程序的。 Java项目主要面向桌面程序的应用，主要是awt、swing这类的编码，不包括JSP等前台页面的代码，大部分是CS架构的工程和一些jar包。JavaWeb项目是BS架构的系统，是网页的编码，像Jsp、Servlet、Struts这类的， JavaWeb项目部署到服务器上，任何用户都可以通过浏览器来访问。 JavaWeb项目中的Java文件是tomcat服务器来触发的，脱离了web服务器就无法启动。而Java项目是由main()方法来开始的，直接依赖JVM就能被编译执行。 Java Web项目需要服务器；而Java项目不需要服务器。 在eclipse中Java Web项目可以转换为Java项目，进而可以转回到Java Web项目。 Java项目多数应用请求响应通过按钮的事件驱动来发起(Web项目也有)。JavaWeb项目衍生了很多框架应用。多数请求响应应用超链接URL来发起(Java项目也有)。 如果说Java项目代码多半在本地，Web项目的代码基本是在远程服务端。当你是Web应用时，比如要建个网站，需要发布到服务器时，应为JavaWeb项目。当你做分布式系统时，也就是你做的只是一个服务，对外发布也只是一个服务的时候，需要建立Web Services Project(不理解可以先研究下webservices)。当你仅仅是需要JDK来运行一些本地代码的时候，只需要建Java Project就可以了。 4.2、Web项目结构12345678910111213app-name||-- src # java源文件和各种属性配置文件|-- web |-- META-INF |-- context.xml # 如tomcat连接池配置文件 |-- WEB-INF # 资源受保护 |-- classes # java文件编译后生成的.class文件存放目录 |-- lib # 当前web工程依赖的第三方jar包 |-- web.xml # 当前web工程的web配置文件 |-- css # 样式文件（用户自定义） |-- js # js文件（用户自定义） |-- images # 图像文件（用户自定义）]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口]]></title>
    <url>%2F2012%2F11%2F16%2FJavaEE%2F17.Java%20Web(%E4%B8%8A)%2F3%E3%80%81%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[3、端口3.1、修改tomcat的端口号找到tomcat-xxx/conf/server.xml配置文件： 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; tomcat的默认端口为8080，如果启动web服务时发现端口被占用，可以修改默认端口号，如下修改为8089： 123&lt;Connector port="8089" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2F2012%2F11%2F15%2FJavaEE%2F17.Java%20Web(%E4%B8%8A)%2F2%E3%80%81tomcat%2F</url>
    <content type="text"><![CDATA[2、Tomcat2.1、Web服务器WEB服务器也称为WWW服务器、HTTP服务器，其主要功能是提供网上信息浏览服务。Unix和Linux平台下常用的服务器有Apache、Nginx、Lighttpd、Tomcat、IBM WebSphere等，其中应用最广泛的是Apache。而Window NT/2000/2003平台下最常用的服务器是微软公司的IIS。 2.1.1、常用的Web服务器： Apache是世界上应用最多的WEB服务器，优势主要在于源代码开放、有一支开放的开发队伍、支持跨平台应用以及其可移植性等。Apache的模块支持非常丰富，虽在速度和性能上不及其他轻量级WEB服务器，是属于重量级产品，所消耗的内存也比其他WEB服务器要高。 Lighttpd是提供一个专门针对高性能网站，安全、快速、兼容性好并且灵活的WEB Server环境，它具有内存开销低、CPU占有率低、效能好，以及模块丰富等特点。支持FastCGI、CGI、Auth、输出压缩、URL重写及Alias等重要功能，属于轻量级WEB服务器。 Tomcat是一个开放源代码、运行servlet和JSP Web应用软件的基于Java的web应用软件容器，Tomcat server是根据servlet和jsp规范执行的，因此也可以说Tomcat server实行了Apache-Jakarta规范，且比绝大多数商用应用软件服务器要好，但是，tomcat对静态文件和高并发的处理比较弱。 IBM WebSphere是一种功能完善、开放的WEB应用程序服务器，它基于Java的应用环境，建立、部署和管理Internet和Intranet Web应用程序。相对于其他流行的WEB服务器而言，应用的数量很少。 IIS是一种WEB服务组件，允许在公共Intranet或Internet上发布信息的WEB服务器，其中包括WEB服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络上发布信息成了一件很容易的事情。它提供ISAPI作为扩展WEB服务器功能的编程接口，同时还提供了Internet，可以实现对数据库的查询和更新。 Nginx是一款高性能的HTTP和反向代理服务器，能够选择高效的epoll、kqueue、eventport最为网络I/O模型，在高连接并发的情况下，能够支持高达5万个并发连接数的响应，而内存、CPU等系统资源消耗却非常低，运行非常稳定。 2.1.2、Tomcat的目录结构 bin：存放的是可执行文件 conf：存放的是Tomcat服务器的各种全局配置文件，其中包括server.xml（Tomcat的主要配置文件）、tomcat-users.xml和web.xml等配置文件。 lib：存放tomcat服务器所需的各种jar文件。 logs:存放Tomcat的日志文件目录，记录了Tomcat启动和关闭的信息，以及异常信息等。 temp：存放Tomcat的临时文件，这个目录下的东西可以停止后删除。 webapps：存放web项目的目录，其中每个文件夹都是一个项目。 work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的。删除后再次运行会重新生成。 LICENSE：许可证。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2012%2F11%2F14%2FJavaEE%2F17.Java%20Web(%E4%B8%8A)%2F1%E3%80%81HTTP%2F</url>
    <content type="text"><![CDATA[1、HTTP协议1.1、HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 1.1.1、主要特点 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 常见的Content-Type HTML文档标记：text/html; JPEG图片标记：image/jpeg; GIF图片标记：image/gif; 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 支持B/S及C/S模式。 C/S：Client客户端/Server服务器端，比如QQ或一些大型的网络游戏，用户需要先下载软件的客户端，然后才能使用。 B/S：Brower浏览器/Server服务器端，大部分上网的网站基本全是B/S模式，用户不需要下载任何东西，只需要用到浏览器就可以访问到这个项目。 1.2、HTTP之URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成： 12URL：http://www.taobao.com:8080/news/index.jsp?boardID=5&amp;ID=24618&amp;page=1#nameURI: /index.jsp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分： 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 域名部分：该URL的域名部分为“www.taobao.com”。一个URL中，也可以使用IP地址作为域名使用(127.0.0.1) 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.jsp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 1.2.1、URL和URI的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成： 访问资源的命名机制 存放资源的主机名 资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成： 协议(或称为服务方式) 存有该资源的主机IP地址(有时也包括端口号) 主机资源的具体地址。如目录和文件名等]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2012%2F11%2F13%2FJavaEE%2F16.JDBC%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC1、JDBC概述JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用java语言编写的类和接口组成。 JDBC制定了统一访问各类关系数据库的标准接口，为各个数据库厂商提供了标准接口的实现。 2、JDBC的体系结构JDBC API支持两层和三层处理模型进行数据库访问，但在一般的JDBC体系结构由两层组成： JDBC API：提供了应用程序对JDBC的管理连接。 JDBC Driver API：支持JDBC管理到驱动器连接 定义了一系列的接口和类，集成在java.sql和javax.sql包中。 2.1、JDBC APIJDBC API提供了以下接口和类： DriverManager类： 这个类管理数据库驱动程序的列表。确定内容是否符合从Java应用程序使用的通信子协议正确的数据库驱动程序的连接请求。识别JDBC在一定子协议的第一个驱动器将被用来建立数据库连接。 Connection接口 此接口与接触数据库的所有方法。连接对象表示通信上下文，即，与数据库中的所有的通信是通过此唯一的连接对象。 Statement接口 可以使用这个接口创建的对象的SQL语句提交到数据库。一些派生的接口接受除执行存储过程的参数。 ResultSet接口 这些对象保存从数据库后，执行使用Statement对象的SQL查询中检索数据。它作为一个迭代器，可以通过移动它来检索下一个数据。 3、JDBC访问数据库的步骤3.1、加载驱动12String DRIVER_CLASS="com.mysql.cj.jdbc.Driver";//jdbc驱动类名称Class.forName(DRIVER_CLASS); 3.2、获取数据库连接对象1234String URL="jdbc:mysql://localhost:3306/test1?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=CST&amp;rewriteBatchedStatements=true";//数据库urlString USER_NAME="root";// 用户名String PASSWORD="123456";//密码java.sql.Connection conn = DriverManager.getConnection(URL, USER_NAME, PASSWORD); 注意：在加载驱动及获取连接过程中，可能会出现异常，因此需要注意进行异常处理。 3.3、获得语句集(Statement)12//通过Connection对象创建java.sql.Statement sta - conn.createStatement(); 3.4、执行sql语句返回结果这里分为二种：查询和更新（新增、修改、删除） 12345678910111213//执行sql查询返回ResultSet对象String sql = "select * from a_student";java.sql.ResultSet rs = sta.executeQuery(String sql);while(rs.next())&#123; int id = rs.getInt("id");//按列名 //int id = rs.getInt(1);//按索引 String name = rs.getString("name"); //String name = rs.getString(2); //...&#125;//执行sql更新返回受影响的行数int rows = sta.executeUpdate(String sql); 3.5、释放资源在使用JDBC与数据交互操作数据库中的数据后，应该明确地关闭所有的数据库资源以减少资源的浪费，对依赖于JVM的垃圾收集如下： 12345678//注意：需从里到外的关闭try&#123; if(rs!=null) rs.close(); if(sta!=null) sta.close(); if(conn!=null) conn.close();&#125; catch(Exception e)&#123; e.printStackTrace();&#125; 4、PreparedStatement(预编译语句集)4.1、SQL注入需求：实现登录功能，需要通过传入的登录名和密码查询数据库表中的用户是否存在。 如果使用的是Statement语句来执行sql语句。 1String sql="select * from admin where loginname='"+loginName+"' and loginpwd='"+loginPwd+"'"; 如果应用中传入： 1234567》请输入用户名：test1》请输入密码：abc' or '1'='1loginName="test1"loginPwd="abc' or '1'='1" 那么当上面的sql拼接变量值之后的sql语句为 1select * from admin where loginname='test1' and loginpwd='abc' or '1'='1' 那么将登录成功。 4.2、PreparedStatement Statement 使数据库频繁编译SQL，可能造成数据库缓冲区溢出。 不能进行占位符的形式替换值，会造成sql注入的问题。 PreparedStatement 继承自Statement接口，对SQL进行预编译，从而提高数据库的执行效率。 PS：什么是预编译？ 预编译语句PreparedStatement是java.sql中的一个接口，它是Statement的子接口。通过Statement对象执行sql语句时，需要将sql语句发送给DBMS,由DBMS首先进行编译再执行（在创建通道的时候并不进行sql的编译工作，事实上也无法进行编译）。而通过PreparedStatement不同，在创建PreparedStatement对象时就指定了sql语句，该语句立即发送给DBMS进行编译，当该语句被执行时，DBMS直接运行编译后的sql语句，而不需要像其他sql语句那样首先将被编译。 一般在考虑反复使用一个sql语句时才使用预编译，预编译语句常常放在一个循环中使用（在这种情况下预编译的优势就很明显了），通过反复设置参数从而达到多次使用该语句； 对SQL中的参数，允许使用占位符(占位符：?)的形式进行替换，简化SQL语句的编写，提高SQL语句执行效率，提高安全性。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.demo1;import java.sql.*;/** * @author Ivy Li * @create 2019-05-23 */public class TestJdbc2 &#123; static final String DRIVER_CLASS="com.mysql.cj.jdbc.Driver"; static final String URL="jdbc:mysql://localhost:3306/test1?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=CST&amp;rewriteBatchedStatements=true"; static final String USER_NAME="root"; static final String PASSWORD="123456"; public static void main(String[] args) &#123; ResultSet rs = null; PreparedStatement sta = null; String sql = "select * from a_student where stuNo= ?"; try &#123; //1、加载驱动 Class.forName(DRIVER_CLASS); //2、获得连接对象 Connection conn = DriverManager.getConnection(URL, USER_NAME, PASSWORD); //3、创建语句集 sta = conn.prepareStatement(sql); sta.setInt(1, 1);//设置占位符参数的值 //4、执行sql语句 rs = sta.executeQuery(); while(rs.next())&#123; int stuNo = rs.getInt("stuNo"); String stuName = rs.getString("stuName"); System.out.println("stuNo:" + stuNo + ", stuName:" + stuName); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(rs!=null) rs.close(); if (sta != null) sta.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4.3、批量处理sql：executeBatch()4.3.1、不使用executeBatch()，而使用executeUpdate()123456789Class.forName("com.mysql.jdbc.Driver");Connection conn = DriverManager.getConnection(dbUrl, user, password);PreparedStatement pstmt = conn.prepareStatement("update content set introtext=? where id=?");for(int i=0; i&lt;10000; i++)&#123; pstmt.setString(1, "abc"+i); pstmt.setInt(2, id); pstmt.executeUpdate();&#125; 这样，更新10000条数据，就得访问数据库10000次 4.3.2、使用executeBatch()12345678910Class.forName("com.mysql.jdbc.Driver");Connection conn = DriverManager.getConnection(dbUrl, user, password);PreparedStatement pstmt = conn.prepareStatement("update content set introtext=? where id=?");for(int i=0; i&lt;10000; i++)&#123; pstmt.setString(1, "abc"+i); pstmt.setInt(2, id); pstmt.addBatch();//添加到同一个批处理中&#125;pstmt.executeBatch();//执行批处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Testpublic void testPreparedStatementBatch()&#123; long starttime = System.currentTimeMillis(); ResultSet rs = null; PreparedStatement sta = null; String sql = "insert into a_student(stuNo,stuName,sex,age,create_time) values (?,?,?,?,?)"; try &#123; //1、加载驱动 Class.forName(DRIVER_CLASS); //2、获得连接对象 Connection conn = DriverManager.getConnection(URL, USER_NAME, PASSWORD); //3、创建语句集 sta = conn.prepareStatement(sql); for(int i=0;i&lt;10008;i++)&#123; sta.setInt(1, 10+i); sta.setString(2, "aa"+i); sta.setString(3, i%2==0?"男":"女"); sta.setInt(4, 20+i); sta.setTimestamp(5, new java.sql.Timestamp(System.currentTimeMillis())); sta.addBatch(); if(i%1000==0)&#123; sta.executeBatch(); sta.clearBatch(); &#125; &#125; sta.executeBatch(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(rs!=null) rs.close(); if (sta != null) sta.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; long endtime = System.currentTimeMillis(); System.out.println("程序花费时间：" + (endtime-starttime)/1000 + "秒！！");&#125; 5、使用配置文件访问数据库5.1、配置文件 以.properties为文件后缀，以键值（key/value）的格式保存内容 1234jdbc.mysql.driverClass=com.mysql.cj.jdbc.Driverjdbc.mysql.url=jdbc:mysql://localhost:3306/test1?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=CST&amp;rewriteBatchedStatements=truejdbc.mysql.username=rootjdbc.mysql.password=123456 5.2、键值配置类12345678910111213141516171819202122232425262728293031323334353637383940package com.demo1;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * @author Ivy Li * @create 2019-05-23 */public class DbConfig &#123; private static String dbConfigFile = "db.properties"; private static Properties props=null; static &#123; props = new Properties(); InputStream is =null; try &#123; is= DbConfig.class.getClassLoader().getResourceAsStream(dbConfigFile); props.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(is!=null) is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据键获取值 * @param key 键 * @return */ public static String getValue(String key)&#123; return props.getProperty(key); &#125;&#125; 1234String DRIVER_CLASS=DbConfig.getValue("jdbc.mysql.driverClass");String URL=DbConfig.getValue("jdbc.mysql.url");String USER_NAME=DbConfig.getValue("jdbc.mysql.username");String PASSWORD=DbConfig.getValue("jdbc.mysql.password"); 6、使用事务6.1、事务简介6.1.1、什么是事务事务是一组原子操作单元，从数据库角度说，就是一组SQL指令，要么全部执行成功，若因为某个原因其中一条指令执行有错误，则撤销先前执行过的所有指令。更简答的说就是：要么全部执行成功，要么撤销不执行。 比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 6.1.2、事务的特性 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 6.2、普通事务123456789101112131415161718192021222324252627282930313233343536373839@Testpublic void testTransactionUpdate1()&#123; ResultSet rs = null; PreparedStatement sta = null; Connection conn = null; try &#123; //1、加载驱动 Class.forName(DRIVER_CLASS); //2、获得连接对象 conn = DriverManager.getConnection(URL, USER_NAME, PASSWORD); conn.setAutoCommit(false); //设置不自动提交事务 //3、创建语句集 String sql1 = "update a_student set age=age+10 where stuNo=1"; sta = conn.prepareStatement(sql1); sta.executeUpdate(); String sql2 = "update a_student set age=age-10 where stuNo=2"; sta = conn.prepareStatement(sql2); sta.executeUpdate(); conn.commit();//提交事务 System.out.println("success..."); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(rs!=null) rs.close(); if (sta != null) sta.close(); if (conn != null) conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 6.3、设置事务保存点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Testpublic void testTransactionUpdate2()&#123; Connection conn = null; ResultSet rs = null; PreparedStatement sta = null; Savepoint sp = null; try &#123; //1、加载驱动 Class.forName(DRIVER_CLASS); //2、获得连接对象 conn = DriverManager.getConnection(URL, USER_NAME, PASSWORD); conn.setAutoCommit(false); //设置不自动提交事务 //3、创建语句集 String sql1 = "update a_student set age=age+10 where stuNo=1"; sta = conn.prepareStatement(sql1); sta.executeUpdate(); sp = conn.setSavepoint();//在这里设置事务回滚点 String sql2 = "update a_student set age=age-10 where stuNo=2"; sta = conn.prepareStatement(sql2); sta.executeUpdate(); int a = 1/0;//报异常 String sql3 = "update a_student set age=age-10 where stuNo=3"; sta = conn.prepareStatement(sql3); sta.executeUpdate(); conn.commit();//提交事务 System.out.println("success..."); &#125; catch (Exception e) &#123; try &#123; conn.rollback(sp);//回滚到该事务点，即该点之前的会正常执行（sql1） conn.commit();//回滚了要记得提交,如果没有提交sql1将会自动回滚 &#125; catch (Exception e1)&#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; finally &#123; try &#123; if(rs!=null) rs.close(); if (sta != null) sta.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 7、Dao设计模式7.1、什么是Dao模式DAO模式是标准的J2EE设计模式之一.开发人员使用这个模式把底层的数据访问操作和上层的业务逻辑分开，此模式的主要作用是封装对数据库的各种操作； 7.2、Dao模式的组成部分 Dao接口：定义对某个持久化类的所有操作 Dao实现类：Dao接口的具体实现 Dao工厂类：用来创建出Dao对象（可选） PO(Persistent Object)类：持久化类，属性对应表的字段，对象实例对应表中的一条记录。 7.3、Dao示例代码]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义注解]]></title>
    <url>%2F2012%2F11%2F12%2FJavaSE%2FDay40_Annotation%2F02.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[自定义注解自定义注解的步骤 第一步，定义注解——相当于定义标记。 第二步，配置注解——把标记打在需要用到的程序代码中。 第三步，解析注解——在编译期或运行时检测到标记，并进行特殊操作。 自定义注解案例 新建Annotation 1234567@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyAnnotation &#123; String parameter1() default ""; int parameter2() default 0;&#125; 使用注解的类 123456public class Demo &#123; @MyAnnotation(parameter1="有道无术，术尚可求", parameter2=8888) public void myMethod () &#123; &#125;&#125; 获取注解参数 1234567public class Test &#123; public static void main(String[] args) throws Exception &#123; Method method = Demo.class.getDeclaredMethod("myMethod"); MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class); System.out.println(myAnnotation.parameter1()); System.out.println(myAnnotation.parameter2());&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2F2012%2F11%2F11%2FJavaSE%2FDay40_Annotation%2F01.%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解什么是注解 注解（Annotation），也叫元数据。一种代码级别的说明。从JDK5开始, Java 增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。 注解，可以看作是对一个类/方法 的一个扩展的模版，每个类/方法 按照注解类中的规则，来为类/方法 注解不同的参数，在用到的地方可以得到不同的类/方法中注解的各种参数与值。 内置注解 Java 定义了一套注解，共有 7 个，3 个在 java.lang中，剩下 4 个在 java.lang.annotation 中。 作用在代码的注解是 @Override :检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated :标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings :指示编译器去忽略注解中声明的警告。 2.作用在其他注解的注解(或者说元注解)是: @Retention :标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented :标记这些注解是否包含在用户文档中。 @Target : 标记这个注解应该是哪种 Java 成员。 表示该注解可以用于什么地方，可能的ElementType参数有： CONSTRUCTOR：构造器的声明 FIELD：域声明（包括enum实例） LOCAL_VARIABLE：局部变量声明 METHOD：方法声明 PACKAGE：包声明 PARAMETER：参数声明 TYPE：类、接口（包括注解类型）或enum声明 @Inherited 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) 允许子类继承父类中的注解 从 Java 7 开始，额外添加了 3 个注解: @SafeVarargs : Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface : Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable : Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括： SOURCE：注解将被编译器丢弃 CLASS：注解在class文件中可用，但会被VM丢弃 RUNTIME：JVM将在运行期间保留注解，因此可以通过反射机制读取注解的信息]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2012%2F11%2F10%2FJavaSE%2FDay39_reflect%2F01.JAVA%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JAVA 反射机制什么是 JAVA 的反射机制 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 JAVA 反射机制的意义 首先，反射机制极大的提高了程序的灵活性和扩展性，降低模块的耦合性，提高自身的适应能力。 其次，通过反射机制可以让程序创建和控制任何类的对象，无需提前硬编码目标类。再次，使用反射机制能够在运行时构造一个类的对象，判断一个类所具有的成员变量和方法，调用一个对象的方法并生成动态代理。 最后，反射机制是构建框架技术的基础所在，使用反射可以避免将代码写死在框架中。正是反射有以上的特征，所以它能动态编译和创建对象，极大的激发了编程语言的灵活性，强化了多态的特性，进一步提升了面向对象编程的抽象能力，因而受到编程界的青睐。 JAVA 反射机制的原理 反射机制(Reflection)是Java提供的一项较为高级的功能，它提供了一种动态功能，而此功能的体现在于通过反射机制相关的API就可以获取任何Java类的包括属性、方法、构造器、修饰符等信息。元素不必在JⅧ运行时进行确定，反射可以使得它们在运行时动态地进行创建或调用。反射技术在中间件领域应用得较多。 JAVA 反射机制的应用 获取反射对象 获取反射对象的方式一共有3种，分别是通过类名.class，对象名.class()以及Class.forName(“完整的类路径”)1234Class&lt;Student&gt; clazz1 = Student.class;Student stu = new Student();Class&lt;? extends Student&gt; clazz2 = stu.getClass();Class&lt;?&gt; clazz3 = Class.forName("com.qf.entity.Student"); 通过反射对象获得对象的属性。 通过 getClass() 方法获得某个对象的类，然后实例化一个 Field 对象，接收类声明的属性，最后通过 get() 方法获得该属性的实例，注意，这里的属性必须为公有的，否则将会报 illegalAeeessException 的异常。 如果是私有的属性则需要通过 getDeclaredField() 方法获取该属性的实例，然后通过实例对象调用 setAccessible(true) 来取消访问权限12Class&lt;? extends Score&gt; clazz = score.getClass();Field java = clazz.getDeclaredField("java"); 通过反射对象获得对象的方法。 同样要先获得对象的类，然后配置类的数组，并把它作搜索方法的条件。通过 getMethod() 方法，得到要执行的方法。执行该方法则是调用 invoke() ，该方法中需要传递对应的对象和方法所需的参数 同理，如果是私有方法则调用 getDeclaredMethod() 方法，然后通过方法对象调用 setAccessible(true) 来取消访问权限12Method method = clazz.getDeclaredMethod("test",int.class,String.class);method.setAccessible(true); 利用反射对象调用构造方法创建实例对象 新建类的实例。我们利用执行带参数的构造函数的方法来新建一个实例。同样要先得到要构造的实例的类，然后构造参数的类数组，构造器是通过 getConstructor(argsClass) 得到的，最后使用 newlnstanee(args) 方法新建一个实例。 同理，如果是私有方法则调用 getDeclaredConstructor() 方法，然后通过方法对象调用 setAccessible(true) 来取消访问权限1234Class&lt;Score&gt; clazz = Score.class;Constructor&lt;Score&gt; con = clazz.getDeclaredConstructor(double.class);con.setAccessible(true);Score score = con.newInstance(88);]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全的集合]]></title>
    <url>%2F2012%2F11%2F09%2FJavaSE%2FDay35_Thread(%E4%B8%8B)%2F02.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[线程安全的集合 java5.0在java.util.concurrent包中提供了多种并发容器类来改进同步容器的性能. 多线程中常用集合:CopyOnWriteArrayList、ConcurrentHashMap、ConCurrentSkipListMap 和 CopyOnWriteArraySet. 当期望许多线程访问一个给定 Collection 时,ConcurrentHashMap 通常优于同步的 HashMap,ConcurrentSkipListMap 通常优于同步的TreeMap. 当期望的读数和遍历远远大于列表的更新数时,CopyOnWriteArrayList 优于同步的 ArrayList . CopyOnWriteArrayList CopyOnWriteArrayList 就是通过 Copy-On-Write(COW)，即写时复制的同时来通过延时更新的策略来实现数据的最终一致性，并且能够保证读线程间不阻塞。 COW 通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对 CopyOnWrite 容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，放弃数据实时性达到数据的最终一致性。 注意事项： 这个所谓新的容器就牵扯到 Arrays.copyof() 整个数组复制的问题,且使用到了 ReentrantLock 同步影响效率,所以写多的话不适用 CopyOnWriteArrayList 。 如何防止并发写? CopyOnWriteArray 当有一个人准备新的容器之前,就加锁,直到他改完释放锁,别人才可以接着它拉新的容器出来搞.换句话说 set(),add(), remove()操作都是 synchronized(),且内部搞新的容器 copyIn() 这个操作也是 synchronized 的. ConcurrentHashMap 结构上和 Java8 的 HashMap 基本上一样，不过它要保证安全性，所以源码上确实要复杂一些。注意：Java8 的 ConcurrentHashMap 不再使用Java7的 Segment 分段锁来保证并发写，而是使用 CAS 操作来保证线程安全的。 CAS 是 compare and swap 的缩写，即我们所说的比较交换。CAS 是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS 是通过无限循环来获取数据的，如果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锁机制]]></title>
    <url>%2F2012%2F11%2F08%2FJavaSE%2FDay35_Thread(%E4%B8%8B)%2F01.%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[锁机制锁机制的概念 在java中,当多条语句操作同一线程共享数据时,一个线程对多条语句只执行一部分,还没执行完毕,另一个线程参与进来执行,有可能导致共享数据的错诶发生. 即多个线程执行的不确定性引发执行结果的不稳定,为了避免这种问题的发生,java的线程就出现锁机制 同步代码块 synchronized 是java中的内置关键词,称为同步锁,在代码执行时出现异常时,JVM 会自动释放锁定. 包含 synchronized 的代码块称之为同步代码块，当线程开始执行同步代码块前，必须先获得对同步代码块的锁定。并且任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定。 “” 为同步监视器，同步监视器必须每个线程都为同一个对象才能达到同步的效果。1234synchronized ("")&#123; &#125; 同步方法 对于关键字 synchronized 修饰的方法，不需要再指定同步监视器，这个同步方法（非 static 方法）无需显式地指定同步监视器，同步方法的同步监视器就是this，也就是调用该方法的对象。1234public synchronized void method()&#123;&#125; Lock Lock 提供了与 synchronized 关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过 synchronized 块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取 lock()与释放锁 unlock() 的可操作性、可中断的获取锁以及超时获取锁等多种 synchronized 关键字所不具备的同步特性。 ReentrantLock 是排他锁，也是一个可重入的互斥锁它具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。123456789101112131415161718192021private void method()&#123; lock.lock(); try &#123; if(ticket &gt;0) &#123; System.out.println(Thread.currentThread().getName()+"正在销售"+ticket+"张票"); ticket--; &#125; else &#123; System.out.println(Thread.currentThread().getName()+"售票完毕"); break; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的生命周期]]></title>
    <url>%2F2012%2F11%2F07%2FJavaSE%2FDay34_Thread(%E4%B8%8A)%2F04.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[线程的生命周期线程的生命周期 线程一共6种状态，分别是NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED（Thread类中有一个State枚举类型列举了线程的所有状态） 新建状态(NEW) 在程序中用构造方法创建了一个线程对象后,新的线程对象便处于新建状态,此时,它已经有了相应的内存空间和其它资源,但还处于不可运行状态.新建一个线程对象可采用线程构造方法来实现. 例如：Thread thread=new Thread(); 就绪状态(BLOCKED) 新建线程对象后,调用该线程的 start() 方法就可以启动线程.当线程启动时,线程进入就绪状态.此时,线程将进入线程队列排队,等待CPU调用,这表明它已经具备了运行条件. 运行状态(RUNNABLE) 当就绪状态的线程被CPU调用并获得处理器资源时,线程就进入了运行状态.此时,自动调用该线程对象的 run() 方法.run() 方法定义了该线程的操作和功能. 阻塞状态(WAITING/TIMED_WAITING) 一个正在执行的线程在某些特殊情况下,如被人为挂起,将让出CPU并暂时中止自己的执行,进入阻塞状态.在可执行状态下，如果调用 sleep(2000)、wait() 等方法,线程都将进入阻塞状态.阻塞时,线程不能进入排队队列,只有当引起阻塞的原因被消除后，线程才可以转入就绪状态. 死亡状态(TERMINATED) 线程调用 stop() 方法时或 run() 方法执行结束后，线程即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。 作业 铁道部发布了一个售票任务，要求销售1000张票，要求有10个窗口来进行销售，请编写多线程程序来模拟这个效果iv.窗口001正在销售第1000张票v.窗口001正在销售第999张票vi.窗口002正在销售第998张票vii.。。。viii.窗口010正在销售第1张票ix.票已经销售完毕 使用多线程完成断点续传]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的常用方法]]></title>
    <url>%2F2012%2F11%2F06%2FJavaSE%2FDay34_Thread(%E4%B8%8A)%2F03.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[线程的常用方法线程的优先级 我们可以通过传递参数给线程的 setPriority() 来设置线程的优先级别 案例:在主线程中创建两个以上的子线程,并且设置不同优先级,观察其优先级对线程执行结果的影响.1234567891011121314151617181920212223242526public class Demo &#123; public static void main(String[] args) &#123; MyThread1 myThread1 = new MyThread1(); MyThread2 myThread2 = new MyThread2(); myThread2.setPriority(Thread.MAX_PRIORITY); myThread1.setPriority(Thread.MIN_PRIORITY); myThread1.start(); myThread2.start(); &#125;&#125;class MyThread1 extends Thread&#123; @Override public void run() &#123; for (int i = 0;i &lt;1000;i++)&#123; System.out.println("子线程:"+i); &#125; &#125;&#125;class MyThread2 extends Thread&#123; @Override public void run() &#123; for (int i = 0;i &lt;1000;i++)&#123; System.out.println(i); &#125; &#125;&#125; 线程的休眠 使用线程的 sleep() 可以使线程休眠指定的毫秒数,在休眠结束的时候继续执行线程 案例:编写一个抽取学员回答问题的程序,要求倒数三秒后输出被抽中的学员姓名12345678910111213141516171819202122232425262728public class Random &#123; public static void main(String[] args) &#123; new MyThread1().start(); &#125;&#125;class MyThread1 extends Thread&#123; @Override public void run() &#123; String[] names = new String[]&#123;"zs","ls","ww","z6"&#125;; int index = (int)(Math.random()*4); for (int i = 3;i &gt; 0;i--) &#123; System.out.println(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("抽中学员为:"+names[index]); &#125;&#125; 线程的礼让 Thread.yield() 方法作用是：暂停当前正在执行的线程对象（及放弃当前拥有的cup资源），并执行其他线程。 yield() 做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用 yield() 的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证 yield() 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 案例:创建两个线程A,B,分别各打印1000次,从1开始每次增加1,其中B一个线程,每打印一次,就yield一次,观察实验结果.1234567891011121314151617181920212223public class Demo &#123; public static void main(String[] args) &#123; new Thread(new Task2()).start(); new Thread(new Task1()).start(); &#125;&#125;class Task1 implements Runnable&#123; @Override public void run() &#123; for (int i = 0;i &lt; 1000;i++)&#123; System.out.println("A:"+i); &#125; &#125;&#125;class Task2 implements Runnable&#123; @Override public void run() &#123; for (int i = 0;i &lt; 1000;i++)&#123; System.out.println("B:"+i); Thread.yield(); &#125; &#125;&#125; 线程的合并 Thread 中，join()方法的作用是调用线程等待该线程完成后，才能继续往下运行。 案例:主线程和子线程各打印1000次,从1开始每次增加1,当主线程打印到10之后,让子线程先打印完再打印主线程.123456789101112131415161718192021222324252627282930313233343536public class Demo &#123; public static void main(String[] args) &#123; MyThread2 myThread2 = new MyThread2(); MyThread1 myThread1 = new MyThread1(myThread2); myThread1.start(); myThread2.start(); &#125;&#125;class MyThread1 extends Thread&#123; private Thread thread; public MyThread1(Thread thread)&#123; this.thread = thread; &#125; @Override public void run() &#123; for (int i = 0;i &lt;1000;i++)&#123; if(i==10)&#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("A"+i); &#125; &#125;&#125;class MyThread2 extends Thread&#123; @Override public void run() &#123; for (int i = 0;i &lt;1000;i++)&#123; System.out.println("B"+i); &#125; &#125;&#125; 线程的中断 在以前的jdk版本中，我们使用stop()方法中断线程，但是现在的jdk版本中已经不再推荐使用该方法了。 每个线程都一个状态位用于标识当前线程对象是否是中断状态。isInterrupted() 是一个实例方法，主要用于判断当前线程对象的中断标志位是否被标记了，如果被标记了则返回 true 表示当前已经被中断，否则返回 false。 如果线程处于运行状态，那么该线程的状态就是 RUNNABLE，但是不一定所有处于 RUNNABLE 状态的线程都能获得CPU运行，在某个时间段，只能由一个线程占用CPU，那么其余的线程虽然状态是 RUNNABLE ，但是都没有处于运行状态。而我们处于 RUNNABLE 状态的线程在遭遇中断操作的时候只会设置该线程的中断标志位，并不会让线程实际中断，想要发现本线程已经被要求中断了则需要用程序去判断。 interrupt()是一个实例方法，该方法用于设置当前线程对象的中断标识位。 案例：使用中断状态值的方式应用 123456789101112131415161718192021public class Demo &#123; public static void main(String[] args) &#123; new MyThread().start(); &#125;&#125;class MyThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i&lt;100;i++)&#123; if(i == 10)&#123; this.interrupt(); &#125; if(this.isInterrupted())&#123; return; &#125; System.out.println(i); &#125; &#125;&#125; 案例：设置开关变量进行中断应用 1234567891011121314151617181920212223242526272829303132333435public class Demo01 &#123; public static void main(String[] args) throws InterruptedException &#123; MyThread1 myThread1 = new MyThread1(); myThread1.start(); for (int i = 0; i&lt;1000;i++)&#123; Thread.sleep(1); if(i ==100)&#123; myThread1.setFlag(true); &#125; System.out.println(i); &#125; &#125;&#125;class MyThread1 extends Thread&#123; private Boolean flag = false; public void setFlag(Boolean flag) &#123; this.flag = flag; &#125; @Override public void run() &#123; for (int i = 0; i&lt;1000;i++)&#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(flag)&#123; return; &#125; System.out.println("A:"+i); &#125; &#125;&#125; 临界资源 多个线程间共享的数据称为临界资源(Critical Resource),由于是线程调度器负责线程的调度,程序员无法精确控制多线程的交替顺序.因此,多线程对临界资源的访问有时会导致数据的不一致.1234567891011121314151617public class Demo &#123; public static void main(String[] args) &#123; MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.start(); myThread2.start(); &#125;&#125;class MyThread extends Thread&#123; static int num = 0 ; @Override public void run() &#123; for (int i = 0;i&lt;1000;i++)&#123; System.out.println(Thread.currentThread().getName()+":"+ num++); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程的实现]]></title>
    <url>%2F2012%2F11%2F05%2FJavaSE%2FDay34_Thread(%E4%B8%8A)%2F02.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[多线程的实现继承 Thread 类创建线程 创建一个自己的线程类,继承 Thread 类,重写 run().123456789101112131415161718public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); for(int i = 0;i&lt;1000;i++)&#123; System.out.println("主线程:"+i); &#125; &#125;&#125;class MyThread extends Thread&#123; @Override public void run() &#123; for (int i = 0;i&lt;1000;i++)&#123; System.out.println(i); &#125; &#125;&#125; 实现 Runnable 接口创建线程 创建一个自己的任务类,实现 Runnable 接口,重写 run(). 12345678910111213141516171819202122public class RunnableDemo &#123; public static void main(String[] args) &#123; Task task = new Task(); Thread thread = new Thread(task); thread.start(); for (int i = 0;i &lt;999;i++) &#123; System.out.println("主线程:"+i); &#125; &#125;&#125;class Task implements Runnable&#123; @Override public void run() &#123; for (int i = 0;i&lt;999;i++)&#123; System.out.println(i); &#125; &#125;&#125; 另外两种实现多线程的方式有何区别? 经典面试题：请问当我们编写一个单纯的main方法时，此时该程序是否为多线程的？为什么？]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程]]></title>
    <url>%2F2012%2F11%2F04%2FJavaSE%2FDay34_Thread(%E4%B8%8A)%2F01.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程和线程什么是进程 进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间和系统资源，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。 什么是线程 线程是指进程中的一个执行流程，一个进程可以运行多个线程。比如java.exe进程可以运行很多线程。线程总是输入某个进程，进程中的多个线程共享进程的内存。 同一时刻运行多个程序的能力。每一个任务称为一个线程。可以同时运行一个以上线程的程序称为多线程程序。 我们应用的软件有哪些是多线程的应用? 单进程操作系统和多进程操作系统的区别 多进程操作系统是指在同一个时段内可以执行多个任务(时间片) 边听音乐边敲代码，CPU 切换非常快 Windows 操作系统-多进程操作系统 Dos 操作系统-单进程的操作系统 Linux 操作系统-多用户多进程的操作系统]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Properties]]></title>
    <url>%2F2012%2F11%2F03%2FJavaSE%2FDay33_IO(%E4%B8%8B)%2F06.Properties%2F</url>
    <content type="text"><![CDATA[Properties什么是 Properties java中有个与配置文件有关的类 Properties(java.util.Properties),主要用于读取java的配置文件, 很多配置都会写在properties文件中,可以使用getResourceAsStream方法和InpoutStream流去读取properties文件. 文件的内容格式为”键=值”的格式,可以使用”#”来进行注释. 使用getResourceAsStream()去读取properties文件时需要注意propertires文件的路径 Properties的案例 DBUtils的再次封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* properties 文件内容: className=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mysql username=root password=root*/public class DBUtils &#123; private static String className = null; private static String url = null; private static String username = null; private static String password = null; static &#123; Properties properties = null; try &#123; properties = new Properties(); properties.load(DBUtils.class.getClassLoader().getResourceAsStream("jdbc.properties")); className = properties.getProperty("className"); url = properties.getProperty("url"); username = properties.getProperty("username"); password = properties.getProperty("password"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; Connection connection = null; try &#123; Class.forName(className); connection = DriverManager.getConnection(url,username,password); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO-随机访问流]]></title>
    <url>%2F2012%2F11%2F02%2FJavaSE%2FDay33_IO(%E4%B8%8B)%2F05.IO-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%B5%81%2F</url>
    <content type="text"><![CDATA[RandomAccessFile什么是随机访问流 RandomAccessFile是随机访问流,这个流的特点是存在指针.既能进行读取,又能进行写入,而且具有指针,可以在文件的任意位置进行读写. 随机访问流的使用1234 //能进行读写的随机访问流RandomAccessFile writerf = new RandomAccessFile("文件名", "rw");//只能进行读取的随机访问流RandomAccessFile readf = new RandomAccessFile("文件名","r"); 断点续传 使用指针的特点进行断点续传.123456789101112131415@Testpublic void test03() throws Exception &#123; RandomAccessFile rw = new RandomAccessFile("千锋教育1.mp4","rw"); RandomAccessFile r = new RandomAccessFile("千锋教育2.mp4", "r"); long length = rw.length(); r.seek(length); rw.seek(length); byte[] b = new byte[14]; int len; while((len=r.read(b)) != -1)&#123; rw.write(b,0,len); &#125; r.close(); rw.close();&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO-内存流]]></title>
    <url>%2F2012%2F11%2F01%2FJavaSE%2FDay33_IO(%E4%B8%8B)%2F04.IO-%E5%86%85%E5%AD%98%E6%B5%81%2F</url>
    <content type="text"><![CDATA[内存流内存流的使用场景 前面我们讲的输入输出流,其操作的目标都是文件,现在如果有一些临时数据需要存放在内存中,且这块内存中的数据要得到复用和操作,那么这个时候就可以使用到内存流. 内存流的类 ByteArrayInputStream 包含一个内部缓冲区,该缓冲区包含从流中读取的字节.内部计数器跟踪 read 方法要提供的下一个字节. 关闭 ByteArrayInputStream 无效.此类中的方法在关闭此流后仍可被调用,而不会产生任何 IOException。 1public class ByteArrayInputStream extends InputStream 此类实现了一个输出流,其中的数据被写入一个 byte 数组.缓冲区会随着数据的不断写入而自动增长.可使用 toByteArray() 和 oString() 获取数据. 关闭 ByteArrayOutputStream 无效.此类中的方法在关闭此流后仍可被调用,而不会产生任何 IOException。 1public class ByteArrayOutputStream extends OutputStream 内存流的案例 把数据写进内存，然后从内存中获取数据 12345678910public static void main(String[] args) throws IOException&#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write("1024".getBytes()); byte[] bytes = baos.toByteArray(); System.out.println(new String(bytes)); baos.close(); baos.writeTo(new FileOutputStream("io6.txt")); baos.close();&#125; 把内存中的数据写到指定文件中 1234567public static void main(String[] args) throws IOException&#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write("1024".getBytes()); baos.writeTo(new FileOutputStream("io6.txt")); baos.close();&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO-对象流]]></title>
    <url>%2F2012%2F10%2F31%2FJavaSE%2FDay33_IO(%E4%B8%8B)%2F03.IO-%E5%AF%B9%E8%B1%A1%E6%B5%81%2F</url>
    <content type="text"><![CDATA[对象流什么是对象流 所谓的对象流,就是可以直接操作对象的流,实现将对象写入到文件中及从文件中读取对象信息.对象流的特点在于序列化与反序列化 将对象写入到文件中—序列化 从文件中读取之前写入的对象—反序列化 对象流的类 ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream.可以使用 ObjectInputStream 读取(重构)对象. 1public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化. 1public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants 案例 实现将对象写入到文件中,又从文件中读取出对象来 写入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 测试类public class Demo &#123; // 写入 public static void main(String[] args) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("io.txt")); oos.writeObject(new Student("江帅",18)); &#125; // 读取 @Test public void test01() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream("io.txt")); Student stu = (Student)ois.readObject(); System.out.println(stu); ois.close(); &#125;&#125;// 实体类public class Student implements Serializable &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 疑问：同时写入多个信息,那么读的时候顺序是否需要对应?]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO-转换流]]></title>
    <url>%2F2012%2F10%2F30%2FJavaSE%2FDay33_IO(%E4%B8%8B)%2F02.IO-%E8%BD%AC%E6%8D%A2%E6%B5%81%2F</url>
    <content type="text"><![CDATA[转换流转换流相关的类 OutputStreamWriter ：是 Writer 的子类。将输出的字符流变成字节流：即将字符流的输入对象变成字节流输入对象。 InputStreamReader ：是 Reader 的子类。将输入的字节流变成字符流，即将一个字节流的输入对象变成字符流输入对象。 转换流的应用场景 源文件或者目的文件对应的设备是字节流，但是操作的却是文本数据，可以使用转换作为桥梁。提高对文本操作的便捷。 一旦操作文本涉及到具体的指定编码表时，必须使用转换流 。 案例 InputStreamReader 的案例1234567891011public static void main() throws IOException &#123; InputStreamReader isr = new InputStreamReader(new FileInputStream("io9.txt")); char[] c = new char[1024]; int len; while((len = isr.read(c)) != -1) &#123; System.out.println(new String(c,0,len)); &#125; isr.close();&#125; OutputStreamWriter 的案例12345public static void main() throws IOException &#123; OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("io10.txt")); osw.write("今天是美好的一天"); osw.close();&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO-缓冲流]]></title>
    <url>%2F2012%2F10%2F29%2FJavaSE%2FDay33_IO(%E4%B8%8B)%2F01.IO-%E7%BC%93%E5%86%B2%E6%B5%81%2F</url>
    <content type="text"><![CDATA[缓冲流字节流的缓冲流 为另一个输入流添加一些功能,在创建 BufferedInputStream 时,会创建一个内部缓冲区数组. 1public class BufferedInputStream extends FilterInputStream 该类实现缓冲的输出流.通过设置这种输出流,应用程序就可以将各个字节写入底层输出流中,而不必针对每次字节写入调用底层系统. 1public class BufferedOutputStream extends FilterOutputStream 字节缓冲流的拷贝1234567891011121314public static void main(String args[]) throws IOException&#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream("io.txt")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("io1.txt")); byte[] b = new byte[1024]; int len; while((len = bis.read(b)) != -1) &#123; bos.write(b,0,len); &#125; bis.close(); bos.close();&#125; 字符流的缓冲流 从字符输入流中读取文本,缓冲各个字符,从而实现字符、数组和行的高效读取. 可以指定缓冲区的大小,或者可使用默认的大小.大多数情况下,默认值就足够大了. 1public class BufferedReader extends Reader 将文本写入字符输出流,缓冲各个字符,从而提供单个字符、数组和字符串的高效写入. 可以指定缓冲区的大小,或者接受默认的大小.在大多数情况下,默认值就足够大了.1public class BufferedWriter extends Writer 字符缓冲流的拷贝12345678910111213public static void main(String args[]) throws IOException&#123; BufferedReader br = new BufferedReader(new FileReader(&quot;io.txt&quot;)); BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;io1.txt&quot;)); char[] c = new char[1024]; int len; while((len = br.read(c)) !=-1) &#123; bw.write(c,0,len); &#125; br.close(); bw.close();&#125; BufferedReader 独有的方法 readLine() 是独属于 BufferedReader 的方法 读取一行文本信息,不能读取到换行信息,返回的是 String 类型数据,达到末尾则返回 null123456789101112public static void main(String args[]) throws IOException&#123; BufferedReader br = new BufferedReader(new FileReader("io8.txt")); BufferedWriter bw = new BufferedWriter(new FileWriter("io9.txt")); String str; while((str=br.readLine()) != null) &#123; bw.write(str+"\n"); &#125; br.close(); bw.close();&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO-字符流]]></title>
    <url>%2F2012%2F10%2F29%2FJavaSE%2FDay32_IO(%E4%B8%8A)%2F03.IO-%E5%AD%97%E7%AC%A6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[字符流什么是字符流 字节流与和字符流的使用非常相似，但是两者在操作代码上有所不同，字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件。 字符流的基类 用于读取字符流的抽象类.子类必须实现的方法只有 read(char[],int,int) 和 close().但是多数子类将重写此处定义的一些方法,以提供更高的效率和/或其他功能. 1public abstract class Reader extends Object implements Readable,Closeable 写入字符流的抽象类.子类必须实现的方法仅有 write(char[],int, int)、flush() 和 close().但是,多数子类将重写此处定义的一些方法以提供更高的效率和/或其他功能. 1public abstract class Writer extends Object implements Appendable, Closeable, Flushable 字符流的案例 实现对文件的读功能 12345678910public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader("io.txt"); char[] buf = new char[1024]; int len; while((len = fr.read(buf)) != -1)&#123; System.out.println(new String(buf,0,len)); &#125; fr.close();&#125; 实现对文件的写功能 123456public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter("io.txt"); fw.write("有道无术，术尚可求；有术无道，止于术"); fw.close();&#125; 实现拷贝功能 123456789101112public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader("io1.txt"); FileWriter fw = new FileWriter("io2.txt"); char[] buf = new char[1024]; int len; while((len = fr.read(buf)) != -1)&#123; fw.write(buf,0,len); &#125; fr.close(); fw.close();&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO-字节流]]></title>
    <url>%2F2012%2F10%2F28%2FJavaSE%2FDay32_IO(%E4%B8%8A)%2F02.IO-%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[字节流什么是IO流? 流是一种抽象的概念,它代表了数据的无结构化传递,是磁盘或其他外围设备中存储的数据的源点或终点。 它主要是指一种逻辑上的概念,它提供或存储数据.产生数据的称为输入流,消耗数据的称为输出流 什么是字节流 字节流是最早出现的流，因为计算机保存文件的最小单位就是字节.在使用IO流的时候,按数据的表现形式来划分,使用字节的IO流便为字节流. API为我们提供了两个字节流的基类: 此抽象类是表示字节输入流的所有类的超类 1public abstract class InputStream extends Object implements Closeable 此抽象类是表示输出字节流的所有类的超类。 1public abstract class OutputStream extends Object implements Closeable,Flushable 输出流的案例 使用IO输出流写内容到文件中 12345678public static void main(String[] args) throws IOException &#123; // FileOutputStream fos = new FileOutputStream(new File("io1.txt")); FileOutputStream fos = new FileOutputStream("io1.txt"); String str = "day day up!"; fos.write(str.getBytes()); fos.close();&#125; 采用标准处理异常的方式 123456789101112131415161718192021222324public static void main(String[] args) &#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream("io1.txt"); String str = "day day up!"; fos.write(str.getBytes()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 实现对文件内容的追加 123456789101112131415161718192021222324public static void main(String[] args) &#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream(&quot;io1.txt&quot;,true); String str = &quot;day day up!&quot;; fos.write(str.getBytes()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 思考：如果文件不存在,会出现什么情况？ 输入流案例 采用逐个字节的读取方式 12345678910public static void main(String[] args) throws IOException&#123; FileInputStream fis = new FileInputStream("io1.txt"); int b = 0; while( (b = fis.read()) != -1) &#123; System.out.print((char) b); &#125; fis.close();&#125; 思考：如果文件不存在，会出现什么情况 文件的拷贝 采用逐个字节读取的方式进行文件的拷贝 1234567891011public static void main(String[] args) throws IOException&#123; FileInputStream fis = new FileInputStream("io1.txt"); FileOutputStream fos = new FileOutputStream("io2.txt"); int b; while( (b = fis.read()) != -1)&#123; fos.write(b); &#125; fis.close(); fos.close();&#125; 采用多个字节读取的方式进行文件的拷贝 123456789101112public static void main(String[] args) throws IOException&#123; FileInputStream fis = new FileInputStream("io1.txt"); FileOutputStream fos = new FileOutputStream("io2.txt"); byte[] b = new byte[1024]; int len; while( (len = fis.read(b)) !=-1)&#123; fos.write(b,0,len); &#125; fis.close(); fos.close();&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[File]]></title>
    <url>%2F2012%2F10%2F27%2FJavaSE%2FDay32_IO(%E4%B8%8A)%2F01.File%2F</url>
    <content type="text"><![CDATA[File什么是 File File 是文件和目录路径名的抽象表示. File 只关注文件本身的信息,而不能操作文件里面的内容. 针对文件大小,文件名,文件类型,文件修改时间等等 File 的常用方法使用 该文件存放的绝对路径 该文件存放的相对路径 该文件的文件名 文件是否可写 该文件是否可读 该文件是否为隐藏文件 该文件的长度 判断是否为文件or是否为目录 该文件的最后修改时间 文件创建案例 通过程序,判断指定路径的文件是否存在,如果不存在,则创建该文件. 下面按各种情况来解决该问题 目录已存在的情况 12345678910111213public static void main(String args[])&#123; File file = new File("E:\\File\\file.txt"); if(!file.exists()) &#123; file.createNewFile(); System.out.println("文件创建成功"); &#125; else &#123; System.out.println("文件已存在"); &#125;&#125; 有一个层级的目录不存在的情况 123456789101112131415161718192021222324public static void main(String args[])&#123; File file = new File("E:\\File\\File\\file.txt"); File parentFile = file.getParentFile(); if(!parentFile.exists()) &#123; parentFile.mkdir(); System.out.println("父目录创建成功"); &#125; else &#123; System.out.println("父目录已存在"); &#125; if(!file.exists()) &#123; file.createNewFile(); System.out.println("文件创建成功"); &#125; else &#123; System.out.println("文件已存在"); &#125;&#125; 有多个层级的目录不存在的情况 123456789101112131415161718192021222324public static void main(String args[])&#123; File file = new File("E:\\File\\File\\file.txt"); File parentFile = file.getParentFile(); if(!parentFile.exists()) &#123; parentFile.mkdirs(); System.out.println("父目录创建成功"); &#125; else &#123; System.out.println("父目录已存在"); &#125; if(!file.exists()) &#123; file.createNewFile(); System.out.println("文件创建成功"); &#125; else &#123; System.out.println("文件已存在"); &#125;&#125; 文件信息案例 输出指定目录下的所有文件名字(只考虑当前目录,不考虑子目录) 123456789101112public static void main(String args[])&#123; File file = new File("E:\\File"); File[] files = file.listFiles(); for (File f:files) &#123; if(f.isFile()) &#123; System.out.println(f.getName()); &#125; &#125;&#125; 要求只输出文件后缀名为txt的文件 123456789101112131415public static void main(String args[])&#123; File file = new File("E:\\File"); File[] files = file.listFiles(); for (File f:files) &#123; if(f.isFile()) &#123; if(f.getName().endsWith(".txt")) &#123; System.out.println(f.getName()); &#125; &#125; &#125;&#125; 根据API的过滤器来完成该功能 123456789101112131415161718192021public static void main(String args[])&#123; File file = new File("E:\\File"); File[] files = file.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; if(pathname.isFile() &amp;&amp; pathname.getName().endsWith(".txt")) &#123; return true; &#125; return false; &#125; &#125;); for (File f:files) &#123; System.out.println(f.getName()); &#125;&#125; 需求继续跟进，列出当前目录及子目录中符合该条件的文件信息 1234567891011121314151617181920public static void main(String args[])&#123; File file = new File("E:\\File"); selectFile(file);&#125;private void selectFile(File file) &#123; File[] files = file.listFiles(); for (File f:files) &#123; if(f.isFile()) &#123; System.out.println(f.getAbsolutePath()); &#125;else &#123; selectFile(f); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2F2012%2F10%2F26%2FJavaSE%2FDay31_%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E5%85%A5%2F05.HashMap%2F</url>
    <content type="text"><![CDATA[HashMap为什么需要使用 Map？ Map 存储的元素为键值对,通常称为 key-value而 key 是不允许重复的. 深入分析 HashMap 的存储 HashMap 在底层数据结构上采用了数组＋链表＋红黑树,这种结构称之为”链表散列”,HashMap 通过键生成一个 hash 值作为数组下标,HashMap 最多只允许一对键值对的 Key 为 Null ,而 value 为 Null 则无限制. 在使用默认构造器对 HashMap 进行初始化时,HashMap 会对本类中的 loadFactor(负载因子)进行一个赋值,值为0.75f. 123public HashMap() &#123; this.loadFactor = 0.75F;&#125; HashMap 是使用 put 方法进行元素存储,在使用 put 方法时,会先计算 key 对应的 hash 值,然后通过 hash 值来确定存放的地址,第一次使用 put 时,会创建一个长度为16的 hash 表. 当 hash 表中的元素大于数组长度*负载因子时,hash 表则会进行扩容,长度为原来的两倍.]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Queue]]></title>
    <url>%2F2012%2F10%2F25%2FJavaSE%2FDay31_%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E5%85%A5%2F04.Queue%2F</url>
    <content type="text"><![CDATA[Queue什么是 Queue Queue 是一种特殊的线性表队列 在 Queue 中,最先插入的元素将最先删除;反之最后插入的元素最后删除,因此队列被称为”先进先出”(FIFO–first in first out)的线性表. Queue 的原理 Queue 在进行插入操作的时候,元素将在表的后端插入,在进行删除操作的时候则会在前端删除. Queue 的使用 Queue 是使用 offer() 来加入元素,使用 poll() 来获取并删除元素,而不是使用 Collection 接口的 add() 和 remove() 方法. 使用 poll() 和 offer() 的优点在与科研通过返回值判断操作是否成功,而 add() 和 remove() 在操作失败的时候会抛出异常,如果要获取队头的元素而不进行删除使用 element() 或者 peek() 方法.1234567891011121314151617181920212223242526272829 public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(&quot;a&quot;); queue.offer(&quot;b&quot;); queue.offer(&quot;c&quot;); queue.offer(&quot;d&quot;); queue.offer(&quot;e&quot;); for(String q : queue)&#123; System.out.println(q); &#125; System.out.println(&quot;==================&quot;); System.out.println(&quot;poll:&quot;+queue.poll()); for(String q : queue)&#123; System.out.println(q); &#125; System.out.println(&quot;==================&quot;); System.out.println(&quot;element:&quot;+queue.element()); for(String q : queue)&#123; System.out.println(q); &#125; System.out.println(&quot;==================&quot;); System.out.println(&quot;peek:&quot;+queue.peek()); for(String q : queue)&#123; System.out.println(q); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TreeSet]]></title>
    <url>%2F2012%2F10%2F24%2FJavaSE%2FDay31_%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E5%85%A5%2F03.TreeSet%2F</url>
    <content type="text"><![CDATA[TreeSetTreeSet的使用 TreeSet 根据你是实现 Comparator 还是 Comparable 接口来决定是使用自然排序还是自定义排序,但是不管自然排序还是自定义排序,最终还是形成一个二叉树结构 以存储 Integer 为案例,存储的第一个元素为根元素(6),后续添加的元素(4)与根元素进行比较,如果比根元素小则放到左子树方向,添加的元素(10)比根元素大,则放在右子树方向. TreeSet的存储原理 TreeSet 是 Set 接口树结构的实现,底层为平衡二叉树(红黑树). 123public TreeSet() &#123; this((NavigableMap)(new TreeMap()));&#125; 在调用 TreeSet 的无参构造器实例对象时,可以看见它创建了一个 TreeMap 的对象. 123public boolean add(E var1) &#123; return this.m.put(var1, PRESENT) == null;&#125; 在调用 add() 方法时,本质是在使用 TreeMap 的 put 方法,把要添加的元素当成 map 集合的 key 传递进去. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public V put(K var1, V var2) &#123; TreeMap.Entry var3 = this.root; if (var3 == null) &#123; this.compare(var1, var1); this.root = new TreeMap.Entry(var1, var2, (TreeMap.Entry)null); this.size = 1; ++this.modCount; return null; &#125; else &#123; Comparator var6 = this.comparator; int var4; TreeMap.Entry var5; if (var6 != null) &#123; do &#123; var5 = var3; var4 = var6.compare(var1, var3.key); if (var4 &lt; 0) &#123; var3 = var3.left; &#125; else &#123; if (var4 &lt;= 0) &#123; return var3.setValue(var2); &#125; var3 = var3.right; &#125; &#125; while(var3 != null); &#125; else &#123; if (var1 == null) &#123; throw new NullPointerException(); &#125; Comparable var7 = (Comparable)var1; do &#123; var5 = var3; var4 = var7.compareTo(var3.key); if (var4 &lt; 0) &#123; var3 = var3.left; &#125; else &#123; if (var4 &lt;= 0) &#123; return var3.setValue(var2); &#125; var3 = var3.right; &#125; &#125; while(var3 != null); &#125; TreeMap.Entry var8 = new TreeMap.Entry(var1, var2, var5); if (var4 &lt; 0) &#123; var5.left = var8; &#125; else &#123; var5.right = var8; &#125; this.fixAfterInsertion(var8); ++this.size; ++this.modCount; return null; &#125; &#125; 但是如果存储的第一个元素是所有元素中最大或者是最小的元素(6),后续的元素添加则会形成一个单链表,而不是二叉树结构.因此在 put 方法结束前,会调用 fixAfterInsertion() 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void fixAfterInsertion(TreeMap.Entry&lt;K, V&gt; var1) &#123; var1.color = false; while(var1 != null &amp;&amp; var1 != this.root &amp;&amp; !var1.parent.color) &#123; TreeMap.Entry var2; if (parentOf(var1) == leftOf(parentOf(parentOf(var1)))) &#123; var2 = rightOf(parentOf(parentOf(var1))); if (!colorOf(var2)) &#123; setColor(parentOf(var1), true); setColor(var2, true); setColor(parentOf(parentOf(var1)), false); var1 = parentOf(parentOf(var1)); &#125; else &#123; if (var1 == rightOf(parentOf(var1))) &#123; var1 = parentOf(var1); this.rotateLeft(var1); &#125; setColor(parentOf(var1), true); setColor(parentOf(parentOf(var1)), false); this.rotateRight(parentOf(parentOf(var1))); &#125; &#125; else &#123; var2 = leftOf(parentOf(parentOf(var1))); if (!colorOf(var2)) &#123; setColor(parentOf(var1), true); setColor(var2, true); setColor(parentOf(parentOf(var1)), false); var1 = parentOf(parentOf(var1)); &#125; else &#123; if (var1 == leftOf(parentOf(var1))) &#123; var1 = parentOf(var1); this.rotateRight(var1); &#125; setColor(parentOf(var1), true); setColor(parentOf(parentOf(var1)), false); this.rotateLeft(parentOf(parentOf(var1))); &#125; &#125; &#125; this.root.color = true; &#125; fixAfterInsertion() 为红黑树结构,是平衡二叉树的其中一种,使不平衡的二叉树形成平衡的二叉树,因此 TreeSet 的底层是红黑树而不是单纯的二叉树]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList]]></title>
    <url>%2F2012%2F10%2F23%2FJavaSE%2FDay31_%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E5%85%A5%2F02.LinkedList%2F</url>
    <content type="text"><![CDATA[LinkedList什么是LinkedList LinkedList 是链表实现的线性表（双链表）。 LinkedList的存储原理 LinkedList 是 List 接口可变队列的实现,基于链表实现的,它的底层是双向链表接口.链表在内存中不是连续的,是通过引用来指向上个元素和下个元素,链表的优点在于添加元素和删除元素比较快,因为是引用指向,所以在查询方面比 ArrayList 慢,但是链表无容量限制. 12345678910111213void linkLast(E var1) &#123; LinkedList.Node var2 = this.last; LinkedList.Node var3 = new LinkedList.Node(var2, var1, (LinkedList.Node)null); this.last = var3; if (var2 == null) &#123; this.first = var3; &#125; else &#123; var2.next = var3; &#125; ++this.size; ++this.modCount;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList]]></title>
    <url>%2F2012%2F10%2F22%2FJavaSE%2FDay31_%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E5%85%A5%2F01.ArrayList%E7%9A%84%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ArrayListArrayList 的存储原理 ArrayList 是 List 接口可变数组的实现,在 java 开发中使用频率相当高,它的底层是使用数组存储元素,添加原理为数组扩容,当数组大小不足以存放新增元素的时候,就会发生数组扩容. 12345public boolean add(E var1) &#123; this.ensureCapacityInternal(this.size + 1); this.elementData[this.size++] = var1; return true;&#125; 在调用 list 的 add() 时,add()会先调用 ensureCapacityInternal(),并且把当前元素数量+1当做参数传递进去. 123private void ensureCapacityInternal(int var1) &#123; this.ensureExplicitCapacity(calculateCapacity(this.elementData, var1));&#125; 在 ensureCapacityInternal() 中调用了当前类的 ensureExplicitCapacity(),它的参数中可以看见,它调用了 calculateCapacity(),并且把存储元素的数组和元素数量+1传递进去. 123private static int calculateCapacity(Object[] var0, int var1) &#123; return var0 == DEFAULTCAPACITY_EMPTY_ELEMENTDATA ? Math.max(10, var1) : var1; &#125; calculateCapacity() 这个方法是在判断数组是否为空,为空则返回10与数组长度+1之间的最大值,不为空则返回元素数量+1. 1234567private void ensureExplicitCapacity(int var1) &#123; ++this.modCount; if (var1 - this.elementData.length &gt; 0) &#123; this.grow(var1); &#125;&#125; 在ensureExplicitCapacity() 中,如果元素+1比数组长度大则调用 grow(),也就是说即将要存储的元素超过了数组的长度,则进行数组扩容. 12345678910111213private void grow(int var1) &#123; int var2 = this.elementData.length; int var3 = var2 + (var2 &gt;&gt; 1); if (var3 - var1 &lt; 0) &#123; var3 = var1; &#125; if (var3 - 2147483639 &gt; 0) &#123; var3 = hugeCapacity(var1); &#125; this.elementData = Arrays.copyOf(this.elementData, var3); &#125; grow() 是 ArrayList 的数组扩容方法,在需要进行扩容的时候,ArrayList 的数组会增加一半的长度.]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2012%2F10%2F21%2FJavaSE%2FDay29_Pattern%2F04.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式什么是观察者模式 在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。 而在程序中，我们可以通过影响一个对象的行为而改变一个或者多个对象的行为，这就是设计模式中的观察者模式。 观察者模式的定义与特点 观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 观察者模式是一种对象行为型模式，其主要优点如下。 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。 它的主要缺点如下: 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 观察者模式的结构 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public abstract class Cop&#123; private List&lt;Human&gt; list = new ArrayList&lt;&gt;(); public void add(Human h) &#123; list.add(h); &#125; public void delete(Human h) &#123; list.remove(h); &#125; public abstract void upadate();&#125;public class Jailer extends Cop &#123; @Override public void update(String str) &#123; for (Human p : list) &#123; p.deed(); &#125; &#125; &#125;public abstract class Human&#123; public void deed();&#125;public class Prisoner1 extends Human&#123; @Override public void deed() &#123; System.out.println(&quot;甲犯人正在集合&quot;); &#125;&#125;public class Prisoner2 extends Human&#123; @Override public void deed() &#123; System.out.println(&quot;乙犯人正在集合&quot;); &#125;&#125;public class ObserverPattern&#123; public static void main(String[] args) &#123; Cop cop = new Jailer(); Human human1 = new Prisoner1(); Human human2 = new Prisoner2(); cop.add(human1); cop.add(human2); cop.update(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2012%2F10%2F20%2FJavaSE%2FDay29_Pattern%2F03.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式什么是策略模式 策略（Strategy）模定义一组算法，将每个算法都封装起来，使得它们之间可以相互替换。策略模式让算法独立于调用它的客户端而独立变化。 策略模式的定义与特点 策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 策略模式的主要优点： 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。 策略模式的主要缺点： 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。 策略模式造成很多的策略类。 策略模式的结构 抽象策略(Strategy)：通常由接口或抽象类实现。定义了多个具体策略的公共接口，具体策略类中各种不同的算法以不同的方式实现这个接口；Context使用这些接口调用不同实现的算法。 具体策略(ConcreteStrategy)：实现Strategy接口或继承于抽象类Strategy，封装了具体的算法和行为。 环境类(Contex)：持有一个公共策略接口的引用，直接给客户端调用。 案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public interface Weapon &#123; public void gun();&#125;public class MyGun1 implements Weapon &#123; @Override public void gun() &#123; System.out.println(&quot;AWM&quot;); &#125;&#125;public class MyGun2 implements Weapon &#123; @Override public void gun() &#123; System.out.println(&quot;M416&quot;); &#125; &#125; public class Context &#123; Weapon weapon; public Context(Weapon weapon) &#123; this.weapon = weapon; &#125; public Weapon getWeapon() &#123; return weapon; &#125; public void setWeapon(Weapon weapon) &#123; this.weapon = weapon; &#125; public void gun() &#123; weapon.gun(); &#125;&#125;public class StrategyPattern &#123; public static void main(String[] args) &#123; System.out.println(&quot;-------远距离发现敌人-------&quot;); Context context=new Context(new MyGun1()); context.gun(); System.out.println(&quot;-------近距离发现敌人-------&quot;); contex.set(new MyGun2()); context.gun(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2012%2F10%2F19%2FJavaSE%2FDay29_Pattern%2F02.%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单工厂模式什么是简单工厂模式 就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。 简单工厂模式的优点和缺点 优点：工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。 缺点：由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利； 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface Human &#123; public void say();&#125;public class Man implements Human &#123; @Override public void say() &#123; System.out.println(&quot;男人&quot;); &#125;&#125;public class Woman implements Human &#123; @Override public void say() &#123; System.out.println(&quot;女人&quot;); &#125;&#125;public class SampleFactory &#123; public static Human makeHuman(String type)&#123; if(type.equals(&quot;man&quot;))&#123; Human man = new Man(); return man; &#125;else if(type.equals(&quot;womman&quot;))&#123; Human woman = new Woman(); return woman; &#125;else&#123; System.out.println(&quot;不存在&quot;); return null; &#125; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Human man = SampleFactory.makeHuman(&quot;man&quot;); man.say(); Human womman = SampleFactory.makeHuman(&quot;womman&quot;); womman.say(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2012%2F10%2F18%2FJavaSE%2FDay29_Pattern%2F01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式什么是设计模式 设计模式是一套被反复使用、多数人知晓的、经过分类编目的代码设计经验的总结，它与具体的语言无关，是一种思想。 掌握了面向对象的思想，才可以更好的理解设计模式，而反之亦然。 设计模式是在软件工程实践过程中，程序员们总结出的良好的编程方法。 设计模式一共有23种。 这23种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。 设计模式的分类 创建型模式（5种）：单例模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式。 结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP编程]]></title>
    <url>%2F2012%2F10%2F17%2FJavaSE%2FDay28_%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F05.UDP%20%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[UDP 编程什么是 UDP 协议 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 在 OSI 模型中的第四层——传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。 UDP 编程案例12345678910111213141516171819202122232425//客户端1public static void main(String[] args) throws IOException &#123; DatagramSocket socket = new DatagramSocket(9999); byte[] b = &quot;客户端1:你好!&quot;.getBytes(); DatagramPacket packet = new DatagramPacket(b,b.length, InetAddress.getByName(&quot;127.0.0.1&quot;),8888); socket.send(packet); b = new byte[1024]; DatagramPacket packet1 = new DatagramPacket(b, b.length); socket.receive(packet1); System.out.println(new String(packet1.getData(),0,packet1.getLength()));&#125;//客户端2public static void main(String[] args) throws IOException &#123; DatagramSocket socket = new DatagramSocket(8888); byte[] b = new byte[1024]; DatagramPacket packet = new DatagramPacket(b, b.length); socket.receive(packet); System.out.println(new String(packet.getData(),0,packet.getLength())); b = &quot;客户端2:你好鸭!&quot;.getBytes(); DatagramPacket packet1 = new DatagramPacket(b, b.length, InetAddress.getByName(&quot;127.0.0.1&quot;), 9999); socket.send(packet1);&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP编程]]></title>
    <url>%2F2012%2F10%2F16%2FJavaSE%2FDay28_%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F04.%20TCP%20%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[TCP 编程什么是 TCP 编程 TCP 编程是建立在 TCP 协议上的 Socket 编程 什么是 TCP 协议 TCP (Transmission Control Protocol 传输控制协议)是一种面向连接(连接导向)的、可靠的、 基于IP的传输层协议。 什么是 Socket 所谓 Socket 通常也称作“套接字”，用于描述 IP 地址和端口，是一个通信链的句柄。应用程序通常通过“套接字”向网络发出请求或者应答网络请求。 Socket 是连接运行在网络上的两个程序间的双向通信的端点。 网络通讯其实指的就是 Socket 间的通讯。 通讯的两端都有 Socket，数据在两个 Socket 之间通过 IO 来进行传输。 TCP 编程案例 建立服务器 建立客户端并且连接服务端 客户端向服务器发送请求–第一次握手 服务器接收到客户端的请求,并且响应客户端–第二次握手 客户端接收到服务器的响应–第三次握手1234567891011121314151617181920212223242526272829303132333435363738// 客户端 public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;,8888); Scanner sc = new Scanner(System.in); InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); byte[] b = new byte[1024]; int len; try&#123; while(true)&#123; os.write((&quot;客户端:&quot;+sc.nextLine()).getBytes()); len = is.read(b); System.out.println(new String(b,0,len)); &#125; &#125;finally &#123; CloseUtils.closeAll(os,is,socket); &#125;&#125;//服务端public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); Scanner sc = new Scanner(System.in); InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); byte[] b = new byte[1024]; int len; try&#123; while(true)&#123; len = is.read(b); System.out.println(new String(b,0,len)); os.write((&quot;服务端:&quot;+sc.nextLine()).getBytes()); &#125; &#125;finally &#123; CloseUtils.closeAll(is,os,socket); &#125;&#125; 什么是三次握手 TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 信息。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址与端口号]]></title>
    <url>%2F2012%2F10%2F15%2FJavaSE%2FDay28_%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F03.IP%20%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[IP 地址与端口号什么是 IP 地址 IP 地址：网络中计算机的唯一标识（IP 地址是一个32位的二进制数据，为了方便，将一个字节的二进制转换为一个十进制的数据） IP地址的组成 IP 地址的组成：网络号段+主机段 IP 地址的分类 A类 IP 地址:第一段号码为网络号码，剩下的三段号码为本地计算机的号码,可以配置255255255台主机 B类 IP 地址:前二段号码为网络号码，剩下的二段号码为本地计算机的号码 C类 IP 地址:前三段号码为网络号码，剩下的一段号码为本地计算机的号码 IP 地址的表示范围 A类地址的表示范围为：0.0.0.0~126.255.255.255，默认网络屏蔽为：255.0.0.0；A类地址分配给规模特别大的网络使用。A类网络用第一组数字表示网络本身的地址，后面三组数字作为连接于网络上的主机的地址。分配给具有大量主机（直接个人用户）而局域网络个数较少的大型网络。例如 IBM 公司的网络。 B类地址的表示范围为：128.0.0.0~191.255.255.255，默认网络屏蔽为：255.255.0.0； C类地址的表示范围为：192.0.0.0~223.255.255.255，默认网络屏蔽为：255.255.255.0；C类地址分配给小型网络，如一般的局域网和校园网，它可连接的主机数量是最少的，采用把所属的用户分为若干的网段进行管理。 特殊地址:127.0.0.1 回环地址,可用于测试本机的网络是否有问题. 端口号 端口号是每个运行程序的标识 每个网络程序都会至少有一个逻辑端口 用于标识进程的逻辑地址，不同进程的标识不同 有效端口：0 ~ 65535，其中0 ~ 1024系统使用或保留端口。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议]]></title>
    <url>%2F2012%2F10%2F14%2FJavaSE%2FDay28_%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F02.TCP%20IP%20%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP/IP 协议什么是 TCP/IP 协议 TCP/IP 协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP 等，这些被称为子协议。在这些协议中，最重要、最著名的就是 TCP 和 IP 。因此，大部分网络管理员称整个协议族为“TCP/IP”。 TCP/IP 协议的分层 应用层: 应用层负责处理特定的应用程序细节。几乎各种不同的 TCP/IP 实现都会提供下面这些通用的应用程序：Telnet 远程登录、SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）、FTP（File Transfer Protocol，文件传输协议）、HTTP（Hyper Text Transfer Protocol，超文本传输协议）等。 传输层: 传输层主要为两台主机上的应用程序提供端到端的通信。在 TCP/IP 协议族中，有两个互不相同的传输协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）。 网络层 网络层处理分组在网络中的活动，例如分组的选路。在 TCP/IP 协议族中，网络层协议包括IP协议（Internet Protocol，网际协议）、ICMP协议（Internet Control Message Protocol，网际控制报文协议）和IGMP协议（Internet Group Management Protocol，网际组管理协议）。 链路层 链路层有时也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。把链路层地址和网络层地址联系起来的协议有ARP（Address Resolution Protocol，地址解析协议）和 RARP（Reverse Address Resolution Protocol，逆地址解析协议）。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI七层网络模型]]></title>
    <url>%2F2012%2F10%2F13%2FJavaSE%2FDay28_%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F01.OSI%20%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[OSI 七层网络模型网络模型 两台计算机之间的通信是根据什么规则来走的(OSI &amp; TCP/IP) OSI是一个开放性的通信系统互连参考模型，他是一个定义得非常好的协议规范。OSI模型有7层结构，每层都可以有几个子层。 OSI的7层从上到下分别是 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层 ； 其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端的数据流。 应用层: 与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。例如，一个没有通信功能的字处理程序就不能执行通信的代码，从事字处理工作的程序员也不关心 OSI 的第7层。但是，如果添加了一个传输文件的选项，那么字处理器的程序就需要实现OSI的第7层。示例：TELNET，HTTP，FTP，NFS，SMTP等。 表示层: 这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或 ASCII 格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择 ASCII 格式，发送方将把文本从发送方的字符集转换成标准的 ASCII 后发送数据。在接收方将标准的 ASCII 转换成接收方计算机的字符集。示例：加密，ASCII等。 会话层: 它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。示例：RPC，SQL等。 传输层: 这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。示例：TCP，UDP，SPX。 网络层 这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。 数据链路层: 它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM (光纤分布式数据接口)，FDDI (异步转移模式)等。 物理层: OSI 的物理层规范是有关传输介质的特性，这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。示例：Rj45，802.3等。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub]]></title>
    <url>%2F2012%2F10%2F12%2FJavaSE%2FDay27_Git%2F02.GitHub%2F</url>
    <content type="text"><![CDATA[GitHub什么是 GitHub GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名 GitHub。 GitHub 是个广受软件开发人员欢迎的平台，允许编程人员共享代码和协作，分享代码片段。 GitHub 有很多程序开发人员会在上面上传自己的代码，或者浏览/下载别人的代码，对很多程序员来说，GitHub是一个必不可少的工具。 在GitHub，用户可以十分轻易地找到海量的开源代码，其被联合创始人称为是“程序员的维基百科全书”。如果某个开发人员想实现某项功能，而又不想或者不知如何编写代码，则可以在GitHub上找到相应的开源代码。 GitHub是全球最大的编程社交及代码托管网站（戏称：全球最大的同性交友网站）。 如何从 GitHub 上下载项目 1.在搜索栏中输入关键词 2.获取项目地址 3.在 IDEA 中获取 GitHub 项目，File–&gt;New–&gt;Project from Version Control–&gt;Git 输入项目地址，并且点击测试，测试成功则 Clone]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2012%2F10%2F11%2FJavaSE%2FDay27_Git%2F01.Git%2F</url>
    <content type="text"><![CDATA[Git什么是 Git Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git安装 在 github 中创建一个账号:https://github.com/join?source=header-home 下载并安装 git:https://git-scm.com/downloads (尽量不要装 C 盘) 安装成功后打开 Git Bash，输入下列命令，设置 git 全局用户名和邮箱 12$ git config --global user.name &quot;jiagndaran&quot;$ git config --global user.email &quot;598360175@qq.com&quot; 使用下列命令查看是否设置成功12$ git config user.name$ git config user.email 4.在 IDEA 中配置 Git 插件,在 File–&gt;Plugins–&gt;勾选 Git Integration 和GitHub进行下载 5.在 IDEA 中设置 Git，在 File–&gt;Setting-&gt;Version Control–&gt;Git–&gt;Path to Git executable 选择你的 git 安装后的 git.exe 文件，然后点击 Test，测试是否设置成功 6.在 IDEA 中设置 GitHub，File–&gt;Setting-&gt;Version Control–&gt;GibHub 7.创建本地仓库，VCS(version control system)–&gt;Import into Version Control–&gt;Create Git Repository… 8.上传项目到 GitHub，VCS–&gt;Import into Version Control–&gt;Share Project on GitHub，在弹框中输入仓库名和描述，点击Share，即可是上传，中间会弹窗输入GitHub的用户名和密码（已输入过用户名和密码并记住的不会再次弹框输入），上传成功后IDEA右下角会给出提示 9.提交修改文件到 GitHub 新增文件（红色），右键–&gt;Git–&gt;add，将新增的文件加入本地仓库，此时文件变绿色 修改文件（蓝色） 在项目右键–&gt;Git–&gt;Commit Directory，查看有变动的文件并输入 Commit Message，点击 Commit and Push… 提交后会进行语法检查，若存在错误或警告会给出确认提示，点击 Commit，弹出 Push框，点击 Push，上传 GitHub 成功]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传]]></title>
    <url>%2F2012%2F10%2F10%2FJavaSE%2FDay26_Upload_Download%2F01.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[文件上传文件上传原理 所谓的文件上传就是服务器端通过request对象获取输入流，将浏览器端上传的数据读取出来，保存到服务器端 客户端浏览器注意事项 1.请求方式必须是 post 2.需要使用组件 3.表单必须设置enctype=”multipart/form-data” 服务器端处理 通过request对象，获取InputStream, 可以将浏览器提交的所有数据读取到. 文件上传案例 在浏览器端创建一个可以上传文件的表单，在服务器端通过commons-fileupload完成文件上传。 浏览器端注意三件事情: 1.表单的method=post 2.设置enctype=multipart/form-data 3.使用具有name属性的file元素 在服务器端 1.创建DiskFileItemFactory 2.创建ServletFileUpload 3.通过ServletFileUpload的parseRequest方法得到所有的FileItem 设置浏览器端: 123&lt;form action=&quot;UploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 图片:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;/form&gt; 在服务器端操作关键类：DiskFileItemFactory、ServletFileUpload、FilenameUtils、IOUtils、BeanUtils 1234567891011121314151617181920private void doPost(HttpServletRequest request, HttpServletResponse response) throws FileUploadException, IOException &#123; DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); List&lt;FileItem&gt; list = upload.parseRequest(request); for (FileItem fItem:list) &#123; InputStream is = fItem.getInputStream(); String path = getServletContext().getRealPath(&quot;Upload&quot;); File file = new File(path); if(!file.exists()) &#123; file.mkdirs(); &#125; FileOutputStream fos = new FileOutputStream(new File(file,fItem.getName())); IOUtils.copy(is,fos); is.close(); fos.close(); &#125; &#125;&#125; 文件重名如何解决 1.客户端参与 方案一：做个文件名的唯一性校验，告诉客户端，这个文件名已经存在（不建议） 2.服务端解决 方案二：重新取个名字（唯一性）—UUID 方案三：使用日期来当目录方式来存储图片 UUID： 12UUID uuid = UUID.randomUUID();String fileName = uuid.toString()+&quot;_&quot;+fItem.getName(); 文件下载 以超链接形式下载 采用流的方式进行读和写 设置响应的头部信息1response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;fileName=&quot;+fileName);]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map]]></title>
    <url>%2F2012%2F10%2F09%2FJavaSE%2F13.%E9%9B%86%E5%90%88%2F18%20-%20Map%2F</url>
    <content type="text"><![CDATA[Map接口 Map&lt;K,V&gt; 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值 Map与Collection集合中存储数据的形式不同 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值 Collection中的集合称为单列集合，Map中的集合称为双列集合 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值 Map中常用的集合为HashMap集合、LinkedHashMap集合 Map 接口中常用集合概述 主要学习HashMap 与 LinkedHashMap HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法 LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法 注意：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同 Map接口中常用的方法 put方法：将指定的键与值对应起来，并添加到集合中 方法返回值为键所对应的值 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中 使用put方法时，若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值 get方法：获取指定键(key)所对应的值(value) remove方法：根据指定的键(key)删除元素，返回被删除元素的值(value) Map接口中方法演示 1234567891011121314151617181920212223public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //给map中添加元素 map.put(&quot;星期一&quot;, &quot;Monday&quot;); map.put(&quot;星期日&quot;, &quot;Sunday&quot;); System.out.println(map); // &#123;星期日=Sunday, 星期一=Monday&#125; //当给Map中添加元素，会返回key对应的原来的value值，若key没有对应的值，返回null System.out.println(map.put(&quot;星期一&quot;, &quot;Mon&quot;)); System.out.println(map); // &#123;星期日=Sunday, 星期一=Mon&#125; //根据指定的key获取对应的value String en = map.get(&quot;星期日&quot;); System.out.println(en); // Sunday //根据key删除元素,会返回key对应的value值 String value = map.remove(&quot;星期日&quot;); System.out.println(value); // Sunday System.out.println(map); // &#123;星期一=Mon&#125; &#125;&#125; Map集合遍历键找值得方式 键找值方式：即通过元素中的键，获取键所对应的值 操作步骤与图解 1.获取Map集合中所有得键，由于键是唯一的，所以返回一个Set集合存储所有的键 遍历键的Set集合，得到每一个键 根据键，获取键所对应的值 代码演示 123456789101112131415161718192021public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //给map中添加元素 map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;刘德华&quot;, &quot;柳岩&quot;); //获取Map中的所有key Set&lt;String&gt; keySet = map.keySet(); //遍历存放所有key的Set集合 Iterator&lt;String&gt; it =keySet.iterator(); while(it.hasNext())&#123; //得到每一个key String key = it.next(); //通过key获取对应的value String value = map.get(key); System.out.println(key+&quot;=&quot;+value); &#125; &#125;&#125; Entry键值对对象 在Map类设计时，提供了一个嵌套接口：Entry。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值 Entry是Map接口中提供的一个静态内部嵌套接口 getKey()方法：获取Entry对象中的键 getValue()方法：获取Entry对象中的值 entrySet()方法：用于返回Map集合中所有的键值对(Entry)对象，以Set集合形式返回 Map集合遍历键值对方式 键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值 1.获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回 2.遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象 3.通过键值对(Entry)对象，获取Entry对象中的键与值 图解: 代码演示 1234567891011121314151617181920212223public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //给map中添加元素 map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;刘德华&quot;, &quot;柳岩&quot;); //获取Map中的所有key与value的对应关系 Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet(); //遍历Set集合 Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it =entrySet.iterator(); while(it.hasNext())&#123; //得到每一对对应关系 Map.Entry&lt;String,String&gt; entry = it.next(); //通过每一对对应关系获取对应的key String key = entry.getKey(); //通过每一对对应关系获取对应的value String value = entry.getValue(); System.out.println(key+&quot;=&quot;+value); &#125; &#125;&#125; 注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了 HashMap存储自定义类型键值 练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值 注意学生是唯一 学生类 12345678public class Student &#123; private String name; private int age; //编写构造方法，文档中已省略 //编写get,set方法，文档中已省略 //编写toString方法，文档中已省略&#125; 测试类 12345678910111213141516171819202122232425262728public class HashMapTest &#123; public static void main(String[] args) &#123; //1,创建hashmap集合对象。 Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;(); //2,添加元素。 map.put(new Student(&quot;lisi&quot;,28), &quot;上海&quot;); map.put(new Student(&quot;wangwu&quot;,22), &quot;北京&quot;); map.put(new Student(&quot;zhaoliu&quot;,24), &quot;成都&quot;); map.put(new Student(&quot;zhouqi&quot;,25), &quot;广州&quot;); map.put(new Student(&quot;wangwu&quot;,22), &quot;南京&quot;); //3,取出元素。键找值方式 Set&lt;Student&gt; keySet = map.keySet(); for(Student key : keySet)&#123; String value = map.get(key); System.out.println(key.toString()+&quot;.....&quot;+value); &#125; //取出元素。键值对方式 Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet(); for (Map.Entry&lt;Student, String&gt; entry : entrySet) &#123; Student key = entry.getKey(); String value = entry.getValue(); System.out.println(key.toString()+&quot;.....&quot;+value); &#125; &#125;&#125; 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象) 如果要保证map中存放的key和取出的顺序一致，可以使用LinkedHashMap集合来存放 静态导入 在导包的过程中我们可以直接导入静态部分，这样某个类的静态成员就可以直接使用了。在源码中经常会出现静态导入 静态导入格式 1import static XXX.YYY; 导入后YYY可直接使用 例如：Map.Entry的访问，简化后为Entry 123456789101112131415161718import static java.util.Map.Entry;public class HashMapTest &#123; public static void main(String[] args) &#123; //1,创建hashmap集合对象。 Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;(); //取出元素。键值对方式 //Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet(); Set&lt;Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet(); //for (Map.Entry&lt;Student, String&gt; entry : entrySet) &#123; for (Entry&lt;Student, String&gt; entry : entrySet) &#123; Student key = entry.getKey(); String value = entry.getValue(); System.out.println(key.toString()+&quot;.....&quot;+value); &#125; &#125;&#125; 可变参数 在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可 jdk1.5以后。出现了简化操作。… 用在参数上，称之为可变参数 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了 代码演示123456789101112131415161718192021222324252627282930public class ParamDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;21,89,32&#125;; int sum = add(arr); System.out.println(sum); sum = add(21,89,32);//可变参数调用形式 System.out.println(sum); &#125; //JDK1.5之后写法 public static int add(int...arr)&#123; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; return sum; &#125; //原始写法 /* public static int add(int[] arr) &#123; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; return sum; &#125; */&#125; 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置 Collections 集合工具类Collections是集合工具类，用来对集合进行操作。部分方法如下 public static void sort(List list) // 集合元素排序 123//排序前元素list集合元素 [33,11,77,55]Collections.sort( list );//排序后元素list集合元素 [11,33,55,77] public static void shuffle(List&lt;?&gt; list) // 集合元素存储位置打乱 123//list集合元素 [11,33,55,77]Collections.shuffle( list );//使用shuffle方法后，集合中的元素为[77,33,11,55]，每次执行该方法，集合中存储的元素位置都会随机打乱 集合嵌套 集合嵌套并不是一个新的知识点，仅仅是集合内容又是集合，如Collection集合嵌套、Collection集合与Map集合相互嵌套、Map集合嵌套 ArrayList嵌套 ArrayList 12 ArrayList&lt; ArrayList&lt;String&gt; &gt;Collection&lt; ArrayList&lt;Integer&gt; &gt; Map嵌套 ArrayList 12HashMap&lt;String, ArrayList&lt;Person&gt;&gt;ArrayList&lt; HashMap&lt;String, String&gt;&gt; Map集合嵌套 12HashMap&lt;String, HashMap&lt;String,String&gt;&gt;HashMap&lt;String, HashMap&lt;Person,String&gt;&gt; 模拟斗地主 54张扑克牌，随机打乱，三个人交替摸牌，每人十七张，最后三张作为底牌查看每个得牌与底牌 手中扑克牌从大到小摆放 案例需求分析 准备牌: 完成数字与纸牌的映射关系: 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系 洗牌 通过数字完成洗牌发牌 发牌 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌 存放的过程中要求数字大小与斗地主规则的大小对应 将代表不同纸牌的数字分配给不同的玩家与底牌 看牌 通过Map集合找到对应字符展示 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;/* * 斗地主洗牌发牌排序 */public class Poker &#123; public static void main(String[] args) &#123; //准备花色 ArrayList&lt;String&gt; color = new ArrayList&lt;String&gt;(); color.add(&quot;♠&quot;); color.add(&quot;♥&quot;); color.add(&quot;♦&quot;); color.add(&quot;♣&quot;); //准备数字 ArrayList&lt;String&gt; number = new ArrayList&lt;String&gt;(); Collections.addAll(number,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;); //定义一个map集合：用来将数字与每一张牌进行对应 HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); int index = 0; for (String thisNumber : number) &#123; for (String thisColor : color) &#123; map.put(index++, thisColor+thisNumber); &#125; &#125; //加入大小王 map.put(index++, &quot;小☺&quot;); map.put(index++, &quot;大☻&quot;); //一副54张的牌 ArrayList里边为0-53的数的新牌 ArrayList&lt;Integer&gt; cards = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt;= 53; i++) &#123; cards.add(i); &#125; //洗牌 Collections.shuffle(cards); //创建三个玩家和底牌 ArrayList&lt;Integer&gt; iPlayer = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; iPlayer2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; iPlayer3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; iCards = new ArrayList&lt;Integer&gt;(); //遍历这副洗好的牌，遍历过程中，将牌发到三个玩家和底牌中 for (int i = 0; i &lt; cards.size(); i++) &#123; if(i&gt;=51) &#123; iCards.add(cards.get(i)); &#125; else &#123; if(i%3==0) &#123; iPlayer.add(cards.get(i)); &#125;else if(i%3==1) &#123; iPlayer2.add(cards.get(i)); &#125;else &#123; iPlayer3.add(cards.get(i)); &#125; &#125; &#125; //对每个人手中的牌排序 Collections.sort(iPlayer); Collections.sort(iPlayer2); Collections.sort(iPlayer3); //对应数字形式的每个人手中的牌，定义字符串形式的牌 ArrayList&lt;String&gt; sPlayer = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; sPlayer2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; sPlayer3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; sCards = new ArrayList&lt;String&gt;(); for (Integer key : iPlayer) &#123; sPlayer.add(map.get(key)); &#125; for (Integer key : iPlayer2) &#123; sPlayer2.add(map.get(key)); &#125; for (Integer key : iPlayer3) &#123; sPlayer3.add(map.get(key)); &#125; for (Integer key : iCards) &#123; sCards.add(map.get(key)); &#125; //看牌 System.out.println(sPlayer); System.out.println(sPlayer2); System.out.println(sPlayer3); System.out.println(sCards); &#125;&#125; 知识点总结 Map集合 map集合中的元素都是成对出现，成对存储的 map集合中的元素都是以一对键和值的形式组成存在的，称为键值对，理解为夫妻对 map集合中的键不能重复存储，值可以重复 map集合中的每一个键 对应着一个值 方法: V put(K key, V value) 把指定的键与指定的值添加到Map集合中 V remove(Object key) 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 获取到Map集合中所有的键值对对象的集合(Set集合) V get(Object key) 根据指定的键，在Map集合中获取对应的值 Set keySet() 获取Map集合中所有的键，存储到Set集合中 Map集合遍历的两种方式 方式1：根据键找值的方式 123456789101112 //a, 获取到Map集合中所有的键，返回对应的Set集合//b, 遍历键的集合，获取到每一个键//c, 通过键，找到对应的值//获取到Map集合中所有的键，返回对应的Set集合Set&lt;String&gt; keys = map.keySet();//遍历键的集合，获取到每一个键for (String key : keys) &#123; //通过键，找到对应的值 Student s = map.get(key); System.out.println( key + &quot;...&quot; + s.getName() + &quot;...&quot; + s.getAge() );&#125; 方式2：根据键值对对象找键和值的方式 12345678910111213141516 //a, 获取Map集合中所有的键值对元素,返回对应的Set集合//b, 遍历键值对元素集合，获取到每一个键值对元素对象//c, 通过键值对元素对象，获取对应的键，和对应的值//获取Map集合中所有的键值对元素,返回对应的Set集合Set&lt; Map.Entry&lt;String, Student&gt;&gt; entrySet = map.entrySet();//遍历键值对元素集合，获取到每一个键值对元素对象for (Map.Entry&lt;String, Student&gt; entry : entrySet) &#123; //通过键值对元素对象，获取对应的键，和对应的值 //找键 String key = entry.getKey(); //找值 Student s = entry.getValue(); //打印 System.out.println( key+&quot;...&quot;+s.getName()+&quot;...&quot;+s.getAge() );&#125; HashMap 特点: 是Map集合的子集合 底层采用哈希表结构 HashMap集合中的key不能重复，通过重写hashCode() 与 equals()方法来保证键的唯一。不能保证元素存与取的顺序完全一致 LinkedHashMap 特点 是HashMap集合的子集合 底层采用哈希表+链表结构 LinkedHashMap集合中的key不能重复，通过重写hashCode() 与 equals()方法来保证键的唯一 Collections中的方法 public static void sort(List list) 排序 public static void shuffle(List&lt;?&gt; list) 集合中的元素存储位置随机打乱]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set]]></title>
    <url>%2F2012%2F10%2F08%2FJavaSE%2F13.%E9%9B%86%E5%90%88%2F17%20-%20Set%2F</url>
    <content type="text"><![CDATA[List集合 ArrayList LinkedList Set集合 HashSet LinkedHashSet TreeSet List集合 我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？ 接下来，我们一起学习Collection中的常用几个子类（List集合、Set集合） List集合介绍 查阅API，看List的介绍。有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。与 set 不同，列表通常允许重复的元素 看完API,总结: List接口: 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的） 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理） 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素 List 接口的常用子类有: ArratList集合 LinkedList集合 List接口中常用的方法 增加元素的方法 add(Object e):向集合末尾处，添加指定的元素 add(int index, Object e)：向集合指定索引处，添加指定的元素，原有元素依次后移 删除元素删除 remove(Object e)：将指定元素对象，从集合中删除，返回值为被删除的元素 remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素 替换元素的方法 set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素 查询元素的方法 get(int index)：获取指定索引处的元素，并返回该元素 1234567891011121314151617List&lt;String&gt; list = new ArrayList&lt;String&gt;();//1,添加元素。list.add(&quot;小红&quot;);list.add(&quot;小梅&quot;);list.add(&quot;小强&quot;);//2,插入元素。插入元素前的集合[&quot;小红&quot;,&quot;小梅&quot;,&quot;小强&quot;]list.add(1, &quot;老王&quot;); //插入元素后的集合[&quot;小红&quot;,&quot;老王&quot;,&quot;小梅&quot;,&quot;小强&quot;]//3,删除元素。list.remove(2);// 删除元素后的集合[&quot;小红&quot;,&quot;老王&quot;,&quot;小强&quot;]//4,修改元素。list.set(1, &quot;隔壁老王&quot;);// 修改元素后的集合[&quot;小红&quot;,&quot;隔壁老王&quot;,&quot;小强&quot;]Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; String str = it.next(); System.out.println(str);&#125; 由于List集合拥有索引，因此List集合迭代方式除了使用迭代器之外，还可以使用索引进行迭代 1234for (int i = 0; i &lt; list.size(); i++) &#123; String str = list.get(i); System.out.println(str); &#125; Iterator的并发修改异常 在list集合迭代元素中，对元素进行判断，一旦条件满足就添加一个新元素 1234567891011121314151617181920212223public class IteratorDemo &#123; //在list集合迭代元素中，对元素进行判断，一旦条件满足就添加一个新元素 public static void main(String[] args) &#123; //创建List集合 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //给集合中添加元素 list.add(&quot;abc1&quot;); list.add(&quot;abc2&quot;); list.add(&quot;abc3&quot;); list.add(&quot;abc4&quot;); //迭代集合，当有元素为&quot;abc2&quot;时，集合加入新元素&quot;aaa&quot; Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //判断取出的元素是否是&quot;abc2&quot;，是就添加一个新元素 if(&quot;abc2&quot;.equals(str))&#123; list.add(&quot;aaa&quot;);// 该操作会导致程序出错 &#125; &#125; //打印容器中的元素 System.out.println(list); &#125;&#125; 运行上述代码发生了错误 java.util.ConcurrentModificationException这是什么原因呢？在迭代过程中，使用了集合的方法对元素进行操作。导致迭代器并不知道集合中的变化，容易引发数据的不确定性 并发修改异常解决办法：在迭代时，不要使用集合的方法操作元素 那么想要在迭代时对元素操作咋办？通过ListIterator迭代器操作元素是可以的，ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况 List 集合存储数据的结构 List接口下有很多个集合，它们存储元素所采用的结构方式是不同的，这样就导致了这些集合有它们各自的特点，供给我们在不同的环境下进行使用。数据存储的常用结构有：堆栈、队列、数组、链表。我们分别来了解一下 堆栈，采用该结构的集合，对元素的存取有如下的特点 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹 栈的入口、出口的都是栈的顶端位置 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置 队列，采用该结构的集合，对元素的存取有如下的特点 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，安检。排成一列，每个人依次检查，只有前面的人全部检查完毕后，才能排到当前的人进行检查 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口 数组，采用该结构的集合，对元素的存取有如下的特点 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中 链表，采用该结构的集合，对元素的存取有如下的特点 多个节点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快 增加元素：操作如左图，只需要修改连接下个元素的地址即可 删除元素：操作如右图，只需要修改连接下个元素的地址即可 ArrayList集合 ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合 LinkedList集合 LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用 123456789101112131415 LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();//添加元素link.addFirst(&quot;abc1&quot;);link.addFirst(&quot;abc2&quot;);link.addFirst(&quot;abc3&quot;);//获取元素System.out.println(link.getFirst());System.out.println(link.getLast());//删除元素System.out.println(link.removeFirst());System.out.println(link.removeLast());while(!link.isEmpty())&#123; //判断集合是否为空 System.out.println(link.pop()); //弹出集合中的栈顶元素 &#125; Vector集合 Vector集合数据存储的结构是数组结构，为JDK中最早提供的集合。Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。此接口Enumeration的功能与Iterator接口的功能是类似的。Vector集合已被ArrayList替代。枚举Enumeration已被迭代器Iterator替代 Vector常见的方法 Enumeration枚举常见的方法 Vector集合对ArrayList集合使用的对比 Set接口 学习Collection接口时，记得Collection中可以存放重复元素，也可以不存放重复元素，那么我们知道List中是可以存放重复元素的。那么不重复元素给哪里存放呢？那就是Set接口，它里面的集合，所存储的元素就是不重复的 Set接口介绍 查阅Set集合的API介绍，通过元素的equals方法，来判断是否为重复元素 HashSet 集合介绍 查阅HashSet集合的API介绍：此类实现Set接口，由哈希表支持（实际上是一个 HashMap集合）。HashSet集合不能保证的迭代顺序与元素存储顺序相同 HashSet集合，采用哈希表结构存储数据，保证元素唯一性的方式依赖于：hashCode()与equals()方法 HashSet 集合存储数据的结构(哈希表) 什么是哈希表呢? 哈希表底层使用的也是数组机制，数组中也存放对象，而这些对象往数组中存放时的位置比较特殊，当需要把这些对象给数组中存放时，那么会根据这些对象的特有数据结合相应的算法，计算出这个对象在数组中的位置，然后把这个对象存放在数组中。而这样的数组就称为哈希数组，即就是哈希表 当向哈希表中存放元素时，需要根据元素的特有数据结合相应的算法，这个算法其实就是Object类中的hashCode方法。由于任何对象都是Object类的子类，所以任何对象有拥有这个方法。即就是在给哈希表中存放对象时，会调用对象的hashCode方法，算出对象在表中的存放位置，这里需要注意，如果两个对象hashCode方法算出结果一样，这样现象称为哈希冲突，这时会调用对象的equals方法，比较这两个对象是不是同一个对象，如果equals方法返回的是true，那么就不会把第二个对象存放在哈希表中，如果返回的是false，就会把这个值存放在哈希表中 总结：保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式 HashSet存储元素 给HashSet中存储JavaAPI中提供的类型元素时，不需要重写元素的hashCode和equals方法，因为这两个方法，在JavaAPI的每个类中已经重写完毕，如String类、Integer类等 创建HashSet集合，存储String对象 123456789101112131415161718public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建HashSet对象 HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;(); //给集合中添加自定义对象 hs.add(&quot;zhangsan&quot;); hs.add(&quot;lisi&quot;); hs.add(&quot;wangwu&quot;); hs.add(&quot;zhangsan&quot;); //取出集合中的每个元素 Iterator&lt;String&gt; it = hs.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; &#125;&#125;// 输出结果如下： wangwu 、lisi 、zhangsan,说明集合中不能存储重复元素. HashSet存储自定义类型元素 给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义对象Student 123456789101112131415161718192021222324252627282930313233343536373839404142 public class Student &#123; private String name; private int age; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; @Override public int hashCode() &#123; return name.hashCode()+age; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj)&#123; return true;// 不允许存 &#125; if(!(obj instanceof Student))&#123; System.out.println(&quot;类型错误&quot;); return false; &#125; Student other = (Student) obj; return this.age == other.age &amp;&amp; this.name.equals(other.name); &#125;&#125; 创建HashSet集合，存储Student对象 1234567891011121314151617181920212223public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建HashSet对象 HashSet hs = new HashSet(); //给集合中添加自定义对象 hs.add(new Student(&quot;zhangsan&quot;,21)); hs.add(new Student(&quot;lisi&quot;,22)); hs.add(new Student(&quot;wangwu&quot;,23)); hs.add(new Student(&quot;zhangsan&quot;,21)); //取出集合中的每个元素 Iterator it = hs.iterator(); while(it.hasNext())&#123; Student s = (Student)it.next(); System.out.println(s); &#125; &#125;&#125;// 输出结果如下:Student[name=list , age = 21]Student[name=zhangsan , age = 21]Student[name=wangwu ,age = 23]// 说明集合中不能存储重复的元素 LinkedHashSet介绍 我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢 在HashSet下面有一个子类LinkedHashSet，它是链表和哈希表组合的一个数据存储结构 12345678910111213public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(&quot;bbb&quot;); set.add(&quot;aaa&quot;); set.add(&quot;abc&quot;); set.add(&quot;bbc&quot;); Iterator it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; TreeSet 介绍 TreeSet 是一个有序的集合，它的作用是提供有序的Set集合 排序的方式 自然排序 比较器进行排序 自然排序 自定义类自然排序 1.创建Person类实现Person implements Comparable 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person() &#123; &#125; @Override public int compareTo(Person o) &#123; /* return -1; //-1表示放在红黑树的左边,即逆序输出 return 1; //1表示放在红黑树的右边，即顺序输出 return 0; //表示元素相同，仅存放第一个元素 主要条件 姓名的长度,如果姓名长度小的就放在左子树，否则放在右子树 */ int i = this.name.length() - o.name.length(); //姓名的长度相同，不代表内容相同,如果按字典顺序此 String 对象位于参数字符串之前，则比较结果为一个负整数。 //如果按字典顺序此 String 对象位于参数字符串之后，则比较结果为一个正整数。 //如果这两个字符串相等，则结果为 0 int i2 = i == 0 ?this.name.compareTo(o.name) :i; //姓名的长度和内容相同，不代表年龄相同，所以还要判断年龄 int i3 = i2 == 0 ? this.age - o.age: i2; return i3; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; 创建测试类 1234567 public static void main(String[] args) &#123; Set&lt;Person&gt; s = new TreeSet&lt;Person&gt;(); s.add(new Person(&quot;a&quot;, 1)); s.add(new Person(&quot;c&quot;, 3)); s.add(new Person(&quot;b&quot;, 2)); System.out.println(s);&#125; 比较器比较 创建Person不需要实现Comparable接口 1234567891011121314151617181920212223242526272829public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person() &#123; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; 自定义比较器MyComparator implements Comparator 12345678910111213public class MyComparator implements Comparator&lt;Person&gt;&#123; @Override public int compare(Person o1, Person o2) &#123; int i = o1.getName().length() - o2.getName().length(); //姓名的长度相同，不代表内容相同,如果按字典顺序此 String 对象位于参数字符串之前，则比较结果为一个负整数。 //如果按字典顺序此 String 对象位于参数字符串之后，则比较结果为一个正整数。 //如果这两个字符串相等，则结果为 0 int i2 = i == 0 ? o1.getName().compareTo(o2.getName()):i; //姓名的长度和内容相同，不代表年龄相同，所以还要判断年龄 int i3 = i2 == 0 ? o1.getAge() - o2.getAge():i2; return i3; &#125;&#125; 自定义测试类 123456789public class Tests &#123; public static void main(String[] args) &#123; Set&lt;Person&gt; s = new TreeSet&lt;Person&gt;(new MyComparator()); s.add(new Person(&quot;a&quot;, 1)); s.add(new Person(&quot;c&quot;, 3)); s.add(new Person(&quot;b&quot;, 2)); System.out.println(s); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List]]></title>
    <url>%2F2012%2F10%2F07%2FJavaSE%2F13.%E9%9B%86%E5%90%88%2F16%20-%20List%2F</url>
    <content type="text"><![CDATA[集合介绍 集合，集合是java中提供的一种容器，可以用来存储多个数据 在前面的学习中，我们知道数据多了，可以使用数组存放,那么，集合和数组既然都是容器，它们有啥区别呢 数组的长度是固定的。集合的长度是可变的 集合中存储的元素必须是引用类型数据 集合结构图 为什么使用集合框架 集合Collection的方法 Collection接口中的方法 是集合中所有实现类必须拥有的方法 使用Collection接口的实现类,程序的演示 ArrayList implements List List extends Collection 方法的执行,都是实现的重写 Conllection 集合中基本的方法 已知Collection 与 List 都是接口，而我们只能用多态的形式使用 创建集合的格式 方式1 ： Collection&lt;声明要存储元素的数据类型&gt; 变量名 = new ArrayList&lt;声明要存储元素的数据类型&gt;(); 声明要存储元素的数据类型只能是引用类型 方式2 ： Collection 变量名 = new ArrayList(); 存储的类型为Object 演示Collection接口中的方法 方式2演练 12345678910111213141516171819202122232425262728293031323334353637//创建集合Collection coll = new ArrayList(); //1,往集合中添加对象元素。add(E e)方法，E代表创建集合时所指定的数据类型如&lt;String&gt;，那么，E就代表String类型；创建集合时若没有指定数据类型，那么，E就代表Object类型。coll.add(&quot;江&quot;);coll.add(&quot;湖&quot;);coll.add(&quot;见&quot;); //把集合打印一下。System.out.println(coll); //打印结果为：[江, 湖, 见]System.out.println(coll.toString()); //打印结果为：[江, 湖, 见]//2,从集合中删除元素。remove(Object o)方法coll.remove(&quot;湖&quot;); //删除后，集合元素为[江, 见]//3,判断集合中是否包含指定元素。contains(Object o)方法System.out.println(coll.contains(&quot;江&quot;));//打印结果为trueSystem.out.println(coll.contains(&quot;湖&quot;));//打印结果为false //4,获取集合元素个数。size()方法System.out.println(coll.size());//打印结果为2//5,返回包含集合中所有元素的数组。toArray()方法 Object[] array = coll.toArray(); System.out.println(Arrays.toString(array));//数组中的元素为&#123;&quot;江&quot;, &quot;见&quot;&#125;//6,清除集合元素。remove()方法coll.clear();//清空后，集合元素为[]，代表没有元素//7.情况只是清空元素，集合照样存在继续添加值coll.add(&quot;缘&quot;);System.out.println(coll); 迭代器Iterator迭代器概述 java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。我们要取出这些集合中的元素，可通过一种通用的获取方式来完成 Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代 集合中把这种取元素的方式描述在Iterator接口中。Iterator接口的常用方法如下 hasNext（）方法：用来判断集合中是否有下一个元素可以迭代。如果返回true,说明可以迭代 next（）方法：用来返回迭代的下一个元素，并把指针向后移动一位 迭代集合图解 Iterator迭代方式的代码体现12345678910111213141516171819202122Collection coll = new ArrayList&lt;&gt;();coll.add(&quot;abc1&quot;);coll.add(&quot;abc2&quot;);coll.add(&quot;abc3&quot;);coll.add(&quot;abc4&quot;);coll.add(5);//2.获取容器的迭代器对象。通过iterator方法。Iterator it = coll.iterator();//3,使用具体的迭代器对象获取集合中的元素。参阅迭代器的方法while(it.hasNext())&#123; System.out.println(it.next());&#125;// it.next();/* 迭代器for循环的形式的使用for (Iterator it = coll.iterator(); it.hasNext(); ) &#123; System.out.println(it.next());&#125;*/ 注意：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误 集合元素向下转型 学习到这里，基本知道了Collection接口的简单使用。可是集合中可以存储任何对象，那么存放进去的数据都是还是原来类型吗？不是了，提升成了Object 在使用集合时，我们需要注意以下几点 集合中存储其实都是对象的地址 集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。因为出现了基本类型包装类，它提供了自动装箱操作（基本类型对象），这样，集合中的元素就是基本数值的包装类对象 存储时提升了Object。取出时要使用元素的特有内容，必须向下转型 1234567891011Collection coll = new ArrayList();coll.add(&quot;aa&quot;);coll.add(&quot;bb&quot;);coll.add(&quot;cc&quot;);Iterator it = coll.iterator();while (it.hasNext()) &#123; //由于元素被存放进集合后全部被提升为Object类型//当需要使用子类对象特有方法时，需要向下转型 String str = (String) it.next(); System.out.println(str);&#125; 注意 : 如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常java.lang.ClassCastException 123456789101112Collection coll = new ArrayList();coll.add(&quot;aa&quot;);coll.add(&quot;bb&quot;);coll.add(&quot;cc&quot;);coll.add(5);Iterator it = coll.iterator();while (it.hasNext()) &#123; //由于元素被存放进集合后全部被提升为Object类型//当需要使用子类对象特有方法时，需要向下转型 String str = (String) it.next(); System.out.println(str);&#125; 方式1演练 12345678910111213 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 此时集合里面只能存String类型的元素 coll.add(&quot;aa&quot;); coll.add(&quot;bb&quot;); coll.add(&quot;cc&quot;); // coll.add(5); 会报错 Iterator&lt;String&gt; it = coll.iterator(); while (it.hasNext()) &#123;String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str); &#125; 增强for循环 增强for循环是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作 格式 1234for(元素的数据类型 变量 : Collection集合or数组)&#123; &#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作 练习1遍历数组 1234int[] arr = new int[]&#123;11,22,33&#125;;for (int n : arr) &#123;//变量n代表被遍历到的数组元素 System.out.println(n);&#125; 遍历集合 12345678Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();coll.add(&quot;aa&quot;);coll.add(&quot;bb&quot;);coll.add(&quot;cc&quot;);coll.add(&quot;dd&quot;);for(String str : coll)&#123;//变量Str代表被遍历到的集合元素 System.out.println(str);&#125; 增强for循环和老式的for循环有什么区别？ 遍历数组时，如果仅为遍历，可以使用增强for如果要对数组的元素进行操作,增强for循环不能操作索引 泛型泛型的引入 在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换 123456789101112131415public class GenericDemo &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(&quot;abc&quot;); list.add(&quot;def&quot;); list.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = list.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); // 求出每一个字符串的长度 System.out.println(str.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException 为什么会发生类型转换异常呢？我们来分析下: 由于集合中什么类型的元素都可以存储。导致取出时，如果出现强转就会引发运行时 ClassCastException。怎么来解决这个问题呢？使用集合时，必须明确集合中元素的类型。这种方式称为：泛型 泛型的定义与使用 我们在集合中会大量使用到泛型，这里来完整地学习泛型知识 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递 含有泛型的类 定义格式：修饰符 class 类名&lt;代表泛型的变量&gt; { } 例如，API中的ArrayList集合 1234class ArrayList&lt;E&gt;&#123; public boolean add(E e) &#123; &#125; public E get(int index)&#123; &#125;&#125; 使用格式 : 创建对象时，确定泛型的类型 例如，ArrayList list = new ArrayList(); 此时，变量E的值就是String类型 1234class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125;&#125; * 例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer * 此时，变量E的值就是Integer类型 1234class ArrayList&lt;Integer&gt;&#123; public boolean add(Integer e)&#123; &#125; public Integer get(int index)&#123; &#125;&#125; 含有泛型的方法 定义格式: 修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ } 例如，API中的ArrayList集合中的方法 12public &lt;T&gt; T[] toArray(T[] a)&#123; &#125; //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组 使用格式 : 调用方法时，确定泛型的类型 例如 12public &lt;String&gt; String[] toArray(String[] a)&#123; &#125;public &lt;Integer&gt; Integer[] toArray(Integer[] a)&#123; &#125; 含有泛型的接口 定义格式：修饰符 interface接口名&lt;代表泛型的变量&gt; { } 例如，API中的Iterator迭代器接口 123public interface Iterator&lt;E&gt; &#123; public abstract E next();&#125; 使用格式: 一. 例如 1234public final class Scanner implements Iterator&lt;String&gt; &#123; public String next()&#123; &#125;&#125;// 此时变量E就是String类型 二.始终不确定泛型的类型，直到创建对象时，确定泛型的类型 123ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();Iterator&lt;String&gt; it = list.iterator();// 此时，变量E就是String类型 使用泛型的好处 将运行时期的ClassCastException,转移到了编译时期变成编译失败 避免了类型强转的麻烦 1234567891011121314public class GenericDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;a&quot;); //list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 //集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; 泛型通配符 泛型是在限定数据类型，当在集合或者其他地方使用到泛型后，那么这时一旦明确泛型的数据类型，那么在使用的时候只能给其传递和数据类型匹配的类型，否则就会报错 代码演示 定义迭代集合元素的方法 123456public static void printCollection(Collection&lt;Person&gt; list) &#123; Iterator&lt;Person&gt; it = list.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125;&#125; 调用方法 1234public static void main(String[] args)&#123; Collection&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); printCollection(list);&#125; 上面调用方法语句属于语法错误，因为泛型限定不一致。方法要的是Collection类型，传入的是Collection，二者类型不匹配 上述定义的printCollection方法中，由于定义的是打印集合的功能，应该是可以打印任意集合中元素的。但定义方法时，根本无法确定具体集合中的元素类型是什么。为了解决这个“无法确定具体集合中的元素类型”问题，java中，为我们提供了泛型的通配符&lt;?&gt; 对上面的方法，进行修改后，实现了可迭代任意元素类型集合的方法 123456public static void printCollection(Collection&lt;?&gt; list) &#123; Iterator&lt;?&gt; it = list.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125;&#125; 边界问题 12? super x 下边界 可以传入 x 以及父类? extends x 上边界 可以传入他和他的子类 总结 当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期对象]]></title>
    <url>%2F2012%2F10%2F06%2FJavaSE%2F12.%E5%8C%85%E8%A3%85%E7%B1%BB%2F03.%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[日期对象Date Date 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象 1234//创建日期对象，把当前的毫秒值转成日期对象Date date = new Date(1607616000000L);System.out.println(date);//打印结果：Fri Dec 11 00:00:00 CST 2020 可是将毫秒值转成日期后，输出的格式不利于我们阅读，继续查阅API，Date中有getYear、getMouth等方法，可以他们已经过时，继续往下查阅，看到了toString方法 点开toString()方法查阅，原来上面打印的date对象就是默认调用了这个toString方法，并且在这个方法下面还有让我们参见toLocaleString方法，点进去，这个方法又过时了，从 JDK 1.1 开始，由 DateFormat.format(Date date) 取代。 既然这个方法被DateFormat.format(Date date) 取代，那么就要去查阅DateFormat类 DateFormat DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat 类）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化 我们通过这个类可以帮我们完成日期和文本之间的转换 继续阅读API，DateFormat 可帮助进行格式化并解析任何语言环境的日期。对于月、星期，甚至日历格式（阴历和阳历），其代码可完全与语言环境的约定无关 日期格式 要格式化一个当前语言环境下的日期也就是日期 -&gt; 文本），要通过下面的方法来完成。DateFormat 是抽象类，我们需要使用其子类 SimpleDateFormat 来创建对象 构造方法 SimpleDateFortmat(String pattern) DateFormat类方法 String format(Date date) 123456代码演示：//创建日期格式化对象,在获取格式化对象时可以指定风格DateFormat df= new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//对日期进行格式化Date date = new Date(1607616000000L);String str_time = df.format(date);System.out.println(str_time);//2020年12月11日 DateFormat 类的作用：即可以将一个 Date 对象转换为一个符合指定格式的字符串，也可以将一个符合指定格式的字符串转为一个 Date 对象 指定格式的具体规则我们可参照 SimpleDateFormat 类的说明，这里做简单介绍，规则是在一个字符串中，会将以下字母替换成对应时间组成部分，剩余内容原样输出 当出现 y 时，会将 y 替换成年 当出现 M 时，会将 M 替换成月 当出现 d 时，会将 d 替换成日 当出现 H 时，会将 H 替换成时 当出现 m 时，会将 m 替换成分 当出现 s 时，会将 s 替换成秒 DateFormat 类常用方法 String format(Date date) 将一个 Date 格式化为 日期/时间字符串 Date parse(String source) 解析文本，生成一个日期 1234567891011练习一：把Date对象转换成StringDate date = new Date(1607616000000L);//Fri Dec 11 00:00:00 CST 2020DateFormat df = new SimpleDateFormat(“yyyy年MM月dd日”);String str = df.format(date);//str中的内容为2020年12月11日练习二：把String转换成Date对象String str = ”2020年12月11日”;DateFormat df = new SimpleDateFormat(“yyyy年MM月dd日”);Date date = df.parse( str );//Date对象中的内容为Fri Dec 11 00:00:00 CST 2020 LocalDate java.time.LocalDate：LocalDate 是一个不可变的类，它表示默认格式 (yyyy-MM-dd) 的日期，我们可以使用 now() 方法得到当前时间，也可以提供输入年份、月份和日期的输入参数来创建一个 LocalDate 实例。 1234567891011LocalDate today = LocalDate.now();System.out.println(&quot;Current Date=&quot; + today);LocalDate firstDay = LocalDate.of(2019, Month.JANUARY, 1);System.out.println(&quot;Specific Date=&quot; + firstDay);LocalDate dateFromBase = LocalDate.ofEpochDay(365);System.out.println(&quot;365th day from base date= &quot; + dateFromBase);LocalDate hundredDay2019 = LocalDate.ofYearDay(2019, 100);System.out.println(&quot;100th day of 2014=&quot; + hundredDay2019); 打印结果 1234Current Date=2019-05-21Specific Date=2019-01-01365th day from base date= 1971-01-01100th day of 2019=2019-04-10 static LocalDate parse(CharSequence text) 从一个文本字符串（如 2007-12-03获取一个 LocalDate的实例。 String toString() 将此日期输出为 String ，如 2007-12-03 。 int getYear( ) 获取当前日期的年份 int getMonthValue( ) 获取当前日期是第几月 DayOfWeek getDayOfWeek() 表示该对象表示的日期是星期几 int getValue( ) int getDayOfMonth() 表示该对象表示的日期是这个月第几天 int getDayOfYear() 表示该对象表示的日期是今年第几天 LocalDate withYear(int year) 修改当前对象的年份 LocalDate withMonth(int month) 修改当前对象的月份 boolean isLeapYear() 是否是闰年 int lengthOfMonth() 这个月有多少天 int lengthOfYear() 该对象表示的年份有多少天（365或者366） LocalDate plusYears(long yearsToAdd) 当前对象增加指定的年份数 LocalDate plusMonths(long monthsToAdd) 当前对象增加指定的月份数 LocalDate plusDays(long daysToAdd) 当前对象增加指定的天数 LocalDate minusYears(long yearsToSubtract) 当前对象减去指定的年数 LocalDate minusMonths(long monthsToSubtract) 当前对象减去注定的月数 LocalDate minusDays(long daysToSubtract) 当前对象减去指定的天数 int compareTo(ChronoLocalDate other) 比较当前对象和other对象在时间上的大小，返回值如果为正，则当前对象时间较晚 LocalTime java.time.LocalTime：LocalTime 是一个不可变的类，它的实例代表一个符合人类可读格式的时间，默认格式是 hh:mm:ss.zzz。像 LocalDate 一样，该类也提供了时区支持，同时也可以传入小时、分钟和秒等输入参数创建实例 static LocalTime now( ) 获取当前时分秒 LocalTime withNano(int n) 一般设置为0 清除纳秒 LocalDateTime java.time.LocalDateTime：LocalDateTime 是一个不可变的日期-时间对象，它表示一组日期-时间，默认格式是 yyyy-MM-dd-HH-mm-ss.zzz。它提供了一个工厂方法，接收 LocalDate 和LocalTime 输入参数，创建 LocalDateTime 实例 static LocalDateTime LocalDateTime() 获取当前年月日时分秒 把当前时间转为指定格式输出 String format = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”).format(LocalDateTime.now());]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2012%2F10%2F05%2FJavaSE%2F12.%E5%8C%85%E8%A3%85%E7%B1%BB%2F02.String%20StringBuffer%20StringBuilder%2F</url>
    <content type="text"><![CDATA[StringString 常用方法 int length( ) 求字符串的长度 String substring(int beginIndex) 截取一个新的字符串 String substring(int beginIndex, int endIndex) 截取指定范围的字符串 boolean startsWith(String prefix) 是否以指定的前缀开始 boolean endsWith(String suffix) 是否以指定的后缀结束 boolean contains(String s) 是否包含指定的字符串 int indexOf(String str) 查找指定字符串出现第一次出现的索引值 byte[] getBytes( ) 把字符串转成 byte 数组 char[] toCharArray( ) 把字符串转成 char 数组 boolean equals(Object anObject) 比较两个字符串的值是否相等 String toString( ) 把对象转成字符串 练习 String value = “123Eqsqwer “; 题目一: 获取指定字符串中，大写字母，小写字母，数字的个数 题目二: 将字符串中，第一个字母转换成大写，其他字母转换成小写，并打印改变后的字符串 题目三：查询大字符串中，出现指定小字符串的次数。如“hellojava,nihaojava,javazhenbang”中查询出现“java”的次数 StringBuffer StringBuffer append(String str) 拼接 StringBuffer delete(int start, int end) 删除 StringBuffer insert(int offset, String str) 插入 StringBuffer replace(int start, int end, String str) 替换 StringBuffer reverse( ) 反转 String toString( ) 把对象转为字符串 StringBuilder 查阅API学习]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型包装类]]></title>
    <url>%2F2012%2F10%2F04%2FJavaSE%2F12.%E5%8C%85%E8%A3%85%E7%B1%BB%2F01.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[基本类型包装类基本类型包装类概述 在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成 int 类型，考试成绩需要转换成 double 类型等。那么，想实现字符串与基本数据之间转换怎么办呢 Java 中提供了相应的对象来解决该问题，基本数据类型对象包装类：Java 将基本数据类型值封装成了对象。封装成对象有什么好处？可以提供更多的操作基本数值的功能 8种基本类型对应的包装类如下 其中需要注意int对应的是Integer，char对应的Character，其他6个都是基本类型首字母大写即可 更多精彩查阅 API]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F2012%2F10%2F03%2FJavaSE%2F11.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BC%82%E5%B8%B8%2F02.%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常什么是异常 Java代码在运行时期发生的问题就是异常 在Java中，把异常信息封装成了一个类。当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等） 异常体系 在Java中使用Exception类来描述异常 查看API中Exception的描述，Exception 类及其子类是 Throwable 的一种形式，它用来表示java程序中可能会产生的异常，并要求对产生的异常进行合理的异常处理 继续观察，我们可以发现Exception有继承关系，它的父类是Throwable。Throwable是Java 语言中所有错误或异常的超类，即祖宗类 另外，在异常Exception类中，有一个子类要特殊说明一下，RuntimeException子类，RuntimeException及其它的子类只能在Java程序运行过程中出现 我们再来观察Throwable类，能够发现与异常Exception平级的有一个Error，它是Throwable的子类，它用来表示java程序中可能会产生的严重错误。解决办法只有一个，修改代码避免Error错误的产生 异常继承体系总结 1234Throwable: 它是所有错误与异常的超类（祖宗类） |- Error 错误 |- Exception 编译期异常,进行编译JAVA程序时出现的问题 |- RuntimeException 运行期异常, JAVA程序运行过程中出现的问题 异常与错误的区别异常 指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。若不处理异常，程序将会结束运行 异常的产生演示如下 1234567public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr[0]); System.out.println(arr[3]);// 该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，由于没有处理异常，导致程序无法继续执行，程序结束。 System.out.println(&quot;over&quot;); // 由于上面代码发生了异常，此句代码不会执行&#125; 错误 指程序在运行期间发生了某种错误(XxxError)，Error错误通常没有具体的处理方式，程序将会结束运行。Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。我们无法针对处理，只能修正代码 错误的产生演示如下 12int[] arr = new int[1024*1024*100];//该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。 异常解析过程 先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程 工具类 1234567public class ArrayTools&#123; //对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr,int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;34,12,67&#125;; int num = ArrayTools.getElement(arr,4) System.out.println(&quot;num=&quot;+num); System.out.println(&quot;over&quot;); &#125;&#125; 上述程序执行过程图解 抛出异常throw 在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢 创建一个异常对象。封装一些提示信息(信息可以自己编写) 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行 使用格式 1throw new 异常类名(参数); 例如 12throw new NullPointerException(&quot;要访问的arr数组不存在&quot;);throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;); 123456789101112131415161718192021222324252627public class ArrayTools&#123; //通过给定的数组，返回给定的索引对应的元素值。 public static int getElement(int[] arr,int index) &#123; /* 若程序出了异常，JVM它会打包异常对象并抛出。但是它所提供的信息不够给力。想要更清晰，需要自己抛出异常信息。 下面判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ if(arr==null)&#123; throw new NullPointerException(&quot;arr指向的数组不存在&quot;); &#125; if(index&lt;0 || index&gt;=arr.length)&#123; throw new ArrayIndexOutOfBoundsException(&quot;错误的角标，&quot;+index+&quot;索引在数组中不存在&quot;); &#125; int element = arr[index]; return element; &#125;&#125;public class ExceptionDemo3 &#123; public static void main(String[] args) &#123; int[] arr = &#123;34,12,67&#125;; //创建数组 int num = ArrayTools.getElement(null,2);// 调用方法，获取数组中指定索引处元素 //int num = ArrayTools.getElement(arr,5);// 调用方法，获取数组中指定索引处元素 System.out.println(&quot;num=&quot;+num);//打印获取到的元素值 &#125;&#125; 声明异常throws 声明：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理 声明异常格式 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… &#123; &#125; 声明异常的代码演示 123456789101112public class Demo&#123; /* 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明。 */ public void show(int x)throws Exception &#123; if(x&gt;0)&#123; throw new Exception(); &#125; else &#123; System.out.println(&quot;show run&quot;); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开 1234567891011//多个异常的情况，例如:public static int getElement(int[] arr,int index) throws NullPointerException, ArrayIndexOutOfBoundsException &#123; if(arr==null)&#123; throw new NullPointerException(&quot;arr指向的数组不存在&quot;); &#125; if(index&lt;0 || index&gt;=arr.length)&#123; throw new ArrayIndexOutOfBoundsException(&quot;错误的角标，&quot;+index+&quot;索引在数组中不存在&quot;); &#125; int element = arr[index]; return element;&#125; 捕获异常try…catch…finally 捕获：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理 捕获异常格式 123456789try &#123; //需要被检测的语句。&#125;catch(异常类 变量) &#123; //参数。 //异常的处理语句。&#125;finally &#123; //一定会被执行的语句。&#125; try：该代码块中编写可能产生异常的代码 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理 finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的 1234567891011121314public class ExceptionDemo&#123; public static void main(String[] args)&#123; //throws ArrayIndexOutOfBoundsException try &#123; int[] arr = new int[3]; System.out.println( arr[5] );// 会抛出ArrayIndexOutOfBoundsException当产生异常时，必须有处理方式。要么捕获，要么声明。 &#125; catch (ArrayIndexOutOfBoundsException e) &#123; //括号中需要定义什么呢？try中抛出的是什么异常，在括号中就定义什么异常类型。 System.out.println(&quot;异常发生了&quot;); &#125; finally &#123; arr = null; //把数组指向null，通过垃圾回收器，进行内存垃圾的清除 &#125; System.out.println(&quot;程序运行结果&quot;); &#125;&#125; try…catch…finally异常处理的组合方式 try catch finally组合：检测异常，并传递给catch处理，并在finally中进行资源释放 try catch组合 : 对代码进行异常检测，并对检测的异常传递给catch处理。对异常进行捕获处理 1234567void show() &#123; //不用throws try&#123; throw new Exception();//产生异常，直接捕获处理 &#125;catch(Exception e)&#123; //处理方式 &#125;&#125; 一个try 多个catch组合 : 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理 1234567891011void show() &#123; //不用throws try&#123; throw new Exception();//产生异常，直接捕获处理 &#125; catch (XxxException e) &#123; //处理方式 &#125; catch (YyyException e) &#123; //处理方式 &#125; catch (ZzzException e) &#123; //处理方式 &#125;&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理 try finally 组合: 对代码进行异常检测，检测到异常后因为没有catch，所以一样会被默认jvm抛出。异常是没有捕获处理的。但是功能所开启资源需要进行关闭，所有finally。只为关闭资源 1234567void show() &#123;//需要throws try &#123; throw new Exception(); &#125; finally &#123; //释放资源 &#125;&#125; 运行时期异常 RuntimeException和他的所有子类异常,都属于运行时期异常。 NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常 运行时期异常的特点 方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常 运行时期异常一旦发生,需要程序人员修改源代码12345678class ExceptionDemo&#123; public static void main(String[] args)&#123; method(); &#125; public static void method()&#123; throw new RuntimeException(); &#125;&#125; 异常中常用方法 在Throwable类中为我们提供了很多操作异常对象的方法，常用的如下 getMessage方法：返回该异常的详细信息字符串，即异常提示信息 toString方法：返回该异常的名称与详细信息字符串 printStackTrace：在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置 异常的常用方法代码演示 自定义异常1234567public Class 异常名 extends Exception&#123; //或继承RuntimeException,模拟空指针异常 public 异常名()&#123; &#125; public 异常名(String s)&#123; super(s); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组]]></title>
    <url>%2F2012%2F10%2F02%2FJavaSE%2F11.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BC%82%E5%B8%B8%2F01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[二维数组什么是二维 二维数组里面放多个一维数组，看成一个平面 eg: 魂斗罗、坦克大战 什么是二维数组 二维数组本质上是以数组作为数组元素的数组，即“数组的数组” 二维数组又称为矩阵，行列数相等的矩阵称为方阵 创建二维数组123数据类型[][] 对象名 = new 数据类型[x][y];x代表行y代表列 例如 1int[][] a = new int[2][2]; 例如 1int[][] a = new int[2][2]; 数组: 使用索引来操作元素，下面给二维数组赋值 1234a[0][0] = 1;//第一行第一列a[0][1] = 2;//第一行第二列a[1][0] = 3;//第二行第一列a[1][1] = 4;//第二行第二列 遍历一个二维数组 123456for(int i = 0;i&lt;a.length;a++)&#123; // 外层循环代表行 a.length 求行数 for(int j = 0;j&lt;a[i].length;j++)&#123;//内层循环代表列 a[i].length 求每一行的列数 System.out.print(a[i][j]);//打印第i行第j列的值 &#125; System.out.println();&#125; 直接赋值 12int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;int[][] arr2 = new int[2][2]&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;; 练习： 打印杨辉三角]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays]]></title>
    <url>%2F2012%2F10%2F01%2FJavaSE%2F10.%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8E%92%E5%BA%8F%2F03.Arrays%2F</url>
    <content type="text"><![CDATA[Arrays概念 此类包含用来操作数组（比如排序和搜索）的各种方法。需要注意，如果指定数组引用为 null，则访问此类中的方法都会抛出空指针异常 NullPointerException 常用方法 sort方法，用来对指定数组中的元素进行排序（元素值从小到大进行排序） 123//源arr数组元素&#123;1,5,9,3,7&#125;, 进行排序后arr数组元素为&#123;1,3,5,7,9&#125;int[] arr = &#123;1,5,9,3,7&#125;;Arrays.sort( arr ); toString方法，用来返回指定数组元素内容的字符串形式 12int[] arr = &#123;1,5,9,3,7&#125;;String str = Arrays.toString(arr); // str的值为[1, 3, 5, 7, 9] binarySearch方法，在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为-1。要求该数组必须是个有序的数组 123int[] arr = &#123;1,3,4,5,6&#125;;int index = Arrays.binarySearch(arr, 4); //index的值为2int index2= Arrasy.binarySearch(arr, 2); //index2的值为-1]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2012%2F09%2F30%2FJavaSE%2F10.%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8E%92%E5%BA%8F%2F02.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法 冒泡排序什么是冒泡排序 冒泡排序是计算机领域一种较简单的排序算法。 它重复地访问要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。访问数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序” 原理 比较相邻的元素。如果第一个比第二个大，就交换他们两个 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数 针对所有的元素重复以上的步骤，除了最后一个(因为最后一个是最大的，不需要比较) 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较(最后一个数不需要比较，因为它是最小的) 12int[] arr = &#123;9, 1, 7, 5&#125;;// 利用冒泡排序算法进行升序排列 123456789101112for(int z = 0;z &lt; arr.length-1;z++)&#123; for(int x = 0;x &lt; arr.length -1 - z;x++)&#123; if(arr[x] &gt; arr[x + 1])&#123; int temp = arr[x]; arr[x] = arr[x + 1]; arr[x+1] = temp; &#125; &#125;&#125;for(int i = 0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]);&#125; 原则排序什么是选择排序 选择排序是一种简单直观的排序算法。 用第一个元素依次以后面的比较，满足条件则交换 如果是升序每次可以确定一个最小值 如果是降序每次可以确定一个最大值 用第一个元素与后面的依次比较以后就可以确定第一个元素是最小值，然后就用第二个元素去比较确定倒数第二小的值，以此类推，比较到倒数第二个元素确定时，最后一个元素就是最大值 1int[] a = &#123;9,1,7,5,3&#125;; 123456789101112for(int i = 0;i&lt;a.length -1;i++)&#123; for(int j = i+1;j&lt;a.length;j++)&#123; if(a[i] &gt; a[j])&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125;&#125;for(int k : a)&#123; System.out.println(k);&#125; 插入排序原理 将初始序列中的第一个元素作为一个有序序列，然后将剩下的 n-1 个元素按关键字大小依次插入该有序序列，每插入一个元素后依然保持该序列有序，经过 n-1 趟排序后使初始序列有序 1int[ ] a = &#123;9,1,7,5&#125;; 第一步 第二步 第三步 如图所示 12345678910for(int i = 1;i&lt;a.length;i++)&#123; // 因为值是从第二个位置(索引为1)拿出来的 所以 i 从 1 开始 int temp = a[i]; // 把a[i] 赋值给 temp 变量 int j = i - 1; // j 当作一个索引 ,a[j] 的值就是temp值的前一位值 while(j&gt;=0 &amp;&amp; a[j] &gt; temp)&#123;// a[j] &gt; temp ，把拿出来的值与前面的做比较 a[j+1] = a[j]; // 如果满足条件就把前面的值放到后面来 j--; // j-- , 因为要把拿出来的值依次与前面的值比较， // while里面的 j &gt;=0 ,在这里当 j=0时,j--会索引越界 所以 j&gt;=0 &#125; a[j+1] = temp; // 把拿出来的值放到指定的位置(根据比较的结果来放入)&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2012%2F09%2F29%2FJavaSE%2F10.%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8E%92%E5%BA%8F%2F01.%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组什么是数组 ？ 数组是一个容器，用来存储多个数据(数据类型相同) 声明一个变量就是再内存空间画出一块合适的空间 声明一个数组就是在内存中间划出一串连续的空间 数组的结构和基本要数 标识符:数组的名称，用于区分不同的数组 数组元素:向数组中存放的数据 元素的索引(下标|角标)：对数组元素进行编号 元素类型：数组元素的数据类型 注意 数组只有一个名称，即标识符 元素索引标明了元素在数组中的位置，下标从 0 开始 数组中的每个元素都可以通过索引来访问 数组长度固定不变，避免数组索引越界 数组变量属于引用数据类型 如何使用数组动态初始化 数组的创建与初始化分开完成1234int[] a = new int[3];a[0] = 1;a[1] = 2;a[2] = 3; 静态初始化 在创建数组对象时就完成初始化 12int[] a = &#123;1, 2, 3&#125;;int[] a = new int[]&#123;1, 2, 3&#125;; 单独的去除数组里面的值 1234//因为数组使用索引操作，下标从0开始System.out.println(a[0]);System.out.println(a[1]);System.out.println(a[2]); 利用循环取出数组的值 12345678/* a.length 是求出输出的长度 a.length 结果为3 因为索引从 0 开始，所以 i = 0;*/for(int i = 0;i &lt; a.length;a++)&#123; // i的最大值为2 ，所以判断的时候 i &lt; a.length System.out.println(a[i]);&#125; 操作数组的时可能会出现哪些异常？出现这些异常的原因是什么 ? 数组索引越界异常 : ArrayIndexOutOfBoundsException 原因:访问了数组中不存在的索引 例如: int[] a = {1,2,3}; System.out.println(a[3]); 空指针异常: NullPointerException 原因:当数组的索引被置为null,然后还去访问数组里面的元素，就会出现空指针异常 增强for循环遍历数组1234int[] b = &#123;3,4,5,2,1&#125;;for(int i : b)&#123; System.out.println(i);// 不能操作索引&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final]]></title>
    <url>%2F2012%2F09%2F28%2FJavaSE%2F09.Java%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81%2F05.final%2F</url>
    <content type="text"><![CDATA[finalfinal 的概念 继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢? 要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final 是个修饰符，它可以用来修饰类，类的成员，以及局部变量 final 的特点 final修饰类不可以被继承，但是可以继承其他类 123public class Yy &#123;&#125;public final class Fu extends Yy&#123;&#125; //可以继承Yy类public class Zi extends Fu&#123;&#125; //不能继承Fu类 final 修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加 final 12345678910public class Fu &#123; // final修饰的方法，不可以被覆盖，但可以继承使用 public final void method1()&#123;&#125; public void method2()&#123;&#125;&#125;public class Zi extends Fu &#123; //重写method2方法 public final void method2()&#123;&#125;&#125; final 修饰的变量称为常量，这些变量只能赋值一次 12final int i = 20;i = 30; //赋值报错，final修饰的变量只能赋值一次 引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改 1234final Person p = new Person();Person p2 = new Person();p = p2; //final修饰的变量p，所记录的地址值不能改变p.name = &quot;小明&quot;;//可以更改p对象中name属性值 p不能为别的对象，而p对象中的name或age属性值可更改 修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。) 1234567891011public class Demo &#123; //直接赋值 final int m = 100; //final修饰的成员变量，需要在创建对象前赋值，否则报错。 final int n; public Demo()&#123; //可以在创建对象时所调用的构造方法中，为变量n赋值 n = 2016; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态]]></title>
    <url>%2F2012%2F09%2F27%2FJavaSE%2F09.Java%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81%2F04.%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态多态的概述 多态是继封装、继承之后，面向对象的第三大特性 现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态 Java 作为面向对象的语言，同样可以描述一个事物的多种形态。如 Student 类继承了 Person 类，一个 Student 的对象便既是 Student 又是 Person Java 中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值 如 Student 类可以为 Person 类的子类。那么一个 Student 对象既可以赋值给一个 Student 类型的引用，也可以赋值给一个 Person 类型的引用 最终多态体现为父类引用变量可以指向子类对象 多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态 在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法 多态的定义与使用的格式 多态的定义格式：就是父类的引用变量指向子类对象 12父类类型 变量名 = new 子类类型();变量名.方法名(); 普通类多态定义的格式1234public class Zi extends Fu&#123;&#125;public class Fu &#123;&#125;Fu f = new Zi(); 多态-成员的特点. 掌握了多态的基本使用后，那么多态出现后类的成员有啥变化呢？前面学习继承时，我们知道子父类之间成员变量有了自己的特定变化，那么当多态出现后，成员变量在使用上有没有变化呢？ 多态出现后会导致子父类中的成员变量有微弱的变化 123456789101112131415161718192021public class Fu &#123; int num = 4; public void show() &#123; System.out.println(&quot;Fu&quot;); &#125;&#125;public class Zi extends Fu &#123; int num = 5; public void show() &#123; System.out.println(&quot;Zi&quot;); &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; Fu f = new Zi(); System.out.println(f.num); // 4 f.show(); // Zi &#125;&#125; 调用方法看等号右边，调用属性看等号左边 instanceof 比较运算符 返回一个布尔值 123456boolean b = 对象 instanceof 数据类型;如：Person p1 = new Student(); // 前提条件，学生类已经继承了人类boolean flag = p1 instanceof Student; //flag结果为trueboolean flag2 = p2 instanceof Teacher; //flag结果为false]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口]]></title>
    <url>%2F2012%2F09%2F26%2FJavaSE%2F09.Java%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81%2F03.%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口接口的概念 接口是功能的集合，是一个比抽象类更加抽象的类,接口也是一种数据类型 接口里面只描述做么些事情，并没有具体的实现 具体的实现由子类完成，将功能的定义与实现分离 世间万物均有接口 接口的定义 定义类用 class 而定义接口则用 interface 接口里面只能有常量，必须初始化的时候赋值 接口里面只能有抽象方法（1.8版本之前） 123456public interface 接口名&#123; // 常量 public static final 数据类型 常量名 = 值; // 抽象方法 public abstract viod 方法名();&#125; 其中常量上面的 public final 与接口上面 abstract 可以省略不写 1234public interface Animal&#123; int age = 5; public void eat();&#125; 使用 interface 代替了原来的 class 其余步骤与类相同 接口中的方法均为公共访问的方法 接口中无法定义普通的成员变量 类实现接口 类与接口的关系为实现关系,实现的动作类似继承，用的关键字不同，实现使用 implements 一个类实现一个接口后拥有该接口的所有功能，需要重写该接口里面所有的抽象方法 123public class 类 implements 接口&#123; 重写接口的抽象方法;&#125; 接口的多实现 接口最重要的体现:解决多继承的弊端。将多继承这种机制在Java中通过多实现完成了 123456789101112public interface Fu1&#123; void show1();&#125;public interface Fu2&#123; void show2();&#125;public class Zi implements Fu1,Fu2&#123;// 多实现，同时实现多个接口 public void show1(); public void show2();&#125; 怎么解决多继承的弊端? 弊端:多继承时，当多个父类中有相同的功能时，子类调用会产生不确定性。其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。 为什么多实现能解决呢? 因为接口中的功能都没有方法体，由子类来明确 类继承类同时实现接口 接口和类之间可以通过实现产生关系，同时也学习了类与类之间可以通过继承产生关系。当一个类已经继承了一个父类，它又需要扩展额外的功能，这时接口就派上用场了 子类通过继承父类扩展功能，通过继承扩展的功能都是子类应该具备的基础功能。如果子类想要继续扩展其他类中的功能呢？这时通过实现接口来完成 12345678910111213public class Fu&#123; public void show()&#123; &#125;&#125;public interface Inter&#123; public abstract void show1();&#125;public class Zi extends Fu implements Inter&#123; public void show1();&#125; 接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能 接口的多继承 学习类的时候，知道类与类之间可以通过继承产生关系，接口和类之间可以通过实现产生关系，那么接口与接口之间会有什么关系 多个接口之间可以使用 extends 进行继承 123456789101112131415public interface Fu1&#123; void show1();&#125;public interface Fu2&#123; void show2();&#125;public interface Fu3&#123; void show3();&#125;public interface Zi extends Fu1,Fu2,Fu3&#123; void show();&#125; 在开发中如果多个接口中存在相同方法，这时若有个类实现了这些接口，那么就要实现接口中的方法，由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性 接口的好处 接口的出现扩展了功能 接口其实就是暴露出来的规则 接口的出现降低了耦合性 案例 定义鼠标、键盘，笔记本三者之间应该遵守的规则 12345interface USB &#123; void open();// 开启功能 void close();// 关闭功能&#125; 鼠标实现USB规则 123456789public class Mouse implements USB &#123; public void open() &#123; System.out.println(&quot;鼠标开启&quot;); &#125; public void close() &#123; System.out.println(&quot;鼠标关闭&quot;); &#125;&#125; 键盘实现USB规则 123456789public class KeyBoard implements USB &#123; public void open() &#123; System.out.println(&quot;键盘开启&quot;); &#125; public void close() &#123; System.out.println(&quot;键盘关闭&quot;); &#125;&#125; 定义笔记本 12345678910111213141516171819public class NoteBook &#123; // 笔记本开启运行功能 public void run() &#123; System.out.println(&quot;笔记本运行&quot;); &#125; // 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备 public void useUSB(USB usb) &#123; // 判断是否有USB设备 if (usb != null) &#123; usb.open(); usb.close(); &#125; &#125; public void shutDown() &#123; System.out.println(&quot;笔记本关闭&quot;); &#125;&#125; 测试 123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; // 创建笔记本实体对象 NoteBook nb = new NoteBook(); // 笔记本开启 nb.run(); // 创建鼠标实体对象 Mouse m = new Mouse(); // 笔记本使用鼠标 nb.useUSB(m); // 创建键盘实体对象 KeyBoard kb = new KeyBoard(); // 笔记本使用键盘 nb.useUSB(kb); // 笔记本关闭 nb.shutDown(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类]]></title>
    <url>%2F2012%2F09%2F25%2FJavaSE%2F09.Java%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81%2F02.%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类抽象类的产生 当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的功能具体实现方式，那么这些方法都有具体的方法体 但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。比如一个图形类应该有一个求周长的方法，但是不同的图形求周长的算法不一样。那该怎么办呢？ 分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法 描述 JavaEE 工程师：行为：工作。 描述 Android 工程师：行为：工作 JavaEE工程师和 Android 工程师之间有共性，可以进行向上抽取。抽取它们的所属共性类型：研发部员工。由于 JavaEE 工程师和 Android 工程师都具有工作功能，但是他们具体工作内容却不一样。这时在描述研发部员工时，发现了有些功能（工作）不具体，这些不具体的功能，需要在类中标识出来，通过 Java 中的关键字 abstract(抽象) 当定义了抽象函数的类也必须被 abstract 关键字修饰，被abstract关键字修饰的类是抽象类 抽象类与抽象方法的定义 抽象方法定义的格式 1public abstract 返回值类型 方法名(参数); 抽象类定义的格式 12public abstract class 类名 &#123;&#125; 看代码 123456789101112131415161718//研发部员工 public abstract class Developer &#123; public abstract void work();//抽象函数。需要abstract修饰，并分号;结束&#125;//JavaEE工程师public class JavaEE extends Developer&#123; public void work() &#123; System.out.println(&quot;正在研发淘宝网站&quot;); &#125;&#125;//Android工程师public class Android extends Developer &#123; public void work() &#123; System.out.println(&quot;正在研发淘宝手机客户端软件&quot;); &#125;&#125; 抽象类的特点 抽象类和抽象方法都需要被 abstract 修饰。抽象方法一定要定义在抽象类中。 抽象类不可以直接创建对象，原因：调用抽象方法没有意义。 只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类 之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单 抽象类的细节问题 抽象类一定是个父类 ？ 是的，因为不断抽取而来的。 抽象类中是否可以不定义抽象方法。 是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用 抽象关键字 abstract 不可以和哪些关键字共存? private、static、final]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object]]></title>
    <url>%2F2012%2F09%2F24%2FJavaSE%2F09.Java%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81%2F01.Object%2F</url>
    <content type="text"><![CDATA[ObjectObject 概述 Object 类是 Java 语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。所有类在创建对象的时候，最终找的父类就是Object boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。 int hashCode() 返回该对象的哈希码值。 Class&lt;?&gt; getClass() 返回此 Object 的运行时类。 String toString() 返回该对象的字符串表示。 所有的类都可以使用 Object 里面的方法 其它方法之后在讲]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重写]]></title>
    <url>%2F2012%2F09%2F23%2FJavaSE%2F08.Java%20%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%A7%E6%89%BF%2F04.Java%20%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[重写子父类中成员方法的特点 当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法 1234567891011121314151617class Fu&#123; public void show()&#123; System.out.println(&quot;Fu类中的show方法执行&quot;); &#125;&#125;class Zi extends Fu&#123; public void show2()&#123; System.out.println(&quot;Zi类中的show2方法执行&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); //子类中没有show方法，但是可以找到父类方法去执行 z.show2(); &#125;&#125; 成员方法特殊情况——覆盖 子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖1234567891011public class Fu&#123; public void show()&#123; System.out.println(&quot;Fu show&quot;); &#125;&#125;public class Zi extends Fu&#123; //子类复写了父类的show方法 public void show()&#123; System.out.println(&quot;Zi show&quot;); &#125;&#125; 方法重写（覆盖）的应用 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容 12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args) &#123; new NewPhone().showNum(); &#125;&#125;//手机类public class Phone&#123; public void sendMessage()&#123; System.out.println(&quot;发短信&quot;); &#125; public void call()&#123; System.out.println(&quot;打电话&quot;); &#125; public void showNum()&#123; System.out.println(&quot;来电显示号码&quot;); &#125;&#125;//智能手机类public class NewPhone extends Phone&#123; //覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能 public void showNum()&#123; //调用父类已经存在的功能使用super super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println(&quot;显示来电姓名&quot;); System.out.println(&quot;显示头像&quot;); &#125;&#125; 重写的注意事项 子类方法覆盖父类方法，必须要保证权限大于等于父类权限 12345678public class Fu()&#123; public void show()&#123; &#125; public void method()&#123; &#125;&#125;public class Zi extends Fu&#123; public void show()&#123; &#125; //编译运行没问题 void method()&#123; &#125; //编译错误&#125; 写法上稍微注意:必须一模一样:方法的返回值类型 方法名 参数列表都要一样 总结：当一个类是另一个类中的一种时，可以通过继承，来继承属性与功能。如果父类具备的功能内容需要子类特殊定义时，进行方法重写]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之继承]]></title>
    <url>%2F2012%2F09%2F22%2FJavaSE%2F08.Java%20%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%A7%E6%89%BF%2F03.Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[面向对象之继承继承概念 在现实生活中，继承一般指的是子女继承父辈的财产。在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如公司中的研发部员工和维护部员工都属于员工，程序中便可以描述为研发部员工和维护部员工继承自员工，同理，JavaEE 工程师和Android 工程师继承自研发部员工，而维网络维护工程师和硬件维护工程师继承自维护部员工。这些员工之间会形成一个继承体系 在 Java 中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有非私有的属性和方法 继承的格式与使用 在程序中，如果想声明一个类继承另一个类，需要使用extends关键字 格式 123public class 子类 extends 父类 &#123;&#125; 接下来通过一个案例来学习子类是如何继承父类的 1234567891011121314151617181920212223242526272829303132/* * 定义员工类Employee */class Employee &#123; String name; // 定义name属性 // 定义员工的工作方法 public void work() &#123; System.out.println(&quot;尽心尽力地工作&quot;); &#125;&#125;/* * 定义研发部员工类Developer 继承 员工类Employee */class Developer extends Employee &#123; // 定义一个打印name的方法 public void printName() &#123; System.out.println(&quot;name=&quot; + name); &#125;&#125;/* * 定义测试类 */public class Example01 &#123; public static void main(String[] args) &#123; Developer d = new Developer(); // 创建一个研发部员工类对象 d.name = &quot;小明&quot;; // 为该员工类的name属性进行赋值 d.printName(); // 调用该员工的printName()方法 d.work(); // 调用Developer类继承来的work()方法 &#125;&#125; 在上述代码中，Developer 类通过 extends 关键字继承了 Employee 类，这样 Developer 类便是 Employee 类的子类。从运行结果不难看出，子类虽然没有定义 name 属性和 work( ) 方法，但是却能访问这两个成员。这就说明，子类在继承父类的时候，会自动拥有父类的成员. 继承的好处与注意事项 继承的好处 继承的出现提高了代码的复用性，提高软件开发效率。 继承的出现让类与类之间产生了关系，提供了多态的前提 在类的继承中，需要注意一些问题，具体如下 在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类123public class A&#123; &#125; public class B&#123; &#125;public class C extends A,B&#123; &#125; // C类不可以同时继承A类和B类 多个类可以继承一个父类，例如下面这种情况是允许的 123public class A&#123; &#125;public class B extends A&#123; &#125;public class C extends A&#123; &#125; // 类B和类C都可以继承类A 在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的 123public class A&#123; &#125;public class B extends A&#123; &#125; // 类B继承类A，类B是类A的子类public class C extends B&#123; &#125; // 类C继承类B，类C是类B的子类，同时也是类A的子类 在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。例如上面的这种情况中，B类是A类的子类，同时又是C类的父类]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static 关键字]]></title>
    <url>%2F2012%2F09%2F21%2FJavaSE%2F08.Java%20%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%A7%E6%89%BF%2F02.static%20%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static 被static修饰的成员变量属于类，不属于这个类的某个对象 多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量 12345678910111213public class Demo &#123; public static int num = 100;&#125;public class Test &#123; public static void main(String[] args) &#123; Demo d1 = new Demo(); Demo d2 = new Demo(); d1.num = 200; System.out.println(d1.num); //结果为200 System.out.println(d2.num); //结果为200 &#125;&#125; 被static修饰的成员可以并且建议通过类名直接访问 类名.静态成员变量名 类名.静态成员方法名(参数) 对象名.静态成员变量名 —— 不建议使用该方式，会出现警告 对象名.静态成员方法名(参数) —— 不建议使用该方式，会出现警告 123456789101112131415public class Demo &#123; //静态成员变量 public static int num = 100; //静态方法 public static void method()&#123; System.out.println(&quot;静态方法&quot;); &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; System.out.println(Demo.num); Demo.method(); &#125;&#125; static 注意事项 静态内容是优先于对象存在，只能访问静态，不能使用this/super。静态修饰的内容存于静态区 123456789class Demo &#123; //成员变量 public int num = 100; //静态方法 public static void method()&#123; //this.num; 不能使用this/super。 System.out.println(this.num); &#125;&#125; 同一个类中，静态成员只能访问静态成员 1234567891011public class Demo &#123; //成员变量 public int num = 100; //静态成员变量 public static int count = 200; //静态方法 public static void method()&#123; //System.out.println(num); 静态方法中，只能访问静态成员变量或静态成员方法 System.out.println(count); &#125;&#125; main方法为静态方法仅仅为程序执行入口，它不属于任何一个对象，可以定义在任意类中 静态代码块与构造代码块1234567891011public class Person &#123; static &#123; System.out.println(&quot;静态代码块&quot;); &#125; &#123; System.out.println(&quot;构造代码块&quot;); &#125;&#125; 加载顺序： 静态代码块 -&gt; 构造代码块 -&gt; 构造方法]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象之封装]]></title>
    <url>%2F2012%2F09%2F20%2FJavaSE%2F08.Java%20%E5%B0%81%E8%A3%85%E4%B8%8E%E7%BB%A7%E6%89%BF%2F01Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[面向对象之封装封装的两层含义 对功能的封装：比如我们的方法，方法就是一个功能的实现 对数据的封装：就比如手机的价格、屏幕等 封装的表现 方法就是一个最基本的封装 类其实就是一个封装体 封装的好处 提高了代码的复用性 隐藏实现细节，对外提供可以访问的方法。便于使用者去使用，这是核心之一，也就是理解为封装的概念。 提高了安全性 封装举例 人 属性 姓名 年龄 方法 吃饭 睡觉 不私有化属性12345678910111213141516public class Person&#123; String name; int age; public void eat()&#123; System.out.println(name + &quot;在吃饭&quot;); &#125;&#125;public class PersonDemo&#123; public static void main()&#123; //创建Person的对象 Person person = new Person(); person.name=&quot;人妖&quot;; person.age = &quot;18&quot;; p.eat(); &#125;&#125; 通过上述代码，我们用Java代码把Person描述清楚了，但有个严重的问题，就是Person中的属性是可以用直接访问的 怎么才能不让直接访问呢? 需要使用java中的一个关键字private(私有,权限修饰符)。只要将Person的属性和行为私有起来，这样就无法直接访问 私有化属性123456789101112131415161718192021222324252627282930313233public class Person&#123; private String name; private int age; /* 提供set与get方法 */ public void setName(String name)&#123; this.name = name;//this代表本类对象 &#125; public String getName()&#123; return this.name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public int getAge()&#123; return this.age; &#125; public void eat()&#123; System.out.println(name + &quot;在吃饭&quot;); &#125;&#125;public class PersonDemo&#123; public static void main(String[] args)&#123; Person person = new Person(); //现在 person.name = &quot;人妖&quot;；是行不通的，那我们要肿么办呢？ person.setName(&quot;小则&quot;); &#125; &#125; 总结 类中不需要对外提供的内容都私有化，包括属性和方法 以后再描述事物，属性都私有化，并提供setXxx getXxx方法对其进行访问 注意：私有仅仅是封装的体现形式而已]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数与this关键字]]></title>
    <url>%2F2012%2F09%2F19%2FJavaSE%2F07.Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85%2F03.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8Ethis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[构造方法 在开发中经常需要在创建对象的同时明确对象的属性值，比如员工入职公司就要明确他的姓名、年龄等属性信息 那么，创建对象就要明确属性值，那怎么解决呢？也就是在创建对象的时候就要做的事情，当使用new关键字创建对象时，怎么给对象的属性初始化值呢？这就要学习Java另外一门小技术，构造方法 那什么是构造方法呢？从字面上理解即为构建创造时用的方法，即就是对象创建时要执行的方法。既然是对象创建时要执行的方法，那么只要在new对象时，知道其执行的构造方法是什么，就可以在执行这个方法的时候给对象进行属性赋值 构造方法格式123修饰符 构造方法名(参数列表)&#123;&#125; 构造方法的体现 构造方法没有返回值类型。也不需要写返回值。因为它是为构建对象的，对象创建完，方法就执行结束 构造方法名称必须和类型保持一致 构造方法没有具体的返回值 构造方法的代码体现1234567891011121314151617class Person &#123; // Person的成员属性age和name int age; String name; // Person的构造方法，拥有参数列表 Person(int age, String name) &#123; // 接受到创建对象时传递进来的值，将值赋给成员属性 this.age = age; this.name = name; &#125; public void speak() &#123; System.out.println(&quot;name=&quot; + name + &quot;,age=&quot; + age); &#125; &#125; this 关键字 this 代表使用者]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象设计原则]]></title>
    <url>%2F2012%2F09%2F18%2FJavaSE%2F07.Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85%2F02.Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[面向对象设计原则 开 : 开闭原则 口 : 接口隔离原则 合 : 组合|聚合原则 里 : 里式替换原则 最 : 最少知识原则（迪米特法则） 单 : 单一职责原则 依 : 依赖倒置原则 开闭原则 因为： 开放封闭原则主要体现在对扩展开放、对修改封闭，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。 所以： 可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭，对扩展开放的设计思路。 封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象 接口隔离原则 因为： 提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。 所以： 建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障 组合|聚合复用原则 因为： 其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。 如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。 所以： 组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用 里式替换原则 因为： 里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 所以： 使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 迪米特法则 因为： 类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式；对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。 所以： 一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用，在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用 单一职责原则 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则 依赖倒置原则 因为： 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。 所以： 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。 生命不息学习不止，搞懂设计模式则是需要时间的沉淀与知识的积累]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象]]></title>
    <url>%2F2012%2F09%2F17%2FJavaSE%2F07.Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85%2F01.Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象 面向对象编程（OOP - Object Oriented Programing） 面向过程与面向对象的区别 面向过程与面向对象都是我们编程中编写程序的一种思维方式 面向过程的程序设计方式，是遇到一件事时，思考”我该怎么做”，然后一步步实现的过程 面向对象的程序设计方式，是遇到一件事时，思考”我该让谁来做”，然后那个”谁”就是对象 使用面向对象的好处 面向对象思维方式是一种更加符合人们思考习惯的思想 面向对象中更多体现的是指挥着(指挥对象做事情) 面向对象思维方式将复杂的问题简单化 面向对象举例 超市 客户 姓名：小龙女 身高：160cm 身高：60kg 操作：购物 收银员 姓名：啊明 部门：财务部 员工编号：00001 操作：收银、打印账单、刷卡 汽车 123456789public class Car &#123; // 颜色 String color; // 轮胎个数 int number; public void run() &#123; System.out.println(&quot;一辆颜色为&quot;+color+&quot;轮子数为&quot;+number+&quot;的车行驶在蜿蜒的马路上&quot;); &#125;&#125; 类与对象的区别 在程序中对事物的描述与该事物在现实中的形态保持一致。为了做到这一点，面向对象的思想中提出两个概念，即类和对象。其中 类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体 面向对象三大特性 封装 只隐藏对象的属性和实现细节，仅对外提供公共访问方式 好处： 将变化隔离、便于使用、提高复用性、提高安全性 原则：将不需要对外提供的内容隐藏起来；把属性隐藏，提供公共方法对其访问 继承 子类自动拥有父类非私有的属性与方法 提高代码复用性；继承是多态的前提 多态 类的多种形态。是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象 好处：提高了程序的扩展性 弊端：当父类引用指向子类对象时，虽提高了扩展性，但只能访问父类中具备的方法，不可访问子类中的方法；即访问的局限性 前提：实现或继承关系；覆写父类方法]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 递归]]></title>
    <url>%2F2012%2F09%2F16%2FJavaSE%2F06.Java%20%E6%96%B9%E6%B3%95%2F03.Java%20%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归递归的概述 递归，指在当前方法内调用自己的这种现象 递归演示 12345 public void method()&#123; System.out.println(“递归的演示”); //在当前方法内调用自己 method();&#125; 递归分为两种直接递归 递归的代码演示，计算 1-n 之间的和，使用递归完成 123456789101112131415public class DiGuiDemo &#123; public static void main(String[] args) &#123; //计算1~num的和，使用递归完成 int n = 5; int sum = getSum(n); System.out.println(sum); &#125; public static int getSum(int n) &#123; if(n == 1)&#123; return 1; &#125; return n + getSum(n-1); &#125;&#125; 注意：递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出 间接递归 间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法 1234567891011121314151617public class Hello &#123; public static void main(String[] args) &#123; Hello hello = new Hello(); hello.a(); &#125; public void a() &#123; b(); &#125; public void b() &#123; c(); &#125; public void c() &#123; a(); &#125;&#125; 递归有入口，一定要有出口，不然会导致栈溢出]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 方法的重载]]></title>
    <url>%2F2012%2F09%2F15%2FJavaSE%2F06.Java%20%E6%96%B9%E6%B3%95%2F02.Java%20%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[方法的重载什么是方法的重载 在同一个类中 方法名相同 参数列表不同(顺序、个数、类型) 与返回值无关 123456789101112131415161718192021public void test1()&#123; &#125;public void test1(int i)&#123; &#125;public void test1(String name)&#123; &#125;public void test1(char sex)&#123; &#125;public void test1(double weight)&#123; &#125;public void test1(int i,int j)&#123; &#125;public void test1(int i,String name)&#123; &#125; 方法参数种类基本数据类型 基本数据类型的变量当做参数传递的时候 方法的局部变量会随着方法的执行完毕而被释放 局部变量: 定义在方法的声明上和 方法体内 引用类型 引用数据类型当做参数传递，其实传递的是地址值 即使方法执行完毕，但是实体(对象、数组)还在对内存中]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 方法概述]]></title>
    <url>%2F2012%2F09%2F14%2FJavaSE%2F06.Java%20%E6%96%B9%E6%B3%95%2F01.Java%20%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是方法？ 我们经常说做事要有方式方法。实现某个目的的具体过程. 例如我们学过 main 函数在里面写求水仙花数、斐波那契数列等 为什么要用方法？123eg: 例如有两 小明、小红两个人，小明求 5!，小红求 10！，这个时候都需要求阶乘。此时我们可以制作一个方法来求任何数的阶乘写且只写一次，供多次使用，提高代码的复用性 方法的种类 两类四种 方法的格式123访问修饰符 是否静态 有无返回值 方法名( 有无参数 )&#123; &#125; 无返回值无参数无返回值123public void demo() &#123; System.out.println(&quot;无参数无返回值&quot;);&#125; 无参数有返回值1234public int demo2() &#123; return 18;&#125; 返回值可以是任意的类型，使用 return 关键字来返回数据，同时也是结束此方法 定义方法的步骤 两个明确 是否有返回值 是否有参数 方法执行流程 定义的方法不被调用的时候是不会去执行的 在主函数里面需要创建方法所在类的对象去调用方法，类似于我们写的 Random rd = new Random( ); 调用者：主函数 main 执行者：某一个方法本身 实际参数：实际参与运算的数据 形式参数：方法上小括号里面的参数 有返回值无参数有返回值123public String demo3() &#123; return &quot;阿梅&quot;;&#125; 有参数有返回值123public double demo4(double weight) &#123; return weight;&#125; 每一个方法最后一行都有一个return，没有返回值可以省略不写，但系统会帮我们添加一个，其作用就是为了结束方法如果手动的写出 return 就不允许带回任意的数据。 定义方法注意事项 方法不能定义在另一个方法里面 不能写错格式 注意参数列表 返回值是void , return 可以省略不写 return 结束此方法，所以下面不能写代码 方法的返回值要和 return 返回的数据类型对应 练习 传递两个值，计算它们的 + ，- ， *，/，%]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java循环结构]]></title>
    <url>%2F2012%2F09%2F13%2FJavaSE%2F05.Java%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%2F01.Java%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[循环结构 什么是循环 ？ 给班上学生打印试卷，打印机循环了 n 次 控制台打印一千条 “我爱编程，变成使我快乐！” 反复的执行某一段程序 Java 三种循环while 循环 while 循环语句和选择结构if语句有些相似，都是根据条件判断来决定是否执行大括号内的执行语句。区别在于，while 语句会反复地进行条件判断，只要条件成立，{ } 内的执行语句就会执行，直到条件不成立，while 循环结束 1234while (循环条件) &#123; 执行语句； ......&#125; 在上面的语法结构中，{ } 中的执行语句被称作循环体，循环体是否执行取决于循环条件。当循环条件为 true 时，循环体就会执行。循环体执行完毕时会继续判断循环条件，如条件仍为 true 则会继续执行，直到循环条件为 false 时，整个循环过程才会结束. 打印 1 ~ 10 12345678910public class Demo &#123; public static void main(String[] args) &#123; int x = 1;//初始化变量x 赋值1 while (x &lt;= 10) &#123;//循环条件 //满足条件时 System.out.println(&quot;x = &quot; + x); x++;//x 进行自增 &#125; &#125;&#125; 在上述代码中，x 初始值为 1，在满足循环条件 x &lt;= 10 的情况下，循环体会重复执行，打印 x 的值并让 x 进行自增。因此打印结果中 x 的值分别为 1、2、3、4 ……。大家要注意的是，代码x++ 用于在每次循环时改变 x 的值，从而达到最终改变循环条件的目的。如果没有这行代码，整个循环会进入无限循环的状态，永远不会结束。 for 循环 for循环语句是最常用的循环语句，一般用在循环次数已知的情况下。for循环语句的语法格式如下 1234for (初始化表达式; 循环条件; 操作表达式) &#123; 执行语句; ......&#125; 在上面的语法结构中，for 关键字后面 ( ) 中包括了三部分内容：初始化表达式、循环条件和操作表达式，它们之间用 “;” 分隔，{ } 中的执行语句为循环体 接下来分别用①表示初始化表达式、②表示循环条件、③表示操作表达式、④表示循环体，通过序号来具体分析for循环的执行流程。具体如下: 12345678for (1;2;4) &#123; 3&#125;第一步，执行1第二步，执行2，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步第三步，执行3第四步，执行4，然后重复执行2 - 3 - 4 - 2 - 3 - 4当 2 不满足时,退出循环 接下来通过一个案例对自然数1~4进行求和，如下所示 12345678910public class Demo6 &#123; public static void main(String[] args) &#123; //定义一个sum变量求和 int sum = 0; for(int i = 1;i &lt;= 4;i++)&#123; sum += i; &#125; System.out.println(&quot;sum = &quot; + sum);//10 &#125;&#125; 上述代码中，变量 i 的初始值为 1，在判断条件 i&lt;=4 为 true 的情况下，会执行循环体sum+=i，执行完毕后，会执行操作表达式 i++，i的值变为 2，然后继续进行条件判断，开始下一次循环，直到 i=5 时，条件 i&lt;=4 为 false，结束循环，执行 for 循环后面的代码，打印 “sum=10” 循环次数 sum i 第一次 1 1 第二次 3 2 第三次 6 3 第四次 10 4 do … while do … while 循环语句和 while 循环语句功能类似，其语法结构如下 1234do &#123; 执行语句; ......&#125; while (循环条件); 在上面的语法结构中，关键字 do 后面 { } 中的执行语句是循环体。do … while 循环语句将循环条件放在了循环体的后面。这也就意味着，循环体会无条件执行一次，然后再根据循环条件来决定是否继续执行 接下来使用 do … while 循环语句来实现打印 1~4 之间的自然数 123456public class Demo7 &#123; int x = 1;//初始化变量x,赋值为1 do &#123; System.out.println(&quot;x = &quot; + x); &#125; while (x &lt;= 4);&#125; do … while循环，先执行一次再去判断，无论如何都会执行一次 练习: 猜数字游戏 无限循环 while 1while(true)&#123; &#125; for 1for (;;) &#123; &#125; 嵌套循环 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do…while、for 循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的在 for 循环中嵌套 for 循环，格式如下： 1234567for ( 初始化表达式; 循环条件; 操作表达式) &#123; ...... for ( 初始化表达式; 循环条件; 操作表达式) &#123; ...... &#125; ......&#125; 接下来通过一个练习，来实现使用“*”打印直角三角形，如下所示 12345678910public class Demo8 &#123; public static void main(String[] args) &#123; for ( int i = 1; i &lt;= 4;i++ ) &#123; //外层循环 for (int j = 1;j&lt;=i ;j++) &#123; //内层循环 System.out.print(&quot;*&quot;);//打印不换行，println这个是打印换行 &#125; System.out.println(); &#125; &#125;&#125; 跳转语句break 在 switch 条件语句和循环语句中都可以使用 break 语句。当它出现在 switch 条件语句中时，作用是终止某个 case 并跳出 switch 结构。当它出现在循环语句中，作用是跳出循环语句，执行后面的代码 123456789101112public class Demo9 &#123; public static void main(String[] args) &#123; int x = 1; // 定义变量x，初始值为1 while (x &lt;= 4) &#123; // 循环条件 System.out.println(&quot;x = &quot; + x); // 条件成立，打印x的值 if (x == 3) &#123; break; &#125; x++; // x进行自增 &#125; &#125;&#125; 标记1234567891011121314public class BreakDemo &#123; public static void main(String[] args) &#123; int i, j; // 定义两个循环变量 AAA: for (i = 1; i &lt;= 9; i++) &#123; // 外层循环 for (j = 1; j &lt;= i; j++) &#123; // 内层循环 if (i &gt; 4) &#123; // 判断i的值是否大于4 break AAA; // 跳出外层循环 &#125; System.out.print(&quot;*&quot;); // 打印* &#125; System.out.print(&quot;\n&quot;); // 换行 &#125; &#125;&#125; continue continue语句用在循环语句中，它的作用是终止本次循环，执行下一次循环 123456789101112public class ContinueDemo &#123; public static void main(String[] args) &#123; int sum = 0; // 定义变量sum，用于记住和 for (int i = 1; i &lt;= 100; i++) &#123; if (i % 2 == 0) &#123; // i是一个偶数，不累加 continue; // 结束本次循环 &#125; sum += i; // 实现sum和i的累加 &#125; System.out.println(&quot;sum = &quot; + sum); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java循环结构]]></title>
    <url>%2F2012%2F09%2F12%2FJavaSE%2F04.Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F03.Java%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[循环结构 什么是循环 ？ 给班上学生打印试卷，打印机循环了 n 次 控制台打印一千条 “我爱编程，变成使我快乐！” 反复的执行某一段程序 Java 三种循环while 循环 while 循环语句和选择结构if语句有些相似，都是根据条件判断来决定是否执行大括号内的执行语句。区别在于，while 语句会反复地进行条件判断，只要条件成立，{ } 内的执行语句就会执行，直到条件不成立，while 循环结束 1234while (循环条件) &#123; 执行语句； ......&#125; 在上面的语法结构中，{ } 中的执行语句被称作循环体，循环体是否执行取决于循环条件。当循环条件为 true 时，循环体就会执行。循环体执行完毕时会继续判断循环条件，如条件仍为 true 则会继续执行，直到循环条件为 false 时，整个循环过程才会结束. 打印 1 ~ 10 12345678910public class Demo &#123; public static void main(String[] args) &#123; int x = 1;//初始化变量x 赋值1 while (x &lt;= 10) &#123;//循环条件 //满足条件时 System.out.println(&quot;x = &quot; + x); x++;//x 进行自增 &#125; &#125;&#125; 在上述代码中，x 初始值为 1，在满足循环条件 x &lt;= 10 的情况下，循环体会重复执行，打印 x 的值并让 x 进行自增。因此打印结果中 x 的值分别为 1、2、3、4 ……。大家要注意的是，代码x++ 用于在每次循环时改变 x 的值，从而达到最终改变循环条件的目的。如果没有这行代码，整个循环会进入无限循环的状态，永远不会结束。 for 循环 for循环语句是最常用的循环语句，一般用在循环次数已知的情况下。for循环语句的语法格式如下 1234for (初始化表达式; 循环条件; 操作表达式) &#123; 执行语句; ......&#125; 在上面的语法结构中，for 关键字后面 ( ) 中包括了三部分内容：初始化表达式、循环条件和操作表达式，它们之间用 “;” 分隔，{ } 中的执行语句为循环体 接下来分别用①表示初始化表达式、②表示循环条件、③表示操作表达式、④表示循环体，通过序号来具体分析for循环的执行流程。具体如下: 12345678for (1;2;4) &#123; 3&#125;第一步，执行1第二步，执行2，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步第三步，执行3第四步，执行4，然后重复执行2 - 3 - 4 - 2 - 3 - 4当 2 不满足时,退出循环 接下来通过一个案例对自然数1~4进行求和，如下所示 12345678910public class Demo6 &#123; public static void main(String[] args) &#123; //定义一个sum变量求和 int sum = 0; for(int i = 1;i &lt;= 4;i++)&#123; sum += i; &#125; System.out.println(&quot;sum = &quot; + sum);//10 &#125;&#125; 上述代码中，变量 i 的初始值为 1，在判断条件 i&lt;=4 为 true 的情况下，会执行循环体sum+=i，执行完毕后，会执行操作表达式 i++，i的值变为 2，然后继续进行条件判断，开始下一次循环，直到 i=5 时，条件 i&lt;=4 为 false，结束循环，执行 for 循环后面的代码，打印 “sum=10” 循环次数 sum i 第一次 1 1 第二次 3 2 第三次 6 3 第四次 10 4 do … while do … while 循环语句和 while 循环语句功能类似，其语法结构如下 1234do &#123; 执行语句; ......&#125; while (循环条件); 在上面的语法结构中，关键字 do 后面 { } 中的执行语句是循环体。do … while 循环语句将循环条件放在了循环体的后面。这也就意味着，循环体会无条件执行一次，然后再根据循环条件来决定是否继续执行 接下来使用 do … while 循环语句来实现打印 1~4 之间的自然数 123456public class Demo7 &#123; int x = 1;//初始化变量x,赋值为1 do &#123; System.out.println(&quot;x = &quot; + x); &#125; while (x &lt;= 4);&#125; do … while循环，先执行一次再去判断，无论如何都会执行一次 练习: 猜数字游戏 无限循环 while 1while(true)&#123; &#125; for 1for (;;) &#123; &#125; 嵌套循环 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do…while、for 循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的在 for 循环中嵌套 for 循环，格式如下： 1234567for ( 初始化表达式; 循环条件; 操作表达式) &#123; ...... for ( 初始化表达式; 循环条件; 操作表达式) &#123; ...... &#125; ......&#125; 接下来通过一个练习，来实现使用“*”打印直角三角形，如下所示 12345678910public class Demo8 &#123; public static void main(String[] args) &#123; for ( int i = 1; i &lt;= 4;i++ ) &#123; //外层循环 for (int j = 1;j&lt;=i ;j++) &#123; //内层循环 System.out.print(&quot;*&quot;);//打印不换行，println这个是打印换行 &#125; System.out.println(); &#125; &#125;&#125; 跳转语句break 在 switch 条件语句和循环语句中都可以使用 break 语句。当它出现在 switch 条件语句中时，作用是终止某个 case 并跳出 switch 结构。当它出现在循环语句中，作用是跳出循环语句，执行后面的代码 123456789101112public class Demo9 &#123; public static void main(String[] args) &#123; int x = 1; // 定义变量x，初始值为1 while (x &lt;= 4) &#123; // 循环条件 System.out.println(&quot;x = &quot; + x); // 条件成立，打印x的值 if (x == 3) &#123; break; &#125; x++; // x进行自增 &#125; &#125;&#125; 标记1234567891011121314public class BreakDemo &#123; public static void main(String[] args) &#123; int i, j; // 定义两个循环变量 AAA: for (i = 1; i &lt;= 9; i++) &#123; // 外层循环 for (j = 1; j &lt;= i; j++) &#123; // 内层循环 if (i &gt; 4) &#123; // 判断i的值是否大于4 break AAA; // 跳出外层循环 &#125; System.out.print(&quot;*&quot;); // 打印* &#125; System.out.print(&quot;\n&quot;); // 换行 &#125; &#125;&#125; continue continue语句用在循环语句中，它的作用是终止本次循环，执行下一次循环 123456789101112public class ContinueDemo &#123; public static void main(String[] args) &#123; int sum = 0; // 定义变量sum，用于记住和 for (int i = 1; i &lt;= 100; i++) &#123; if (i % 2 == 0) &#123; // i是一个偶数，不累加 continue; // 结束本次循环 &#125; sum += i; // 实现sum和i的累加 &#125; System.out.println(&quot;sum = &quot; + sum); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java选择结构]]></title>
    <url>%2F2012%2F09%2F11%2FJavaSE%2F04.Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F02.Java%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Java 选择结构 switch … case 语法是 Java 里面的选择结构 123456789101112switch (值) &#123; case 常量1 : 要执行代码; break; case 常量2 : 要执行代码; break; ... default : 要执行代码; break;&#125; switch 的值可以是 byte、short、int、char、String(1.7)、enum(1.5) 1234567891011121314switch (1) &#123; case 1 : System.out.println(&quot;礼拜一上班&quot;); break; case 2 : System.out.println(&quot;礼拜二出去游玩&quot;); break; case 3 : System.out.println(&quot;礼拜三搬砖&quot;); break; default : System.out.println(&quot;自嗨&quot;); break;&#125; switch 在什么情况下终止: 两种情况: 遇到 break 遇到 switch 的右大括号 case 后面 只可以跟常量 case 后面 的常量值是不允许重复出现 default 可以省略,也可以出现在 switch 语句的任意位置 default 里的代码,一定是在所有的 case 都不匹配的情况下才会去执行!!!]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java分支结构]]></title>
    <url>%2F2012%2F09%2F10%2FJavaSE%2F04.Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F01.Java%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Java 分支结构 接下来要学习的 if 条件语句分为三种语法格式，每一种格式都有它自身的特点，下面我们分别进行介绍 if if 语句是指如果满足某种条件，就进行某种处理。 1234eg: 汪半壁考 Java 考试， 如果考了 100 分 那么就给他唱歌 1 小时 在上面的伪代码中，“如果” 相当于 Java 中的关键字 if 考了 100 分是判断条件，需要用 ( ) 括起来，“唱歌 1 小时”是执行语句，需要放在 { } 中 123if (考了 100 分) &#123; 唱歌 1 小时&#125; 上面的例子就描述了 if 语句的用法，在 Java 中，if 语句的具体语法格式如下： 123if (条件语句) &#123; // 条件语句判断是一个布尔值，当值位 true 时，&#123; &#125; 里面的执行语句才会执行 执行语句；&#125; if 语句的执行流程图 12345678public class Demo1 &#123; public static void main(String[] args) &#123; int score = 100; if(score == 100)&#123; System.out.println(&quot;唱歌 1 小时&quot;); &#125; &#125;&#125; if … else if … else 语句是指如果满足某种条件，就进行某种处理，否则就进行另一种处理 123456789eg: 要判断一个正整数的奇偶，如果该数字能被 2 整除则是一个偶数，否则该数字就是一个奇数。if … else 语句具体语法格式如下 :if (条件语句) &#123; 执行语句1； ......&#125; else &#123; 执行语句2; ......&#125; 上述代码中，判断条件是一个布尔值。当判断条件为 true 时，if 后面 { } 中的执行语句 1 会执行。当判断条件为 false 时，else 后面 { } 中的执行语句 2 会执行。 12345678910public class Demo2 &#123; public static void main(String[] args) &#123; int num = 10; if (num % 2 == 0) &#123; System.out.println(&quot;num是一个偶数&quot;); &#125; else &#123; System.out.println(&quot;num是一个奇数&quot;); &#125; &#125;&#125; if … else if … else if … else if … else 语句用于对多个条件进行判断，进行多种不同的处理 1eg: 对一个学生的考试成绩进行等级的划分，如果分数大于80分等级为优，否则，如果分数大于70分等级为良，否则，如果分数大于60分等级为中，否则，等级为差. 1234567891011if (判断条件1) &#123; 执行语句1；&#125; else if (判断条件2) &#123; 执行语句2；&#125;......else if (判断语句n) &#123; 执行语句n;&#125; else &#123; 执行语句n+1;&#125; 上述格式中，判断条件是一个布尔值。当判断条件 1 为 true 时，if 后面 { } 中的执行语句 1 会执行。当判断条件 1 为 false 时，会继续执行判断条件 2，如果为 true 则执行语句 2，以此类推，如果所有的判断条件都为 false，则意味着所有条件均未满足，else 后面 { } 中的执行语句 n+1 会执行 1234567891011121314public class Demo3 &#123; public static void main(String[] args) &#123; int score = 75;//定义学生分数 if (score &gt; 80) &#123; System.out.println(&quot;优&quot;); &#125; else if (score &gt; 70) &#123; System.out.println(&quot;良&quot;); &#125; else if (score &gt; 60) &#123; System.out.println(&quot;刚刚好&quot;); &#125; else &#123; System.out.println(&quot;差&quot;); &#125; &#125;&#125; if 嵌套1234567891011121314public class Demo4 &#123; double height = 110; double weight = 1110; if (height &gt;= 110) &#123; System.out.println(&quot;你很优秀&quot;); if (weight &gt;= 1110) &#123; System.out.println(&quot;陈独秀，请坐！&quot;); &#125; else &#123; System.out.println(&quot;你还是好好学java吧!&quot;); &#125; &#125; else &#123; System.out.println(&quot;你需要更加完美!&quot;); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运算符]]></title>
    <url>%2F2012%2F09%2F09%2FJavaSE%2F03.Java%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%2F02.Java%20%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java 运算符算术运算符 运算符 运算规则 范例 结果 + 正号 +3 3 + 加 2+3 5 + 连接字符串 “中”+“国” “中国” - 负号 int a=3;-a -3 - 减 3-1 2 * 乘 2*3 6 / 除 5/2 2 % 取模 5%2 1 ++ 自增 int a=1;a++/++a 0 – 自减 int a=3;a–/–a 3 使用算术运算符是需要注意 加法运算符在连接字符串时要注意，只有直接与字符串相加才会转成字符串 12345public class Demo4&#123; public static void main(String[] args)&#123; System.out.println(&quot;中&quot; + &quot;国&quot;);//打印出中国 &#125;&#125; 除法“/”当两边为整数时，取整数部分，舍余数。当其中一边为浮点型时，按正常规则相除 12System.out.println(3/2);// 1System.out.println(3.0/2);//1.5 “%”取模(取余数)，小数取余没有意义。结果符号与被取余符号相同 12System.out.println(5%3);// 5 / 3 = 1 ... 2 所以结果时 2System.out.println(3%5);// 一个小的数对一个大的数取模，就等于它本身 3 算术运算符 ++ , –的使用 123456int a = 3;int b = 3;a++;b--;System.out.println(a);//4System.out.println(b);//2 上面的代码输出结果 a 的值为4，b 的值为2,这说明 a 与 b 的值在原有的基础上发生了改变，改变的值为1. ++运算符：会在原有值得基础上自增1 –运算符：会在原有值得基础上自减1 123456int a = 3;int b = 3;++a;--b;System.out.println(a);//4System.out.println(b);//2 上面的代码输出结果 a 的值为4，b 的值为2， 说明 ++,– 在单独使用并且不参与操作符时，不管在前还是在后结果是一样的。 接下来我们参与操作符 12345int a = 3;int b;b = a++ + 10;System.out.println(a);//4System.out.println(b);//13 上面代码的输出结果a值为4，b 值为13; 强调:当 ++,– 运算符后置时，先使用变量 a 原有值参与运算操作，运算操作完成后，变量a的值自增1或者自减1 再介绍下 ++，– 运算符前置时，参与运算操作的变化，我们来看一段代码 ： 12345int a = 3;int b;b = ++a + 10;System.out.println(a);//4System.out.println(b);//14 强调: ++，– 运算符前置时，先将变量 a 的值自增1或者自减1，然后使用更新后的新值参与运算操作 赋值运算符 运算符 运算规则 范例 结果 = 赋值 int a=2 2 += 加后赋值 int a=2，a+=2 4 -= 减后赋值 int a=2，a-=2 0 *= 乘后赋值 int a=2，a*=2 4 /= 整除后赋值 int a=2，a/=2 1 %= 取模后赋值 int a=2，a%=2 0 注意：诸如 += 这样形式的赋值运算符，会将结果自动强转成等号左边的数据类型。 1234567public class Demo5&#123; public static void main(String[] args) &#123; byte x = 10; x += 20;// 相当于 x = (byte)(x+20); System.out.println(x);// 30 &#125;&#125; 注意：赋值运算符左边必须是变量 上面的运算符作用：将等号左右两边计算，会将结果自动强转成等号左边的数据类型,再赋值给等号左边的 比较运算符 比较运算符，又叫关系运算符，它是用来判断两个操作数的大小关系及是否相等关系的，结果是布尔值true或者false 。 | 运算符 | 运算规则 | 范例 | 结果 | | ———- | ———— | ——– | ——– | | == | 相等于 | 4==3 | False | | != | 不等于 | 4!=3 | True | | &lt; | 小于 | 4 | 大于 | 4&gt;3 | True | | &lt;= | 小于等于 | 4&lt;=3 | False | | &gt;= | 大于等于 | 4&gt;=3 | True | 1234int a = 3;int b = 4;System.out.println( a=b );// 4System.out.println( a==b );// true 逻辑运算符 逻辑运算符，它是用于布尔值进行运算的，运算的最终结果为布尔值true或false | 运算符 | 运算规则 | 范例 | 结果 | | ———- | ———— | ————- | ——– | | &amp; | 与 | false&amp;true | False | | | | 或 | false|true | True | | ^ | 异或 | true^flase | True | | ! | 非 | !true | Flase | | &amp;&amp; | 短路与 | false&amp;&amp;true | False | | || | 短路或 | false||true | True | 123456boolean b = 100&gt;10;boolean b2 = false;System.out.println(b&amp;&amp;b2); // 打印结果为 falseSystem.out.println(b||b2); //打印结果为 trueSystem.out.println(!b2); //打印结果为 trueSystem.out.println(b &amp;&amp; 100&gt;10); //打印结果为 true,本行结果的计算方式稍后讲解运算符优先级时解答 三元运算符(三目运算) 格式 1数据类型 变量名 = (条件表达式)？表达式1：表达式2; 三元运算符运算规则 先判断条件表达式的值，若为true，运算结果为表达式1；若为false，运算结果为表达式2 123456789101112131415方式一： System.out.println( 3&gt;2 ? “正确” : “错误” ); // 三元运算符运算后的结果为true，运算结果为表达式1的值“正确”，然后将结果“正确”，在控制台输出打印方式二： int a = 3; int b = 4; String result = (a==b) ? “相等” : “不相等”; System.out.println(result);//三元运算符运算后的结果为false，运算结果为表达式2的值“不相等”，然后将结果赋值给了变量result方式三： int n = (3&gt;2 &amp;&amp; 4&gt;6) ? 100 : 200; System.out.println(n); //三元运算符运算后的结果为false，运算结果为表达式2的值200,然后将结果200赋值给了变量n 进制转换 二进制 八进制 十六进制]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java标识符与基本数据类型]]></title>
    <url>%2F2012%2F09%2F08%2FJavaSE%2F03.Java%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%2F01.Java%20%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java 标识符与基本数据类型Java 注释注释的作用 解释代码 注释的种类单行注释1234public static void main(String[] args) &#123; // 年龄 int age = 18;&#125; 多行注释123456789public static void main(String[] args) &#123; /* public 公共的 static 静态的 System 系统 out 输出 */ System.out.println(&quot;Hello World&quot;);&#125; 文档注释123456/** 这是JVM的入口，我们一般称之为主函数*/public static void main(String[] args) &#123; System.out.println(&quot;道&quot;);&#125; Java 关键字 Java 语言赋予特殊含义的单词 Java 关键字预览 Java 标识符 标识符就是名称的意思，所有的名字都统称为标识符。 Java 中经常要定义类、方法、变量等，在定义的时候需要给它们取名字，这些名字就是标识符 标识符的组成 字母 数字 下划线 _ 美元符 $ 不能以数字开头 不能是关键字 遵循驼峰法则 见名知意1标识符可以是中文吗? 基本数据类型什么是数据 eg : LOL 玩家就是数据、呈现给玩家的信息也是数据，数据无处不在。 数据类型 指包含由各特殊的事物或现象抽出来的共通点的抽象概念 1eg : 人名是英文的还是中文的 ？ Java 中的数据类型 Java 是强类型语言，对每一种数据都有对应的数据类型 基本数据类型是 Java 语言中内置的类型。整数类型、小数类型、字符类型、布尔类型这四类是最基础的类型 引用数据类型是强大的数据类型，它是基于数据类型创建的。 基本数据类型的取值范围 char 字符型 ，2个字节 ，用单引号表示 ‘ ‘ ,刚好容纳一个汉字，注意：里面只能放一个 boolean 布尔型 ，一个字节 0000 0001 最低为表示，取值(布尔值) ：true(真) 和 false(假) E : 123E5 = 123 10^5 = 12300000 , 123E-5 = 123 10^-5 = 0.0123 e : 自然常数，约 2.718281828 Java 的常量与变量常量 常量就是不变的数据量，例如666就是常量。任何数据量都有其类型，那么这个666又是什么类型呢？没错，就是整数类型!!! 整数类型: 18 、666 、1888等 小数类型: 1.8 、6.66、3.1415926等 字符类型: ‘a’ 、’A’、’0’ 、‘中’等。（注意: 字符型是用 ‘ ‘ 包裹，并且里面只能写一个） 布尔类型: true(真)、false(假) 字符串类型: “我爱Java”、“HelloWorld!!!”、“我爱编程，编程使我快乐!” 变量变量的概述 变量是内存中装数据的小容器，你只能用它来存数据和取数据。 计算机的存储单元 变量是内存中的小容器，用来存储数据。那么计算机内存是怎么存储数据的呢？无论是内存还是硬盘，计算机的存储设备最小信息单元叫 “位( bit )”, 我们又称之为”比特位“，通常用小写字母b表示。而计算机最小的存储单元叫”字节(byte)”,通常用大写字母B表示，1个字节由8个位组成。 操作系统分派的最小存储空间是1个字节，而不是1位。 12345678910111B(字节) = 8 bit1KB = 1024B1MB = 1024KB1GB = 1024MB1TB = 1024GB1PB = 1024TB 定义变量 语法 数据类型 变量名 = 数据值; 局部变量 我们使用变量的时候要注意，要满足变量的使用规则我们才能使用 定义变量时可以先不赋值，使用时在赋值。不赋值不能使用 1234567public class Demo2&#123; public static void main(String[] args)&#123; int x;//先定义一个变量x x = 20;//把20赋值给这个x System.out.println(x);//这一步是打印x，这也就是在这一行用到了x &#125;&#125; 变量不可重复定义 123456public class Demo3&#123; public static void main(String[] args)&#123; int i = 10; double i = 1.5;// 这里 i 就重复了，会发生编译错误 &#125;&#125; 数据类型转换显示转换 小范围数据类型 变量 = (小范围数据类型 变量)大范围数据类型; int n = (int)6.7; 隐式转换 大范围数据类型 变量 = 小范围的数据类型; double d = 10000;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生中的第一个程序]]></title>
    <url>%2F2012%2F09%2F07%2FJavaSE%2F02.Java%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95%2F03.%E4%BA%BA%E7%94%9F%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[人生中的第一个程序HelloWorld创建Java文件 记事本 .txt 结尾 , 图片 .png|.jpeg|.jpg结尾 , 而Java则是 .java 结尾 HelloWorld.java 编写文件12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;HelloWorld！！！&quot;); &#125;&#125; 运行Java程序所具备的条件 JDK （Java Development Kit）- Java开发工具包 JRE （Java Runtime Enviroment）- Java运行环境 JVM （Java Virtual Machine）- Java虚拟机执行Java程序 想要打印HelloWorld分编译与运行两个过程 我们写的程序计算机不认识，所以需要编译成计算机认识的程序 运行，我们运行的是编译之后的 .class 结尾的二进制字节码文件]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA下载安装]]></title>
    <url>%2F2012%2F09%2F06%2FJavaSE%2F02.Java%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95%2F02.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7IDEA%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[IDEA 下载与安装 官网 下载步骤 安装 无脑点击右下角按钮 修改hosts文件与获取注册码 注册码获取网址 获取注册码 IDEA 的使用创建Java项目 修改设置字符集编码 File -&gt; Settings 字体大小 如还需修改其它,请找度娘.]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK下载与安装]]></title>
    <url>%2F2012%2F09%2F05%2FJavaSE%2F02.Java%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B5%8B%E8%AF%95%2F01.JDK%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[JDK下载与安装JDK下载步骤 Java已经被Oracle收购，进入Oracle官网下载 安装之后目录 配置环境变量 测试是否安装成功]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有道云做笔记]]></title>
    <url>%2F2012%2F09%2F04%2FJavaSE%2F01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F04.%E6%9C%89%E9%81%93%E4%BA%91%E5%81%9A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[有道云做笔记笔记的大概内容 标题 文字 图片 链接 表格 标题 使用 # 符号 个数越多级别越低 文字 文字用来描述知识点 可以采用table键来缩进、中划线操作列表(-) 图片 采用 链接百度 表格 使用工具 MD表格生成]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用DOS命令]]></title>
    <url>%2F2012%2F09%2F03%2FJavaSE%2F01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F03.%E5%B8%B8%E7%94%A8DOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用DOS命令开始操作打开cmd 点击左下角windows图标(windows系统开机图标) - 点击运行 - 输入cmd - 敲回车 按windows(键盘上面有着windows图标的按键) + R - 输入cmd - 敲回车 进入盘符 这里以E盘为例，输入 E: 查看E盘下的目录及文件 dir(directory) 创建文件夹 md(make directory) 文件夹名,例如创建名为 QF的文件夹，输入 md QF 删除文件夹 rd(remove directory) 文件夹名，例如删除名为QF的文件夹 输入 rd QF 创建文件 创建文件时输入内容 echo Hello&gt;b.txt 查看文件信息 type 文件名.后缀 type Hello.txt 接着写(不覆盖) echo Java&gt;&gt;Hello.txt 删除多级文件 例如 a/b/c rmdir /s/q a /s 代表所有的子目录文件 /q 代表是否提示Yes/No 返回上一级 cd .. 返回根目录 cd / 查看ip地址与子网掩码 ipconfig 1234红花 ip 10.3.134.29绿叶 子网掩码 255.255.255.0 (255 代表固定,0代表任意) 检测能否上网 ping www.baidu.com -t]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语言的发展史]]></title>
    <url>%2F2012%2F09%2F02%2FJavaSE%2F01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F02.Java%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[Java语言的发展史Java 可以做什么 Java之父 - 詹姆斯·高斯林 Java 是sun(Stanford Univesity Network)公司开发的一门编程语言1995年5月23日java 1.0版本正式在SunWorld大会上发布,2009年被oracle(甲骨文)收购，其实编程语言就是用来编写软件的。 版本 描述 1991年1月 Sun公司成立了Green项目小组，专攻智能家电的嵌入式控制系统 1991年2月 放弃C++，开发新语言，命名为“Oak” 1991年6月 JamesGosling开发了Oak的解释器 1992年1月 Green完成了Green操作系统、Oak语言、类库等开发 1992年11月 Green计划转化成“FirstPerson”，一个Sun公司的全资母公司 1993年2月 获得时代华纳的电视机顶盒交互系统的订单，于是开发的重心从家庭消费电子产品转到了电视盒机顶盒的相关平台上。 1994年6月 FirstPerson公司倒闭，员工都合并到Sun公司。Liveoak计划启动了，目标是使用Oak语言设计出一个操作系统。 1994年7月 第一个Java语言的Web浏览器WebRunner（后来改名为HotJava），Oak更名为Java。 1994年10月 VanHoff编写的Java编译器用于Java语言 1995年3月 在SunWorld大会，Sun公司正式介绍了Java和HotJava。 1996年1月 JDK1.0发布 1997年2月 J2SE1.1发布 1998年12月 J2SE1.2发布 1999年6月 发布Java的三个版本：J2SE、J2EE、J2ME 2000年5月 J2SE1.3发布 2001年9月 J2EE1.3发布 2002年2月 J2SE1.4发布 2004年9月 J2SE1.5发布，将J2SE1.5改名JavaSE5.0 2005年6月 JavaSE6.0发布，J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME 2006年12月 JRE6.0发布 2006年12月 JavaSE6发布 2009年12月 JavaEE6发布 2009年4月 Oracle收购Sun 2011年7月 JavaSE7发布 2014年3月 JavaSE8发布 Java9、Java10、Java11 Java 三大版本JavaSE Java Platform Standard Edition Java平台标准版（Java基础） JavaME Java Platform Micro Edition Java平台微版，用于嵌入式开发（机顶盒、打印机等） JavaEE Java Platfrom Enterprise Edition Java企业版（天猫、斗鱼等） Java语言的特性不难 大家都知道Java在行中名C++-,Java丢弃了C++中很难理解的部分，如操作符重载、多继承、自动的强制类型转换 特别是Java语言不使用指针，而且提供了自动的垃圾回收机制，是的程序员不必为内存管理而担忧。 面向对象 一切皆对象 分布式 Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等 健壮性 Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择 安全性 Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如：安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查。 可移植性 跨平台： JVM 作用用来解释执行字节码文件根据不同的平台进行不同的解释执行，从而可以达到跨平台作用，C++生成直接可以运行的机器码文件。java素有 “一次编译，到处运行” 多线程 多线程可以帮你编写出cpu最大利用率的高效程序(CPU的抢占式调度)，使得空闲时间保持最低(提高效率)]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机语言的发展史]]></title>
    <url>%2F2012%2F09%2F01%2FJavaSE%2F01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[计算机语言的发展史什么是计算机语言计算机语言(Computer Language) 指用于“人” 与 “计算机”之间通讯的语言。计算机语言是人与计算机之间传递信息的媒介。计算机系统最大特征是“指令” 通过一种语言传达给机器。为了使计算机进行各种工作，就需要有一套用以编写计算机程序的数字、字符、和语法规则，由这些字符和语法规则组成计算机各种指令。这就是计算机能接受的语言(计算机语言)。 计算机语言的迭代 机器语言使用0和1的二进制码，但是在做计算的时候，比如128 ，我们要写为10000000，其它的数以此类推，如果再做计算就会变的非常的不尽人意，如果想要显示HelloWorld，可能要几百个01的组合，可读性差，难以查错！(智商不够用) 汇编语言为了编程的方便，以及解决更加复杂的问题，程序员开始用英文的缩写的助记符来表示基本的计算机操作。这些助记符就构成了汇编语言的基础。计算机在芯片技术以&quot;摩尔定律&quot;的速度发展。计算机的性能越来越强，可以处理更多的事情了。这个时候发现汇编语言无法应付了。于是高级语言出来了... 高级编程语言在与计算机的不断交流中，人们对计算机程序的移植性需求不断提高，此时急需要一种不依赖于特定型号的计算机的语言，用这种语言编写的程序能在在各种平台都正常运行。从最初的语言诞生至今，已经相继出现了几百种语言。高级语言的发展也从最初的结构化语言发展成为面向过程语言设计和面向对象语言设计。面向过程语言设计的代表有：C语言，Fortran，COBOL，ADA，而面向对象语言设计的代表则为：java,c++,c#等 C语言，是高级语言的鼻祖。在美国贝尔实验室发明的。计算机的晶体管也是贝尔实验室搞出来的 C++也是贝尔实验室发明的 Fortran，上世纪50年代，IBM推出。IBM公司诞生于1900年前后，中国还是清朝末年 Cobol，在金融和银行里仍然在用 ADA，美国国防部推出的，用于控制的，如阿波罗登月 Java，SUN公司推出 等等……]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
</search>
