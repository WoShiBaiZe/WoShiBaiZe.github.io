<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Cloud Netflix 简介]]></title>
    <url>%2F2013%2F05%2F11%2FSpring-Cloud%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Spring Cloud一. Eureka简介​ Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。 ​ Eureka包含两个组件：Eureka Server和Eureka Client。 ​ Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。 ​ Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也就别一个内置的、使用轮询(round-robin)负载算法的负载均衡。 1.1 Eureka Server的搭建1.1.1 依赖配置123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;!-- 在写版本的时候，不能像官网那样写 Greenwich SR2， --&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 1.1.2 application.yml配置12345678eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:$&#123;server.port&#125;/eureka/ 1.1.3 代码1234567@SpringBootApplication@EnableEurekaServer //启用Eureka的服务public class EurekaServerApplication &#123; public static void main( String[] args ) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 1.2 服务提供方1.2.1 依赖配置1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 1.2.2 application.yml配置12345678eureka: instance: prefer-ip-address: true client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://localhost:8761/eureka/ 1.2.3 代码编写1234567@SpringBootApplication@EnableEurekaClient //启动Eureka客户端public class ShopProviderApplication &#123; public static void main( String[] args)&#123; SpringApplication.run(ShopProviderApplication.class, args); &#125;&#125; 1.3 服务消费方1.3.1 application.yml配置12345spring: application: name: shop-consumerserver: port: 8080 1.3.2 代码的编写启动类代码： 123456@SpringBootApplicationpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 调用类代码： 12345678910111213141516171819@RestController@RequestMapping(value=&quot;/user&quot;)public class UserController &#123; @Resource private RestTemplate restTemplate; @RequestMapping(value = &quot;/ticket/&#123;id&#125;&quot;, method = RequestMethod.GET) public Object getTicket(@PathVariable(value = &quot;id&quot;) Integer id) &#123; Person person = new Person(); person.setId(23); person.setName(&quot;张三三&quot;); List&lt;Ticket&gt; ticketList = restTemplate.postForEntity(&quot;http://localhost:666/ticket&quot;, person, List.class).getBody(); return ticketList; &#125;&#125; RestTemplate的注入： 123456789@Configurationpublic class BeanConfig &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 二. Ribbon​ Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。其主要功能是提供客户端的负载均衡算法，并提供了完善的配置项如连接超时，重试等。简单的说，就是配置文件中列出Load Balancer后面所有的机器，Ribbon会自动的基于某种规则(如简单轮询，随机连接等)去连接这些机器，当然我们也可以使用Ribbon自定义负载均衡算法。Ribbon的实现需要使用的Eureka，消费方需要在Eureka注册中心找到要调用的服务的相关信息。 2.1 配置依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 实现负载均衡​ Ribbon只是一个客户端的负载均衡器工具，实现起来非常的简单，我们只需要在注入RestTemplate的bean上加上@LoadBalanced就可以了。如下： 123456789@Configurationpublic class BeanConfig &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 2.3 启动类配置1234567@SpringBootApplication@EnableEurekaClientpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 2.4 服务的调用​ 在服务的消费方，不再采用主机名+端口的形式进行调用，而是直接采用服务名的方式进行调用。 123456789101112131415161718@RestController@RequestMapping(value=&quot;/user&quot;)public class UserController &#123; @Resource private RestTemplate restTemplate; @RequestMapping(value = &quot;/ticket/&#123;id&#125;&quot;, method = RequestMethod.GET) public Object getTicket(@PathVariable(value = &quot;id&quot;) Integer id) &#123; Person person = new Person(); person.setId(23); person.setName(&quot;张三三&quot;); // shop-provider 是服务名，不需要使用ip:端口的形式进行调用 List&lt;Ticket&gt; ticketList = restTemplate.getForObject(&quot;http://shop-provier/ticket&quot;, List.class, person); return ticketList; &#125;&#125; 2.5 负载均衡策略​ Ribbon提供了一个很重要的接口叫做IRule，其中定义了很多的负载均衡策略，默认的是轮询的方式，以下是Ribbon的负载均衡策略： 类名 描述 RoundRobinRule 轮询 RandomRule 随机挑选 RetryRule 按照轮询的方式去调用服务，如果其中某个服务不可用，但是还是会尝试几次，如果尝试过几次都没有成功，那么就不在调用该服务，会轮询调用其他的可用服务。 AvailabilityFilteringRule 会先过滤掉因为多次访问不可达和并发超过阈值的服务，然后轮询调用其他的服务 WeightedResponseTimeRule 根据平均响应时间计算权重，响应越快权重越大，越容易被选中。服务刚重启的时候，还未统计出权重会按照轮询的方式；当统计信息足够的时候，就会按照权重信息访问 ZoneAvoidanceRule 判断server所在的区域性能和可用性选择服务器 BestAvailableRule 会过滤掉多次访问都不可达的服务，然后选择并发量最小的服务进行调用，默认方式 ​ 改变Ribbon的负责均衡策略： 1234@Beanpublic IRule getRule() &#123; return new RandomRule();&#125; 2.6 自定义负载均衡策略​ 我们自定义的负载均衡策略需要继承AbstractLoadBalancerRule这个类，然后重写choose方法，然后将其注入到容器中，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Customize_Rule extends AbstractLoadBalancerRule &#123; private static Logger logger = LoggerFactory.getLogger(Customize_Rule.class); private int currentIndex = 0; //当前调用的索引 private int num = 1; //次数 private int limit = 5; /** * 初始化工作 * @param iClientConfig */ @Override public void initWithNiwsConfig(IClientConfig iClientConfig) &#123; &#125; @Override public Server choose(Object key) &#123; ILoadBalancer balancer = getLoadBalancer(); return choose(balancer, key); &#125; private Server choose(ILoadBalancer balancer, Object key) &#123; Server server = null; while(null == server) &#123; //获取所有可用的服务 List&lt;Server&gt; reachableServers = balancer.getReachableServers(); if (0 == reachableServers.size()) &#123; logger.error(&quot;没有可用的服务&quot;); return null; //退出while循环 &#125; int total = reachableServers.size(); //可用服务的数量 synchronized (this) &#123; /** * 有种极端情况，当我们在使用最后一个服务的时候，其他的服务都不可用，可能导致索引越界异常 */ if (currentIndex + 1 &gt; total) &#123; currentIndex = 0; server = reachableServers.get(currentIndex); //获取第一个服务 num = 0; num++; &#125; else &#123; if(limit == num) &#123; currentIndex++; num = 0; if(currentIndex == total) &#123; currentIndex=0; server = reachableServers.get(currentIndex); //获取第一个服务 num++; &#125;else&#123; server = reachableServers.get(currentIndex); num++; &#125; &#125;else &#123; server = reachableServers.get(currentIndex); num++; &#125; &#125; &#125; &#125; return server; &#125;&#125; ​ 将其注入到容器中，如下所示： 1234@Beanpublic IRule getRule() &#123; return new Customize_Rule();&#125; 三. Feign负载均衡​ feign是基于Ribbon的另外一个负载均衡的客户端框架，只需要在接口上定义要调用的服务名即可，使用起来非常的简单。 3.1 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 3.2 启动类的配置 ​ 需要在启动类上加上@EnableFeignClients注解即可开启feign，如下所示： 12345678@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 3.3 服务接口配置与调用方式 1234567@Service@FeignClient(name = &quot;shop-provier&quot;)public interface TicketService &#123; @RequestMapping(value = &quot;ticket&quot;, method = RequestMethod.GET) public List&lt;Ticket&gt; getAllTicket(Person person);&#125; 四. Hystrix断路器​ 分布式系统中一个微服务需要依赖于很多的其他的服务，那么服务就会不可避免的失败。例如A服务依赖于B、C、D等很多的服务，当B服务不可用的时候，会一直阻塞或者异常，更不会去调用C服务和D服务。同时假设有其他的服务也依赖于B服务，也会碰到同样的问题，这就及有可能导致雪崩效应。 ​ 如下案例：一个用户通过通过web容器访问应用，他要先后调用A、H、I、P四个模块，一切看着都很美好。 ​ 由于某些原因，导致I服务不可用，与此同时我们没有快速处理，会导致该用户一直处于阻塞状态。 ​ 当其他用户做同样的请求，也会面临着同样的问题，tomcat支持的最大并发数是有限的，资源都是有限的，将整个服务器拖垮都是有可能的。 ​ Hystrix是一个用于分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖会不可避免的调用失败，例如超时，异常等，Hystrix能保证在一个依赖出现问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。 ​ 断路器本身是一种开关装置，当某个服务单元发生故障后，通过断路器的故障监控（类似于保险丝），向调用者返回符合预期的，可处理的备选响应，而不是长时间的等待或者抛出无法处理的异常，这样就保证了服务调用的线程不会被长时间，不必要的占用，从而避免故障在分布式系统中的蔓延，乃至雪崩。 ​ Hystrix在网络依赖服务出现高延迟或者失败时，为系统提供保护和控制;可以进行快速失败，缩短延迟等待时间；提供失败回退（Fallback）和相对优雅的服务降级机制；提供有效的服务容错监控、报警和运维控制手段。 4.1 配置依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 4.2 application.yml配置123feign: hystrix: enabled: true #开启feign的熔断机制 4.3 启动类配置​ 只需要在启动类上加上@EnableCircuitBreaker注解即可，如下所示： 123456789@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableCircuitBreakerpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 4.4 接口的编写​ 在接口的@FeignClient注解中加入fallback参数，该参数为Class类型的对象，我们将该接口实现，作为服务降级后的快速响应，然后提供给fallback作为参数的值，如下所示： 1234567@Service@FeignClient(name = &quot;shop-provier&quot;, fallback = TicketServiceFallback.class)public interface TicketService &#123; @RequestMapping(value = &quot;ticket&quot;, method = RequestMethod.GET) public List&lt;Ticket&gt; getAllTicket(Person person);&#125; TicketServiceFallback是对TicketService这个接口的实现，用于在服务降级后的一个快速响应，代码如下： 12345678@Componentpublic class TicketServiceFallback implements TicketService &#123; @Override public List&lt;Ticket&gt; getAllTicket(Person person) &#123; return Arrays.asList(new Ticket()); &#125;&#125; 4.5 Hystrix监控4.5.1 配置依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 4.5.2 启动类配置​ 在启动类上加上@EnableHystrixDashboard注解，如下图所示： 12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableCircuitBreaker@EnableHystrixDashboardpublic class ShopConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ShopConsumerApplication.class, args); &#125;&#125; 4.5.3 编写servlet入口12345678910@Beanpublic ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean;&#125; 4.5.4 访问Hystrix Dashboard​ 在输入框中输入：http://locahost:8080/actuator/hystrix.stream]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
</search>
