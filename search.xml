<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[oracle多表联查]]></title>
    <url>%2F2020%2F01%2F17%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%9A%E8%A1%A8%E8%81%94%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[一、on和where 的区别（1）on是在临时表生成时使用的条件，不管on中的条件是否为真，都会返回左(左连接中)/右(右连接)边表中的全部记录。（2）where是在临时表生成后使用的条件，是对临时表进行过滤的条件，不满足条件的就会被过滤掉。二、表连接的语法简写 全称 简称 inner join on (内连接) join on (连接) left outer join on (左外连接) left join on (左连接) right outer join on (右外连接) right join on (右连接) full outer join on (全外连接) full join on (全连接) 三、表连接的总结（1）inner join（内连接）：在两张表进行连接查询时，只保留两张表中完全匹配的结果集。PS：单纯的select from a,b是笛卡尔乘积。比如a表有3条数据，b表有3条数据，那么最后的结果有33=9条数据。如果对两个表进行连接查询:select from a,b where a.id = b.id，（不推荐）相当于：select from a inner join b on a.id = b.id。即内连接。（2）left join（左连接）：在两张表进行连接查询时，会返回左表所有的行，(即使在右表中没有匹配的记录)，右表不匹配的行会以null的形式显示。（3）right join（右连接）：在两张表进行连接查询时，会返回右表所有的行（即使在左表中没有匹配的记录）左表不匹配的行会以null的形式显示。（4）full join（全连接）：在两张表进行连接查询时，不管是否匹配，都会返回左表和右表中所有的数据。相当于是left join和right join的并集。四、图例表示表连接中的结果集（1）内连接 （2）左连接：右表中不匹配的数据将以NUll形式显示 （3）右连接：左表中不匹配的数据将以NUll形式显示 （4）全连接]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker/Kubernetes总结]]></title>
    <url>%2F2019%2F12%2F30%2FDocker-Kubernetes%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Docker/Kubernetes总结 一、Docker​ Docker-容器化，与传统Linux物理主机部署方式发生了改变，进程，线程隔离，不会因为一个应用的问题导致所有部署的程序乃至系统卡顿，管理工具有Docker三剑客，Compose、Machine、Swarm，虽然简化了docker操作，但是还是有许多问题，例如：自动扩缩容，多个容器管理不方便等问题。所以出现了Kubernetes，Rancher等管理工具，都是基于Docker之上安装。 二、Kubernetes​ Kubernetes容器编排工具，管理Docker，可以通过kubectl命令，或者kboard等图形化界面，操作简单，易于管理。一般使用为三主三从，以保证Kubernetes的高可用集群，博客里安装的是一主三从方式，如果master挂掉，整个kubernetes会失去操作，想要搭建三主三从方式，可以通过官网学习。或者下面推荐的网站学习。 三、深入学习Docker/k8sDocker 1.Docker官网 2.镜像仓库DockerHub 3.Docker中文社区 kubernetes 1.kuboard for K8S 提供中文支持 2.Kubernetes官网 官网从Kubernetes v1.17版本开始支持中文 3.kubernetes中文社区 四、个人总结​ 系统架构从传统的单体应用架构转变为现在的微服务架构（分布式系统开发），开发方式的转变，同时部署方式也发生了改变，从传统的将整个单体系统放到服务器的环境变为了多个服务放入容器当中，有利于系统的高可用，高并发，高负载，但是，同时增加了新的问题，开发当中，例如：客户端如何访问多个服务？服务之间如何通讯？多个服务如何管理？服务挂了怎么办？分布式事务如何解决等等，当然，这些问题都已经解决了，后面会有新的博客文章记录。如果以一个Java程序员来看，这些东西可以不用会，最主要的还是JavaSE、JavaEE、SpringBoot、Dubbo+Zookeeper、SpringCloudNetflix、SpringCloudAlibaba、MySQL、Oracle、中间件，至于Linux、Jenkins、Docker、K8s等等，其实和开发没什么关系，会使用GIT/SVN就够了。Docker与Kubernetes有许多东西没有记录，只是搭建了一个简单能用的环境，还需要深入学习，工作当中会使用就可以了，一般也轮不到程序员使用，都是由运维管理 五、后续学习 1.Istio Istio中文社区 Istio官网 2.Hadoop、Spark、pig、Zookeeper……大数据内容]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker/K8s总结</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Docker</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes命令]]></title>
    <url>%2F2019%2F12%2F30%2FKubernetes%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Kubectl 与 Docker 命令概述Docker 命令和 Kubectl 命令有很多相似的地方，Docker 操作容器，Kubectl 操作 Pod（容器的集合）等 运行容器 docker：docker run -d --restart=always -e DOMAIN=cluster --name nginx-app -p 80:80 nginx kubectl： kubectl run --image=nginx nginx-app --port=80 --env=&quot;DOMAIN=cluster&quot; kubectl expose deployment nginx-app --port=80 --name=nginx-http 注意： kubectl run 会创建一个 Deployment 并且默认会在后台运行，以上面的代码为例它的名称为 nginx-app。默认情况 Deployment 并不会将端口暴露出去，所以我们还需要使用 kubectl expose 暴露端口以供访问，此时还会创建一个同名的 Service 查看已运行的容器 docker：docker ps kubectl： kubectl get pods kubectl get deployment kubectl get service 交互式进入容器 docker：docker exec -it &lt;容器 ID/NAME&gt; /bin/bash kubectl：kubectl exec -it &lt;容器名&gt; -- /bin/bash 打印日志 docker：docker logs -f &lt;容器 ID/NAME&gt; kubectl：kubectl logs -f &lt;容器名&gt; 停止和删除容器 docker： docker stop &lt;容器 ID/NAME&gt; docker rm &lt;容器 ID/NAME&gt; kubectl： kubectl delete deployment kubectl delete service 注意： 不要直接删除 Pod，使用 kubectl 请删除拥有该 Pod 的 Deployment。如果直接删除 Pod，则 Deployment 将会重新创建该 Pod。 查看版本 docker：docker version kubectl：kubectl version 查看环境信息 docker：docker info kubectl：kubectl cluster-info]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker/K8s总结</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubectl 常用命令]]></title>
    <url>%2F2019%2F12%2F30%2FKubectl%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[小提示： 所有命令前都可以加上 watch 命令来观察状态的实时变化，如：watch kubectl get pods --all-namespaces 查看组件状态1kubectl get cs 查看环境信息1kubectl cluster-info 查看 Node1kubectl get nodes -o wide 查看集群配置1kubectl -n kube-system get cm kubeadm-config -oyaml 运行容器1kubectl run nginx --image=nginx --replicas=2 --port=80 暴露服务1kubectl expose deployment nginx --port=80 --type=LoadBalancer 查看命名空间1kubectl get namespace 创建命名空间1234apiVersion: v1kind: Namespacemetadata: name: development 查看容器12kubectl get pods -o widekubectl get deployment -o wide 查看服务1kubectl get service -o wide 查看详情123kubectl describe pod &lt;Pod Name&gt;kubectl describe deployment &lt;Deployment Name&gt;kubectl describe service &lt;Service Name&gt; 查看日志1kubectl logs -f &lt;Pod Name&gt; 删除容器和服务12kubectl delete deployment &lt;Deployment Name&gt;kubectl delete service &lt;Service Name&gt; 配置方式运行1kubectl create -f &lt;YAML&gt; 配置方式删除1kubectl delete -f &lt;YAML&gt; 查看配置12kubeadm config viewkubectl config view 查看 Ingress1kubectl get ingress 查看持久卷1kubectl get pv 查看持久卷消费者1kubectl get pvc 查看 ConfigMap1kubectl get cm &lt;ConfigMap Name&gt; 修改 ConfigMap1kubectl edit cm &lt;ConfigMap Name&gt;]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker/K8s总结</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker常用命令]]></title>
    <url>%2F2019%2F12%2F30%2FDocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker 常用命令查看 Docker 版本1docker version 从 Docker 文件构建 Docker 映像1docker build -t image-name docker-file-location 运行 Docker 映像1docker run -d image-name 查看可用的 Docker 映像1docker images 查看最近的运行容器1docker ps -l 查看所有正在运行的容器1docker ps -a 停止运行容器1docker stop container_id 删除一个镜像1docker rmi image-name 删除所有镜像1docker rmi $(docker images -q) 强制删除所有镜像1docker rmi -r $(docker images -q) 删除所有虚悬镜像1docker rmi $(docker images -q -f dangling=true) 删除所有容器1docker rm $(docker ps -a -q) 进入 Docker 容器1docker exec -it container-id /bin/bash 查看所有数据卷1docker volume ls 删除指定数据卷1docker volume rm [volume_name] 删除所有未关联的数据卷1docker volume rm $(docker volume ls -qf dangling=true) 从主机复制文件到容器1sudo docker cp host_path containerID:container_path 从容器复制文件到主机1sudo docker cp containerID:container_path host_path]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker/K8s总结</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes(Ubuntu)]]></title>
    <url>%2F2019%2F12%2F29%2FKubernetes(Ubuntu%E7%89%88)%2F</url>
    <content type="text"><![CDATA[基于Ubuntu18.04 Kubernetes(k8s安装) 一、什么是 Kubernetes概述 Kubernetes 是 Google 2014 年创建管理的，是 Google 10 多年大规模容器管理技术 Borg 的开源版本。 Kubernetes 是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。使用 Kubernetes 我们可以： 快速部署应用 快速扩展应用 无缝对接新的应用功能 节省资源，优化硬件资源的使用 Kubernetes 的目标是促进完善组件和工具的生态系统，以减轻应用程序在公有云或私有云中运行的负担。 特点 可移植： 支持公有云，私有云，混合云，多重云（多个公共云） 可扩展： 模块化，插件化，可挂载，可组合 自动化： 自动部署，自动重启，自动复制，自动伸缩/扩展 从传统到容器化部署 传统的部署方式传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。 容器化部署的优势 快速创建/部署应用： 与虚拟机相比，容器镜像的创建更加容易。 持续开发、集成和部署： 提供可靠且频繁的容器镜像构建/部署，并使用快速和简单的回滚(由于镜像不可变性)。 开发和运行相分离： 在 build 或者 release 阶段创建容器镜像，使得应用和基础设施解耦。 开发，测试和生产环境一致性： 在本地或外网（生产环境）运行的一致性。 云平台或其他操作系统： 可以在 Ubuntu、RHEL、CoreOS、on-prem、Google Container Engine 或其它任何环境中运行。 分布式，弹性，微服务化： 应用程序分为更小的、独立的部件，可以动态部署和管理。 资源隔离 资源利用更高效 为什么需要 Kubernetes可以在物理或虚拟机的 Kubernetes 集群上运行容器化应用，Kubernetes 能提供一个以 “容器为中心的基础架构”，满足在生产环境中运行应用的一些常见需求，如： 多个进程协同工作 存储系统挂载 应用健康检查 应用实例的复制 自动伸缩/扩展 注册与发现 负载均衡 滚动更新 资源监控 日志访问 调试应用程序 提供认证和授权 二、kubernetes 安装前的准备概述本次安装采用 Ubuntu Server X64 18.04 LTS 版本安装 kubernetes 集群环境，集群节点为 1 主 2 从模式，此次对虚拟机会有些基本要求，如下： OS：Ubuntu Server X64 18.04 LTS（16.04 版本步骤相同，再之前则不同） CPU：最低要求，1 CPU 2 核 内存：最低要求，2GB 磁盘：最低要求，20GB 创建三台虚拟机，分别命名如下： Ubuntu Server 18.04 X64 Kubernetes Master Ubuntu Server 18.04 X64 Kubernetes Slave1 Ubuntu Server 18.04 X64 Kubernetes Slave2 对虚拟机系统的配置： 关闭交换空间：sudo swapoff -a 避免开机启动交换空间：注释 /etc/fstab 中的 swap 关闭防火墙：ufw disable 使用 APT 安装 Docker安装123456789101112# 更新软件源sudo apt-get update# 安装所需依赖sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common# 安装 GPG 证书curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 新增软件源信息sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;# 再次更新软件源sudo apt-get -y update# 安装 Docker CE 版sudo apt-get -y install docker-ce 验证12345678910111213141516171819docker versionClient: Version: 18.09.6 API version: 1.39 Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 02:35:57 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.6 API version: 1.39 (minimum version 1.12) Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 01:59:36 2019 OS/Arch: linux/amd64 Experimental: false 配置加速器对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件） 12345&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ]&#125; 注意，一定要保证该文件符合 JSON 规范，否则 Docker 将不能启动 验证加速器是否配置成功： 1234567sudo systemctl restart dockerdocker info...# 出现如下语句即表示配置成功Registry Mirrors: https://registry.docker-cn.com/... 修改主机名在同一局域网中主机名不应该相同，所以我们需要做修改，下列操作步骤为修改 18.04 版本的 Hostname，如果是 16.04 或以下版本则直接修改 /etc/hostname 里的名称即可 查看当前 Hostname 123456789101112# 查看当前主机名hostnamectl# 显示如下内容 Static hostname: ubuntu Icon name: computer-vm Chassis: vm Machine ID: 33011e0a95094672b99a198eff07f652 Boot ID: dc856039f0d24164a9f8a50c506be96d Virtualization: vmware Operating System: Ubuntu 18.04.2 LTS Kernel: Linux 4.15.0-48-generic Architecture: x86-64 修改 Hostname 12# 使用 hostnamectl 命令修改，其中 kubernetes-master 为新的主机名hostnamectl set-hostname kubernetes-master 修改 cloud.cfg 如果 cloud-init package 安装了，需要修改 cloud.cfg 文件。该软件包通常缺省安装用于处理 cloud 12345# 如果有该文件vi /etc/cloud/cloud.cfg# 该配置默认为 false，修改为 true 即可preserve_hostname: true 验证 12345678910root@kubernetes-master:~# hostnamectl Static hostname: kubernetes-master Icon name: computer-vm Chassis: vm Machine ID: 33011e0a95094672b99a198eff07f652 Boot ID: 8c0fd75d08c644abaad3df565e6e4cbd Virtualization: vmware Operating System: Ubuntu 18.04.2 LTS Kernel: Linux 4.15.0-48-generic Architecture: x86-64 三、安装Kubeadm概述kubeadm 是 kubernetes 的集群安装工具，能够快速安装 kubernetes 集群。 配置软件源12345678# 安装系统工具apt-get update &amp;&amp; apt-get install -y apt-transport-https# 安装 GPG 证书curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -# 写入软件源；注意：我们用系统代号为 bionic，但目前阿里云不支持，所以沿用 16.04 的 xenialcat &lt;&lt; EOF &gt;/etc/apt/sources.list.d/kubernetes.list&gt; deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&gt; EOF 安装 kubeadm，kubelet，kubectl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 安装apt-get update apt-get install -y kubelet kubeadm kubectl# 安装过程如下，注意 kubeadm 的版本号Reading package lists... DoneBuilding dependency tree Reading state information... DoneThe following additional packages will be installed: conntrack cri-tools kubernetes-cni socatThe following NEW packages will be installed: conntrack cri-tools kubeadm kubectl kubelet kubernetes-cni socat0 upgraded, 7 newly installed, 0 to remove and 96 not upgraded.Need to get 50.6 MB of archives.After this operation, 290 MB of additional disk space will be used.Get:1 http://mirrors.aliyun.com/ubuntu bionic/main amd64 conntrack amd64 1:1.4.4+snapshot20161117-6ubuntu2 [30.6 kB]Get:2 http://mirrors.aliyun.com/ubuntu bionic/main amd64 socat amd64 1.7.3.2-2ubuntu2 [342 kB]Get:3 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 cri-tools amd64 1.12.0-00 [5,343 kB]Get:4 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubernetes-cni amd64 0.7.5-00 [6,473 kB]Get:5 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubelet amd64 1.14.1-00 [21.5 MB]Get:6 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubectl amd64 1.14.1-00 [8,806 kB]Get:7 https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial/main amd64 kubeadm amd64 1.14.1-00 [8,150 kB]Fetched 50.6 MB in 5s (9,912 kB/s) Selecting previously unselected package conntrack.(Reading database ... 67205 files and directories currently installed.)Preparing to unpack .../0-conntrack_1%3a1.4.4+snapshot20161117-6ubuntu2_amd64.deb ...Unpacking conntrack (1:1.4.4+snapshot20161117-6ubuntu2) ...Selecting previously unselected package cri-tools.Preparing to unpack .../1-cri-tools_1.12.0-00_amd64.deb ...Unpacking cri-tools (1.12.0-00) ...Selecting previously unselected package kubernetes-cni.Preparing to unpack .../2-kubernetes-cni_0.7.5-00_amd64.deb ...Unpacking kubernetes-cni (0.7.5-00) ...Selecting previously unselected package socat.Preparing to unpack .../3-socat_1.7.3.2-2ubuntu2_amd64.deb ...Unpacking socat (1.7.3.2-2ubuntu2) ...Selecting previously unselected package kubelet.Preparing to unpack .../4-kubelet_1.14.1-00_amd64.deb ...Unpacking kubelet (1.14.1-00) ...Selecting previously unselected package kubectl.Preparing to unpack .../5-kubectl_1.14.1-00_amd64.deb ...Unpacking kubectl (1.14.1-00) ...Selecting previously unselected package kubeadm.Preparing to unpack .../6-kubeadm_1.14.1-00_amd64.deb ...Unpacking kubeadm (1.14.1-00) ...Setting up conntrack (1:1.4.4+snapshot20161117-6ubuntu2) ...Setting up kubernetes-cni (0.7.5-00) ...Setting up cri-tools (1.12.0-00) ...Setting up socat (1.7.3.2-2ubuntu2) ...Setting up kubelet (1.14.1-00) ...Created symlink /etc/systemd/system/multi-user.target.wants/kubelet.service → /lib/systemd/system/kubelet.service.Setting up kubectl (1.14.1-00) ...Processing triggers for man-db (2.8.3-2ubuntu0.1) ...# 注意这里的版本号，我们使用的是 kubernetes v1.14.1Setting up kubeadm (1.14.1-00) ...# 设置 kubelet 自启动，并启动 kubeletsystemctl enable kubelet &amp;&amp; systemctl start kubelet kubeadm：用于初始化 Kubernetes 集群 kubectl：Kubernetes 的命令行工具，主要作用是部署和管理应用，查看各种资源，创建，删除和更新组件 kubelet：主要负责启动 Pod 和容器 四、配置 kubeadm概述安装 kubernetes 主要是安装它的各个镜像，而 kubeadm 已经为我们集成好了运行 kubernetes 所需的基本镜像。但由于国内的网络原因，在搭建环境时，无法拉取到这些镜像。此时我们只需要修改为阿里云提供的镜像服务即可解决该问题。 创建并修改配置12# 导出配置文件kubeadm config print init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 修改配置为如下内容apiVersion: kubeadm.k8s.io/v1beta1bootstrapTokens:- groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authenticationkind: InitConfigurationlocalAPIEndpoint: # 修改为主节点 IP advertiseAddress: 192.168.141.130 bindPort: 6443nodeRegistration: criSocket: /var/run/dockershim.sock name: kubernetes-master taints: - effect: NoSchedule key: node-role.kubernetes.io/master---apiServer: timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta1certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrolPlaneEndpoint: &quot;&quot;controllerManager: &#123;&#125;dns: type: CoreDNSetcd: local: dataDir: /var/lib/etcd# 国内不能访问 Google，修改为阿里云imageRepository: registry.aliyuncs.com/google_containerskind: ClusterConfiguration# 修改版本号kubernetesVersion: v1.14.1networking: dnsDomain: cluster.local # 配置成 Calico 的默认网段 podSubnet: &quot;192.168.0.0/16&quot; serviceSubnet: 10.96.0.0/12scheduler: &#123;&#125;---# 开启 IPVS 模式apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: KubeProxyConfigurationfeatureGates: SupportIPVSProxyMode: truemode: ipvs 查看和拉取镜像1234# 查看所需镜像列表kubeadm config images list --config kubeadm.yml# 拉取镜像kubeadm config images pull --config kubeadm.yml 五、使用 kubeadm 配置 slave 节点概述将 slave 节点加入到集群中很简单，只需要在 slave 服务器上安装 kubeadm，kubectl，kubelet 三个工具，然后使用 kubeadm join 命令加入即可。准备工作如下： 修改主机名 配置软件源 安装三个工具 由于之前章节已经说明了操作步骤，此处不再赘述。 将 slave 加入到集群123456789101112131415161718kubeadm join 192.168.141.130:6443 --token abcdef.0123456789abcdef --discovery-token-ca-cert-hash sha256:cab7c86212535adde6b8d1c7415e81847715cfc8629bb1d270b601744d662515# 安装成功将看到如下信息[preflight] Running pre-flight checks [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/[preflight] Reading configuration from the cluster...[preflight] FYI: You can look at this config file with &apos;kubectl -n kube-system get cm kubeadm-config -oyaml&apos;[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.14&quot; ConfigMap in the kube-system namespace[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;[kubelet-start] Activating the kubelet service[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...This node has joined the cluster:* Certificate signing request was sent to apiserver and a response was received.* The Kubelet was informed of the new secure connection details.Run &apos;kubectl get nodes&apos; on the control-plane to see this node join the cluster. 说明： token 可以通过安装 master 时的日志查看 token 信息 可以通过 kubeadm token list 命令打印出 token 信息 如果 token 过期，可以使用 kubeadm token create 命令创建新的 token discovery-token-ca-cert-hash 可以通过安装 master 时的日志查看 sha256 信息 可以通过 openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed &#39;s/^.* //&#39; 命令查看 sha256 信息 以上方式感谢群友 停 驻 提供。 验证是否成功回到 master 服务器 123456kubectl get nodes# 可以看到 slave 成功加入 masterNAME STATUS ROLES AGE VERSIONkubernetes-master NotReady master 9h v1.14.1kubernetes-slave1 NotReady &lt;none&gt; 22s v1.14.1 如果 slave 节点加入 master 时配置有问题可以在 slave 节点上使用 kubeadm reset 重置配置再使用 kubeadm join 命令重新加入即可。希望在 master 节点删除 node ，可以使用 kubeadm delete nodes 删除。 查看 pod 状态1234567891011kubectl get pod -n kube-system -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATEScoredns-8686dcc4fd-gwrmb 0/1 Pending 0 9h &lt;none&gt; &lt;none&gt; &lt;none&gt; &lt;none&gt;coredns-8686dcc4fd-j6gfk 0/1 Pending 0 9h &lt;none&gt; &lt;none&gt; &lt;none&gt; &lt;none&gt;etcd-kubernetes-master 1/1 Running 1 9h 192.168.141.130 kubernetes-master &lt;none&gt; &lt;none&gt;kube-apiserver-kubernetes-master 1/1 Running 1 9h 192.168.141.130 kubernetes-master &lt;none&gt; &lt;none&gt;kube-controller-manager-kubernetes-master 1/1 Running 1 9h 192.168.141.130 kubernetes-master &lt;none&gt; &lt;none&gt;kube-proxy-496dr 1/1 Running 0 17m 192.168.141.131 kubernetes-slave1 &lt;none&gt; &lt;none&gt;kube-proxy-rsnb6 1/1 Running 1 9h 192.168.141.130 kubernetes-master &lt;none&gt; &lt;none&gt;kube-scheduler-kubernetes-master 1/1 Running 1 由此可以看出 coredns 尚未运行，此时我们还需要安装网络插件。 六、配置网络概述容器网络是容器选择连接到其他容器、主机和外部网络的机制。容器的 runtime 提供了各种网络模式，每种模式都会产生不同的体验。例如，Docker 默认情况下可以为容器配置以下网络： none： 将容器添加到一个容器专门的网络堆栈中，没有对外连接。 host： 将容器添加到主机的网络堆栈中，没有隔离。 default bridge： 默认网络模式。每个容器可以通过 IP 地址相互连接。 自定义网桥： 用户定义的网桥，具有更多的灵活性、隔离性和其他便利功能。 什么是 CNICNI(Container Network Interface) 是一个标准的，通用的接口。在容器平台，Docker，Kubernetes，Mesos 容器网络解决方案 flannel，calico，weave。只要提供一个标准的接口，就能为同样满足该协议的所有容器平台提供网络功能，而 CNI 正是这样的一个标准接口协议。 Kubernetes 中的 CNI 插件CNI 的初衷是创建一个框架，用于在配置或销毁容器时动态配置适当的网络配置和资源。插件负责为接口配置和管理 IP 地址，并且通常提供与 IP 管理、每个容器的 IP 分配、以及多主机连接相关的功能。容器运行时会调用网络插件，从而在容器启动时分配 IP 地址并配置网络，并在删除容器时再次调用它以清理这些资源。 运行时或协调器决定了容器应该加入哪个网络以及它需要调用哪个插件。然后，插件会将接口添加到容器网络命名空间中，作为一个 veth 对的一侧。接着，它会在主机上进行更改，包括将 veth 的其他部分连接到网桥。再之后，它会通过调用单独的 IPAM（IP地址管理）插件来分配 IP 地址并设置路由。 在 Kubernetes 中，kubelet 可以在适当的时间调用它找到的插件，为通过 kubelet 启动的 pod进行自动的网络配置。 Kubernetes 中可选的 CNI 插件如下： Flannel Calico Canal Weave 什么是 CalicoCalico 为容器和虚拟机提供了安全的网络连接解决方案，并经过了大规模生产验证（在公有云和跨数千个集群节点中），可与 Kubernetes，OpenShift，Docker，Mesos，DC / OS 和 OpenStack 集成。 Calico 还提供网络安全规则的动态实施。使用 Calico 的简单策略语言，您可以实现对容器，虚拟机工作负载和裸机主机端点之间通信的细粒度控制。 安装网络插件 Calico 注意：截止到文章发表日期 2019 年 05 月 11 日，Calico 官方版本为 3.7 参考官方文档安装：https://docs.projectcalico.org/v3.7/getting-started/kubernetes/ 123456789101112131415161718192021222324252627# 在 Master 节点操作即可kubectl apply -f https://docs.projectcalico.org/v3.7/manifests/calico.yaml# 安装时显示如下输出configmap/calico-config createdcustomresourcedefinition.apiextensions.k8s.io/felixconfigurations.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/ipamblocks.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/blockaffinities.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/ipamhandles.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/ipamconfigs.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/bgppeers.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/bgpconfigurations.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/ippools.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/hostendpoints.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/clusterinformations.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/globalnetworkpolicies.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/globalnetworksets.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/networkpolicies.crd.projectcalico.org createdcustomresourcedefinition.apiextensions.k8s.io/networksets.crd.projectcalico.org createdclusterrole.rbac.authorization.k8s.io/calico-kube-controllers createdclusterrolebinding.rbac.authorization.k8s.io/calico-kube-controllers createdclusterrole.rbac.authorization.k8s.io/calico-node createdclusterrolebinding.rbac.authorization.k8s.io/calico-node createddaemonset.extensions/calico-node createdserviceaccount/calico-node createddeployment.extensions/calico-kube-controllers createdserviceaccount/calico-kube-controllers created 确认安装是否成功 123456789101112131415watch kubectl get pods --all-namespaces# 需要等待所有状态为 Running，注意时间可能较久，3 - 5 分钟的样子Every 2.0s: kubectl get pods --all-namespaces kubernetes-master: Fri May 10 18:16:51 2019NAMESPACE NAME READY STATUS RESTARTS AGEkube-system calico-kube-controllers-8646dd497f-g2lln 1/1 Running 0 50mkube-system calico-node-8jrtp 1/1 Running 0 50mkube-system coredns-8686dcc4fd-mhwfn 1/1 Running 0 51mkube-system coredns-8686dcc4fd-xsxwk 1/1 Running 0 51mkube-system etcd-kubernetes-master 1/1 Running 0 50mkube-system kube-apiserver-kubernetes-master 1/1 Running 0 51mkube-system kube-controller-manager-kubernetes-master 1/1 Running 0 51mkube-system kube-proxy-p8mdw 1/1 Running 0 51mkube-system kube-scheduler-kubernetes-master 1/1 Running 0 51m 至此基本环境已部署完毕。 解决 ImagePullBackOff在使用 watch kubectl get pods --all-namespaces 命令观察 Pods 状态时如果出现 ImagePullBackOff 无法 Running 的情况，请尝试使用如下步骤处理： Master 中删除 Nodes：kubectl delete nodes Slave 中重置配置：kubeadm reset Slave 重启计算机：reboot Slave 重新加入集群：kubeadm join 附：配置固定 IP 和 DNS当关机后再启动虚拟机有时 IP 地址会自动更换，导致之前的配置不可用；配置完 Kubernetes 网络后虚拟机还会出现无法联网的情况，后经研究发现是 DNS 会被自动重写所致，Ubuntu Server 18.04 LTS 版本的 IP 和 DNS 配置也与之前的版本配置大相径庭，故在此说明下如何修改 IP 和 DNS 修改固定 IP编辑 vi /etc/netplan/50-cloud-init.yaml 配置文件，注意这里的配置文件名未必和你机器上的相同，请根据实际情况修改。修改内容如下： 12345678network: ethernets: ens33: addresses: [192.168.141.134/24] gateway4: 192.168.141.2 nameservers: addresses: [192.168.141.2] version: 2 使配置生效 netplan apply 修改 DNS方法一 停止 systemd-resolved 服务：systemctl stop systemd-resolved 修改 DNS：vi /etc/resolv.conf，将 nameserver 修改为如 114.114.114.114 可以正常使用的 DNS 地址 方法二1vi /etc/systemd/resolved.conf 把 DNS 取消注释，添加 DNS，保存退出，重启即可 七、第一个 Kubernetes 容器检查组件运行状态12345678910kubectl get cs# 输出如下NAME STATUS MESSAGE ERROR# 调度服务，主要作用是将 POD 调度到 Nodescheduler Healthy ok # 自动化修复服务，主要作用是 Node 宕机后自动修复 Node 回到正常的工作状态controller-manager Healthy ok # 服务注册与发现etcd-0 Healthy &#123;"health":"true"&#125; 检查 Master 状态123456789kubectl cluster-info# 输出如下# 主节点状态Kubernetes master is running at https://192.168.141.130:6443# DNS 状态KubeDNS is running at https://192.168.141.130:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxyTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. 检查 Nodes 状态1234567kubectl get nodes# 输出如下，STATUS 为 Ready 即为正常状态NAME STATUS ROLES AGE VERSIONkubernetes-master Ready master 44h v1.14.1kubernetes-slave1 Ready &lt;none&gt; 3h38m v1.14.1kubernetes-slave2 Ready &lt;none&gt; 3h37m v1.14.1 运行第一个容器实例123456# 使用 kubectl 命令创建两个监听 80 端口的 Nginx Pod（Kubernetes 运行容器的最小单元）kubectl run nginx --image=nginx --replicas=2 --port=80# 输出如下kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.deployment.apps/nginx created 查看全部 Pods 的状态123456kubectl get pods# 输出如下，需要等待一小段实践，STATUS 为 Running 即为运行成功NAME READY STATUS RESTARTS AGEnginx-755464dd6c-qnmwp 1/1 Running 0 90mnginx-755464dd6c-shqrp 1/1 Running 0 90m 查看已部署的服务12345kubectl get deployment# 输出如下NAME READY UP-TO-DATE AVAILABLE AGEnginx 2/2 2 2 91m 映射服务，让用户可以访问1234kubectl expose deployment nginx --port=80 --type=LoadBalancer# 输出如下service/nginx exposed 查看已发布的服务1234567kubectl get services# 输出如下NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 44h# 由此可见，Nginx 服务已成功发布并将 80 端口映射为 31738nginx LoadBalancer 10.108.121.244 &lt;pending&gt; 80:31738/TCP 88m 查看服务详情1234567891011121314151617kubectl describe service nginx# 输出如下Name: nginxNamespace: defaultLabels: run=nginxAnnotations: &lt;none&gt;Selector: run=nginxType: LoadBalancerIP: 10.108.121.244Port: &lt;unset&gt; 80/TCPTargetPort: 80/TCPNodePort: &lt;unset&gt; 31738/TCPEndpoints: 192.168.17.5:80,192.168.8.134:80Session Affinity: NoneExternal Traffic Policy: ClusterEvents: &lt;none&gt; 验证是否成功通过浏览器访问 Master 服务器 1http://192.168.141.130:31738/ 此时 Kubernetes 会以负载均衡的方式访问部署的 Nginx 服务，能够正常看到 Nginx 的欢迎页即表示成功。容器实际部署在其它 Node 节点上，通过访问 Node 节点的 IP:Port 也是可以的。 停止服务1234kubectl delete deployment nginx# 输出如下deployment.extensions "nginx" deleted 1234kubectl delete service nginx# 输出如下service "nginx" deleted]]></content>
      <categories>
        <category>Linux</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Docker</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes(Centos版)]]></title>
    <url>%2F2019%2F12%2F29%2FKubernetes%EF%BC%88Centos%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基于Centos 7 Kubernetes(k8s安装) 1.准备本次安装采用 Centos 7 版本安装 kubernetes 集群环境，集群节点为 1 主 2 从模式，此次对虚拟机会有些基本要求，如下： OS：Centos7 CPU：最低要求，1 CPU 2 核 内存：最低要求，2GB 磁盘：最低要求，20GB 创建三台虚拟机，分别命名如下： Centos7 Kubernetes Master Centos7 Kubernetes Slave1 Centos7 Kubernetes Slave2 对虚拟机系统的配置： 关闭交换空间：sudo swapoff -a 避免开机启动交换空间：注释 /etc/fstab 中的 swap 关闭防火墙：ufw disable 2.Docker安装参考前面做过的Docker安装/](https://woshibaize.github.io/2019/12/08/Docker安装(Centos版)/) 验证12345678910111213141516171819docker versionClient: Version: 18.09.6 API version: 1.39 Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 02:35:57 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.6 API version: 1.39 (minimum version 1.12) Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 01:59:36 2019 OS/Arch: linux/amd64 Experimental: false 配置加速器对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件） 123456# 此处为docker在国内的镜像地址，建议配置阿里的，在Docker安装文章中写过配置方式&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ]&#125; 注意，一定要保证该文件符合 JSON 规范，否则 Docker 将不能启动。 验证加速器是否配置成功： 1234567sudo systemctl restart dockerdocker info...# 出现如下语句即表示配置成功Registry Mirrors: https://registry.docker-cn.com/... 修改主机名1234# 查看当前主机名hostnamectl# 使用 hostnamectl 命令修改，其中 kubernetes-master 为新的主机名hostnamectl set-hostname kubernetes-master 3.安装Kubelet1234# 在 master 节点和 worker 节点都要执行# 最后一个参数 1.17.0 用于指定 kubenetes 版本，支持所有 1.17.x 版本的安装curl -sSL https://kuboard.cn/install-script/v1.17.x/install_kubelet.sh | sh -s 1.17.0 4.初始化master节点 关于初始化时用到的环境变量 APISERVER_NAME 不能是 master 的 hostname APISERVER_NAME 必须全为小写字母、数字、小数点，不能包含减号 POD_SUBNET 所使用的网段不能与 master节点/worker节点 所在的网段重叠。该字段的取值为一个 CIDR 值，如果您对 CIDR 这个概念还不熟悉，请仍然执行 export POD_SUBNET=10.100.0.1/16 命令，不做修改 12345678910# 只在 master 节点执行# 替换 x.x.x.x 为 master 节点实际 IP（请使用内网 IP）# export 命令只在当前 shell 会话中有效，开启新的 shell 窗口后，如果要继续安装过程，请重新执行此处的 export 命令export MASTER_IP=x.x.x.x# 替换 apiserver.demo 为 您想要的 dnsNameexport APISERVER_NAME=apiserver.demo# Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中export POD_SUBNET=10.100.0.1/16echo &quot;$&#123;MASTER_IP&#125; $&#123;APISERVER_NAME&#125;&quot; &gt;&gt; /etc/hostscurl -sSL https://kuboard.cn/install-script/v1.17.x/init_master.sh | sh -s 1.17.0 如果出错 请确保您的环境符合 安装docker及kubelet 中所有勾选框的要求 请确保您使用 root 用户执行初始化命令 不能下载 kubernetes 的 docker 镜像 安装文档中，默认使用阿里云的 docker 镜像仓库，然而，有时候，该镜像会罢工 如碰到不能下载 docker 镜像的情况，请尝试手工初始化，并修改手工初始化脚本里的第22行（文档中已高亮）为： 1imageRepository: gcr.azk8s.cn/google-containers 检查环境变量，执行如下命令 1echo MASTER_IP=$&#123;MASTER_IP&#125; &amp;&amp; echo APISERVER_NAME=$&#123;APISERVER_NAME&#125; &amp;&amp; echo POD_SUBNET=$&#123;POD_SUBNET&#125; 请验证如下几点： 环境变量 MASTER_IP 的值应该为 master 节点的 内网IP，如果不是，请重新 export APISERVER_NAME 不能是 master 的 hostname APISERVER_NAME 必须全为小写字母、数字、小数点，不能包含减号 POD_SUBNET 所使用的网段不能与 master节点/worker节点 所在的网段重叠。该字段的取值为一个 CIDR 值，如果您对 CIDR 这个概念还不熟悉，请仍然执行 export POD_SUBNET=10.100.0.1/16 命令，不做修改 重新初始化 master 节点前，请先执行 kubeadm reset -f 操作 检查 master 初始化结果 1234567# 只在 master 节点执行# 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态watch kubectl get pod -n kube-system -o wide# 查看 master 节点初始化结果kubectl get nodes -o wide 5.初始化 worker节点获得 join命令参数在 master 节点上执行 12# 只在 master 节点执行kubeadm token create --print-join-command 可获取kubeadm join 命令及参数，如下所示 12# kubeadm token create 命令的输出kubeadm join apiserver.demo:6443 --token mpfjma.4vjjg8flqihor4vt --discovery-token-ca-cert-hash sha256:6f7a8e40a810323672de5eee6f4d19aa2dbdb38411845a1bf5dd63485c43d303 有效时间 该 token 的有效时间为 2 个小时，2小时内，您可以使用此 token 初始化任意数量的 worker 节点。 初始化worker针对所有的 worker 节点执行 123456789# 只在 worker 节点执行# 替换 x.x.x.x 为 master 节点的内网 IPexport MASTER_IP=x.x.x.x# 替换 apiserver.demo 为初始化 master 节点时所使用的 APISERVER_NAMEexport APISERVER_NAME=apiserver.demoecho &quot;$&#123;MASTER_IP&#125; $&#123;APISERVER_NAME&#125;&quot; &gt;&gt; /etc/hosts# 替换为 master 节点上 kubeadm token create 命令的输出kubeadm join apiserver.demo:6443 --token mpfjma.4vjjg8flqihor4vt --discovery-token-ca-cert-hash sha256:6f7a8e40a810323672de5eee6f4d19aa2dbdb38411845a1bf5dd63485c43d303 如果出错常见错误原因经常在群里提问为什么 join 不成功的情况大致有这几种： worker 节点不能访问 apiserver在worker节点执行以下语句可验证worker节点是否能访问 apiserver 1curl -ik https://apiserver.demo:6443 如果不能，请在 master 节点上验证 1curl -ik https://localhost:6443 正常输出结果如下所示： 123456789101112HTTP/1.1 403 ForbiddenCache-Control: no-cache, privateContent-Type: application/jsonX-Content-Type-Options: nosniffDate: Fri, 15 Nov 2019 04:34:40 GMTContent-Length: 233&#123; &quot;kind&quot;: &quot;Status&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: &#123;... 可能原因 如果 master 节点能够访问 apiserver、而 worker 节点不能，则请检查自己的网络设置 /etc/hosts 是否正确设置？ 是否有安全组或防火墙的限制？ worker 节点默认网卡 Kubelet使用的 IP 地址 与 master 节点可互通（无需 NAT 映射），且没有防火墙、安全组隔离 如果你使用 vmware 或 virtualbox 创建虚拟机用于 K8S 学习，可以尝试 NAT 模式的网络，而不是桥接模式的网络 移除worker节点并重试 WARNING 正常情况下，您无需移除 worker 节点，如果添加到集群出错，您可以移除 worker 节点，再重新尝试添加 在准备移除的 worker 节点上执行 12# 只在 worker 节点执行kubeadm reset -f 在 master 节点 demo-master-a-1 上执行 12# 只在 master 节点执行kubectl get nodes -o wide 如果列表中没有您要移除的节点，则忽略下一个步骤 12# 只在 master 节点执行kubectl delete node demo-worker-x-x TIP 将 demo-worker-x-x 替换为要移除的 worker 节点的名字 worker 节点的名字可以通过在节点 demo-master-a-1 上执行 kubectl get nodes 命令获得 检查初始化结果在 master 节点上执行 12# 只在 master 节点执行kubectl get nodes -o wide 输出结果如下所示： 12345[root@demo-master-a-1 ~]# kubectl get nodesNAME STATUS ROLES AGE VERSIONdemo-master-a-1 Ready master 5m3s v1.17.xdemo-worker-a-1 Ready &lt;none&gt; 2m26s v1.17.xdemo-worker-a-2 Ready &lt;none&gt; 3m56s v1.17.x 6.安装 Ingress Controller在 master 节点上执行 12# 只在 master 节点执行kubectl apply -f https://kuboard.cn/install-script/v1.17.x/nginx-ingress.yaml 配置域名解析 将域名 *.demo.yourdomain.com 解析到 demo-worker-a-2 的 IP 地址 z.z.z.z （也可以是 demo-worker-a-1 的地址 y.y.y.y） 验证配置 在浏览器访问 a.demo.yourdomain.com，将得到 404 NotFound 错误页面 提示 许多初学者在安装 Ingress Controller 时会碰到问题，请不要灰心，可暂时跳过 安装 Ingress Controller 这个部分，等您学完 www.kuboard.cn 上 Kubernetes 入门 以及 通过互联网访问您的应用程序 这两部分内容后，再来回顾 Ingress Controller 的安装。 WARNING 如果您打算将 Kubernetes 用于生产环境，请参考此文档 Installing Ingress Controller，完善 Ingress 的配置]]></content>
      <categories>
        <category>Linux</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Docker</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装(Ubuntu版)]]></title>
    <url>%2F2019%2F12%2F28%2FDocker%E5%AE%89%E8%A3%85(Ubuntu%E7%89%88)%2F</url>
    <content type="text"><![CDATA[基于Ubuntu 18.04 Docker安装 1.Ubuntu更改静态IProot@ubuntu:~# vim /etc/netplan/50-cloud-init.yaml123456789101112network: ethernets: eth0: addresses: - 192.168.15.72/20 gateway4: 192.168.12.2 nameservers: addresses: - 223.5.5.5 search: [] optional: true version: 2 root@ubuntu:~# netplan apply2.Ubuntu18.04更新软件包123sudo gedit /etc/apt/sources.list # 编辑软件源apt-get update -y # 更新软件列表sudo apt-get upgrade # 跟新软件 3.Docker安装系统要求Docker CE 支持以下版本的 Ubuntu 操作系统： Artful 17.10 (Docker CE 17.11 Edge +) Xenial 16.04 (LTS) Trusty 14.04 (LTS) Docker CE 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本,当前最新的 LTS 版本为 Ubuntu 16.04。 卸载旧版本123$ sudo apt-get remove docker \ docker-engine \ docker.io Ubuntu 14.04 可选内核模块从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (linux-image-extra-*) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。 如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包： 12345$ sudo apt-get update$ sudo apt-get install \ linux-image-extra-$(uname -r) \ linux-image-extra-virtual Ubuntu 16.04 +使用APT安装Ubuntu 16.04 + 上的 Docker CE 默认使用 overlay2 存储层驱动,无需手动配置。 安装必要的一些系统工具12sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common 安装 GPG 证书1curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 写入软件源信息1sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; 更新并安装 Docker CE12sudo apt-get -y updatesudo apt-get -y install docker-ce 以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要最新或者测试版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 镜像源也会包含稳定版本的 Docker。 使用脚本自动安装在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装： 123$ curl -fsSL get.docker.com -o get-docker.sh# 可能会出现 404 错误，请移步下面的特别说明$ sudo sh get-docker.sh --mirror Aliyun 特别说明2018 年 7 月 21 日，貌似阿里云这边在做调整，故导致 Docker 的 Aliyun 安装脚本不可用，是永久性还是临时性的尚不清除，如果你已经按照之前的操作安装 Docker，请按以下步骤进行修复并重新安装 如果已经使用了 Aliyun 脚本安装并成功的 请先卸载 Docker，命令为：apt-get autoremove docker-ce 删除 /etc/apt/sources.list.d 目录下的 docker.list 文件 使用 AzureChinaCloud 镜像脚本重新安装，命令为：sudo sh get-docker.sh --mirror AzureChinaCloud 启动 Docker CE12$ sudo systemctl enable docker$ sudo systemctl start docker Ubuntu 14.04 请使用以下命令启动： 1$ sudo service docker start 建立 docker 用户组默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： 1$ sudo groupadd docker 将当前用户加入 docker 组： 1$ sudo usermod -aG docker $USER 退出当前终端并重新登录，进行如下测试 测试 Docker 是否安装正确12345678910111213141516171819202122232425262728$ docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-worldca4f61b1923c: Pull completeDigest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905cStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 若能正常输出以上信息，则说明安装成功。 镜像加速器阿里云登录后，搜索容器镜像服务—&gt;镜像加速器，选择适合自己的操作系统]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>IP</tag>
        <tag>系统更新</tag>
        <tag>微服务架构</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装(Centos版)]]></title>
    <url>%2F2019%2F12%2F28%2FDocker%E5%AE%89%E8%A3%85(Centos%E7%89%88)%2F</url>
    <content type="text"><![CDATA[基于Centos 7Docker安装 1.Centos7更改静态IP1234567891011root@localhost:~# vim /etc/sysconfig/network-scripts/ifcfg-ens33# 把dhcp改成staticBOOTPROTO=&quot;static&quot;# 以下为增加内容IPADDR=&quot;XXX.XXX.XXX.XXX&quot;NETMASK=&quot;255.255.255.0&quot;GATEWAY=&quot;XXX.XXX.XXX.XXX&quot;DNS1=&quot;XXX.XXX.XXX.XXX&quot;root@localhost:~# vim /etc/resolv.confnameserver xxx.xxx.xxx.xxx #第二种更改DNS方式 更改生效：1service network restart 或者 systemctl restart network 2.Centos7更新软件包与删除指定内核12345671. yum update -y # 更新系统内核，会重新下载一个新的2. uname -sr # 查看当前使用的系统内核3. rpm -q kernel # 搜索查看当前机器上所有的内核4. yum remove kernel-3.10.0-123.el7.x86_64 kernel-devel-3.10.0-123.el7.x86_64或者 rpm -e kernel-3.10.0-123.el7.x86_64 # 删除指定的内核5. reboot # 重启6. rpm -qa|grep kernel* # 再次查看所有内核 3.指定版本docker安装1234567891011121314151617181920212223242526272829301. 更新软件包 sudo yum update 2. 卸载原来安装 sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine3.清空docker包 rm -rf /var/lib/docker/4.安装所需包 sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm25.设置稳定存储库 sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo6.安装默认最新 sudo yum install docker-ce docker-ce-cli containerd.io7.安装特定版本（查看有哪些版本） yum list docker-ce --showduplicates | sort -r8. 更换&lt;VERSION_STRING&gt;选择的版本 sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io9.启动docker并设置开机自启 sudo systemctl start docker sudo systemctl enable docker]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Docker</tag>
        <tag>IP</tag>
        <tag>系统更新</tag>
        <tag>Centos 7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架整体概况]]></title>
    <url>%2F2016%2F06%2F04%2Fmybatis%E6%A1%86%E6%9E%B6%E6%95%B4%E4%BD%93%E6%A6%82%E5%86%B5%2F</url>
    <content type="text"><![CDATA[一、MyBatis 框架概况1.1 MyBatis框架简介（1） MyBatis框架就是对JDBC的封装.主要目的简化JDBC开发流程,实现事务松耦合管理,将实体类与SQL命令进行动态对应.（2） 起源于Apache的Ibatis项目,2010年迁移到Google.被正式命名为MyBatis.最后在2013年迁移到Github（3） MyBatis框架使用简单,同时由于提供了中文官方文档,一般在一天左右即可以掌握.1.2 MyBatis下载MyBatis的官网： https://github.com/mybatis/mybatis-3 1.3 MyBatis框架执行流程 1.将sql语句和数据库配置信息保存在配置文件 2.在MyBatis运行时，将配置信息存储Configuration对象 3.在创建SqlSession对象提供属性 1） Configuration对象 2） dirty:true sql语句执行完毕后 可以事务提交false sql语句执行发送错误 事务进行回滚 3） Executor执行器对象：创建Statement对象，在创建过程中 依靠MapperStatement对象将赋值内容与sql占位符 进行绑定 4.SqlSession.commit(): 根据此时dirty属性决定提交和回滚 5.SqlSession.close(); 12345678910111213141516171819202122&lt;? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatiss.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;properties resource=&quot;config.properties&quot;&gt;&lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environments&gt; &lt;mappers&gt; &lt;package name=&quot;com.kaikeba.dao&quot;&gt; &lt;/mappers&gt; &lt;/configuration&gt;]]></content>
      <categories>
        <category>SSM</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>单体应用架构</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
</search>
